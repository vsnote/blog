<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Flux on 陈三</title>
    <link>https://www.zfanw.com/blog/tags/flux/</link>
    <description>Recent content in Flux on 陈三</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Mon, 21 Sep 2015 12:55:26 +0000</lastBuildDate>
    <atom:link href="https://www.zfanw.com/blog/tags/flux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>react.js 里测试 flux 架构的 store</title>
      <link>https://www.zfanw.com/blog/react-js-flux-test-store.html</link>
      <pubDate>Mon, 21 Sep 2015 12:55:26 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/react-js-flux-test-store.html</guid>
      <description>

&lt;p&gt;在 &lt;a href=&#34;https://facebook.github.io/flux/&#34;&gt;flux 架构&lt;/a&gt;​的 react.js 项目里，我写过 component 的测试，略为无趣；但 store 的测试则相对有趣多了。&lt;/p&gt;

&lt;p&gt;​想想，一个 action 分发后，store 就会相应做出变化，就好像你跟喜欢的人​​表白，保证能得到 yes 的回应似的 &amp;#8211; 让人欣喜。&lt;/p&gt;

&lt;p&gt;我们要用到的测试框架不是 &lt;a href=&#34;http://mochajs.org/&#34;&gt;Mocha&lt;/a&gt;，不是 &lt;a href=&#34;http://jasmine.github.io/&#34;&gt;Jasmine&lt;/a&gt;，而是 facebook 出品的基于 Jasmine 的 &lt;a href=&#34;https://github.com/facebook/jest&#34;&gt;jest&lt;/a&gt;，据 react.js 官方说，他们都用这个测试，不过我敢保证，你一定会遇上各种问题。&lt;/p&gt;

&lt;p&gt;且把这些担忧放到一边，来看一个简单的 &lt;a href=&#34;https://www.zfanw.com/react/demo-store-test/&#34;&gt;react.js 项目&lt;/a&gt;，源码托管在 &lt;a href=&#34;https://github.com/chenxsan/demo-jest-test-flux-store/blob/master/__tests__/TodoStore.test.js&#34;&gt;github&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;它只有一个输入框，&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;输入内容并回车&lt;/li&gt;
&lt;li&gt;触发一个 action&lt;/li&gt;
&lt;li&gt;这个 action 继而触发了 store 里的回调&lt;/li&gt;
&lt;li&gt;回调修改了 store 中的 model 数据&lt;/li&gt;
&lt;li&gt;store 射出事件&lt;/li&gt;
&lt;li&gt;监听 store 的 view 重新读取 store 中的数据、设置 state、重新 render 组件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这是 flux 原始实现的整个流程。&lt;/p&gt;

&lt;p&gt;因为 store 中的操作都是同步的，所以测试就非常便捷了。&lt;/p&gt;

&lt;p&gt;但使用 jest 有几个注意事项：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;最好使用 node.js 4.x.x&lt;/li&gt;
&lt;li&gt;如果你要用 es6 写法，需要使用 &lt;a href=&#34;https://github.com/babel/babel-jest&#34;&gt;babel-jest&lt;/a&gt; 一类预处理器&lt;/li&gt;
&lt;li&gt;如果用 es6 写法，要测试的 store 不能使用 &lt;code&gt;import&lt;/code&gt;，而必须使用 &lt;code&gt;require&lt;/code&gt;，因为 &lt;code&gt;import&lt;/code&gt; &lt;a href=&#34;https://github.com/babel/babel-jest/issues/16#issuecomment-104063719&#34;&gt;会被置前&lt;/a&gt;，导致 &lt;code&gt;jest.dontMock&lt;/code&gt; 失效&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;来看测试代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jest.dontMock(&#39;object-assign&#39;)
jest.dontMock(&#39;../src/stores/Todo&#39;)

describe(&#39;TodoStore&#39;, () =&amp;gt; {
  let AppDispatcher
  let TodoStore
  let callback

  // mock actions
  let actionNewTodo = {
    type: &#39;NEW_TODO&#39;,
    todo: &#39;hello world&#39;
  }

  beforeEach(() =&amp;gt; {
    AppDispatcher = require(&#39;../src/dispatcher/AppDispatcher&#39;)
    TodoStore = require(&#39;../src/stores/Todo&#39;)
    callback = AppDispatcher.register.mock.calls[0][0]
  })

  it(&#39;registers a callback with the dispatcher&#39;, () =&amp;gt; {
    expect(AppDispatcher.register.mock.calls.length).toBe(1)
  })

  it(&#39;初始化时为空&#39;, () =&amp;gt; {
    expect(TodoStore.getTodos()).toEqual([])
  })

  it(&#39;创建一个新的 todo&#39;, () =&amp;gt; {
    callback(actionNewTodo)
    expect(TodoStore.getTodos().length).toBe(1)
    expect(TodoStore.getTodos()[0]).toEqual(&#39;hello world&#39;)
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;callback = AppDispatcher.register.mock.calls[0][0]&lt;/code&gt; 是一个黑魔法，它能够执行我们的 action，而 store 将会相应地变化，就如上面的代码中：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;初始化时 &lt;code&gt;TodoStore.getTodos()&lt;/code&gt; 返回一个空数组&lt;/li&gt;
&lt;li&gt;在执行 &lt;code&gt;callback(actionNewTodo)&lt;/code&gt; 后，TodoStore 里插入了 &lt;code&gt;&#39;hello world&#39;&lt;/code&gt;，我们就能预计它的长度为 1，且第一条数据是 &lt;code&gt;&#39;hello world&#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在命令行下跑 &lt;code&gt;npm test&lt;/code&gt;，就能看到 &amp;#8220;1 test passed&amp;#8221; 的字眼了。&lt;/p&gt;

&lt;p&gt;真是让人感动：我们前端终于有机会写单元测试，并且还十分轻松。&lt;/p&gt;

&lt;h2 id=&#34;扩展阅读&#34;&gt;扩展阅读&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://facebook.github.io/flux/docs/testing-flux-applications.html&#34;&gt;Flux | Application Architecture for Building User Interfaces&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>