<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Node.Js on 陈三</title>
    <link>https://www.zfanw.com/blog/tags/node/index.js/</link>
    <description>Recent content in Node.Js on 陈三</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 30 Jun 2016 06:32:13 +0000</lastBuildDate>
    <atom:link href="https://www.zfanw.com/blog/tags/node.js/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>peerDependencies</title>
      <link>https://www.zfanw.com/blog/peerdependencies.html</link>
      <pubDate>Thu, 30 Jun 2016 06:32:13 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/peerdependencies.html</guid>
      <description>&lt;p&gt;写 npm package 时，接触最多的，当属 &lt;a href=&#34;https://www.zfanw.com/blog/difference-between-dependencies-and-devdependencies.html&#34;&gt;dependencies 与 devDependencies&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果一个包定义了 &lt;code&gt;dependencies&lt;/code&gt; 与 &lt;code&gt;devDependencies&lt;/code&gt;，则我们在安装这个包时，会连着它的依赖们一同安装。&lt;/p&gt;

&lt;p&gt;比如一个 react-native 的包，它依赖于 &lt;code&gt;react&lt;/code&gt; 与 &lt;code&gt;react-native&lt;/code&gt;，如果我们把 &lt;code&gt;react&lt;/code&gt; 及 &lt;code&gt;react-native&lt;/code&gt; 定义在 &lt;code&gt;dependencies&lt;/code&gt; 下，则安装完这个包后，它的目录结构是这样：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ProjectRoot/node_modules/package_name/node_modules/react&lt;/li&gt;
&lt;li&gt;ProjectRoot/node_modules/package_name/node_modules/react-native&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们又下载了一遍 react 与 react-native，这显得多余，可能还会导致冲突问题。&lt;/p&gt;

&lt;p&gt;这时我们就可以使用 &lt;a href=&#34;https://nodejs.org/en/blog/npm/peer-dependencies/&#34;&gt;&lt;code&gt;peerDependencies&lt;/code&gt;&lt;/a&gt;，通过它，我们能够声明第三方包正常运行的环境 &amp;#8211; 要安装我，你的环境该是如何，否则将无法运行。当然，没人会无聊到在一个 ember.js 项目中安装一个 react-native 的第三方包。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Node.js 开发 Telegram bot</title>
      <link>https://www.zfanw.com/blog/telegram-bot-with-nodejs.html</link>
      <pubDate>Sat, 27 Feb 2016 14:16:36 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/telegram-bot-with-nodejs.html</guid>
      <description>&lt;p&gt;昨天 Ingress 厦门的 telegram 群里大家在逗机器人，于是自己也想开发一个玩。&lt;/p&gt;

&lt;p&gt;首先，在 telegram 里找 &lt;a href=&#34;https://telegram.me/botfather&#34;&gt;@BotFather&lt;/a&gt; ，跟它对话，让它创建一个 bot，并且讨要一个 token，token 大概长这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，我们与 bot 对话，或是在带了 bot 玩的群里说话，bot 都能够读取到，它相当于中间的传话者，服务器与 bot 对话的方式有两种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://core.telegram.org/bots/api#getupdates&#34;&gt;getUpdates&lt;/a&gt; &amp;#8211; 我们的服务器主动读取&lt;/p&gt;

&lt;p&gt;拿上面那个假 token 说，GET &lt;code&gt;https://api.telegram.org/bot123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11/getUpdates&lt;/code&gt; 就可以得到数据。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://core.telegram.org/bots/api#setwebhook&#34;&gt;setWebhook&lt;/a&gt; &amp;#8211; telegram bot 在得到消息后，会主动往我们通过 setWebhook 接口设定的服务器 url POST 数据。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;setWebhook&lt;/code&gt; 的用法是，在浏览器中访问 &lt;code&gt;https://api.telegram.org/bot123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11/setWebhook?url=https://example.org&lt;/code&gt;，页面会返回结果：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;{&amp;#8220;ok&amp;#8221;:true,&amp;#8221;result&amp;#8221;:true,&amp;#8221;description&amp;#8221;:&amp;#8221;Webhook was set&amp;#8221;}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;返回结果表示 Webhook 设定成功，之后 telegram 就会往 &lt;a href=&#34;https://example.org&#34;&gt;https://example.org&lt;/a&gt; 地址 POST 新数据。&lt;/p&gt;

&lt;p&gt;webhook 的地址必需是 https 的，telegram 文档中有提到证书 &amp;#8211; 除非你的网站是自己签名的，否则可以不理会该参数。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外，&lt;code&gt;getUpdates&lt;/code&gt; 方法与 &lt;code&gt;setWebhook&lt;/code&gt; 只能二选一，不能同时使用。&lt;/p&gt;

&lt;p&gt;我用的 node.js 框架是 &lt;a href=&#34;http://hapijs.com/&#34;&gt;hapi.js&lt;/a&gt;，整个代码大致如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const Hapi = require(&#39;hapi&#39;)
const ajax = require(&#39;request&#39;)

// Create a server with a host and port
const server = new Hapi.Server()
const token = require(&#39;./token&#39;)
const api = `https://api.telegram.org/bot${token}/`

server.connection({
  host: &#39;localhost&#39;,
  port: 8888
})

// Add the route
server.route({
  method: &#39;GET&#39;,
  path: &#39;/&#39;,
  handler: function (request, reply) {
    return reply(&#39;hello world&#39;)
  }
})
server.route({
  method: &#39;POST&#39;,
  path: &#39;/&#39; + token,
  handler: function (req, reply) {
    reply(&#39;done&#39;)
    const message = req.payload.message
    const chat_id = message.from.id
    ajax.post(api + &#39;sendMessage&#39;,
          {
            form: {chat_id: chat_id, text: message.text}
          }, (err, response, body) =&amp;gt; {
            if (err) console.log(err)
            console.log(&#39;everything is ok: &#39;, body)
          })
  }
})

// Start the server
server.start((err) =&amp;gt; {
  if (err) {
    throw err
  }
  console.log(&#39;Server running at:&#39;, server.info.uri)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把代码上传到 vps 上，通过 &lt;a href=&#34;http://pm2.keymetrics.io/docs/usage/quick-start/&#34;&gt;pm2&lt;/a&gt; 启动，并配置 Apache，将&lt;a href=&#34;https://www.zfanw.com/blog/apache-proxy-node-js.html&#34;&gt;指定路由的流量全部转发给 node.js 服务器上&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apache 代理 Node.js 服务器</title>
      <link>https://www.zfanw.com/blog/apache-proxy-node-js.html</link>
      <pubDate>Sun, 07 Feb 2016 04:05:35 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/apache-proxy-node-js.html</guid>
      <description>&lt;p&gt;我在&lt;a href=&#34;https://www.zfanw.com/blog/linode-vps-install-ghost.html#_Apache_Ghost&#34;&gt;安装 Ghost 博客&lt;/a&gt;时，需要转发 Apache 请求给 node.js 服务器，当时为了快速搞定，找了些资料，拷了些配置，看它可以运行，也就没再搭理。&lt;/p&gt;

&lt;p&gt;说来，我根本不知道为什么要加个 &lt;code&gt;ProxyPassReverse&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;前些天写的 blog &lt;a href=&#34;https://www.zfanw.com/blog/react-js-server-render.html&#34;&gt;React.js 服务端渲染&lt;/a&gt;里，同样需要让示例在服务器上运行。与安装 Ghost 时唯一的区别是，我的 blog 现在已经换成了 https。&lt;/p&gt;

&lt;p&gt;所以配置过程是这样的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打开 &lt;code&gt;/etc/httpd/conf.d/vhost.conf&lt;/code&gt; 文件，这是 CentOS 系统下 Apache2 的配置文件路径，添加以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;VirtualHost *:443&amp;gt;
 # 其它内容，这里不显示
  &amp;lt;Location /react/server-render&amp;gt;
    ProxyPass http://localhost:2222
    ProxyPassReverse http://localhost:2222
 &amp;lt;/Location&amp;gt;
&amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/react/react-render&lt;/code&gt; 是我存放项目的路径，3000 端口是 node.js 运行的服务器端口 &amp;#8211; 我使用了 &lt;a href=&#34;https://github.com/Unitech/pm2&#34;&gt;PM2&lt;/a&gt; 来管理生产环境中的 node.js 项目。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;sudo service httpd restart&lt;/code&gt; 重启 Apache 服务器。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以 &lt;code&gt;ProxyPassReverse&lt;/code&gt; 做什么用的？还是看&lt;a href=&#34;https://httpd.apache.org/docs/2.4/mod/mod_proxy.html#proxypassreverse&#34;&gt;官方文档&lt;/a&gt;吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linode vps 安装配置 Ghost</title>
      <link>https://www.zfanw.com/blog/linode-vps-install-ghost.html</link>
      <pubDate>Sat, 03 Jan 2015 06:20:45 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/linode-vps-install-ghost.html</guid>
      <description>&lt;div id=&#34;toc_container&#34; class=&#34;ml-l u-floatRight pure-u-1-1 pure-u-sm-2-5 toc_white no_bullets&#34;&gt;
  &lt;nav id=&#34;myaffix&#34;&gt;
  
  &lt;p class=&#34;toc-title&#34;&gt;
    目录
  &lt;/p&gt;
  
  &lt;ul class=&#34;toc-list nav&#34; role=&#34;menu&#34;&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#_Ghost&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;1&lt;/span&gt; 安装 Ghost&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#_Apache_Ghost&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;2&lt;/span&gt; 配置 Apache 与 Ghost&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;&lt;/nav&gt;
&lt;/div&gt;

&lt;div class=&#34;&#34;&gt;
  &lt;p&gt;
    我的 vps 情况：
  &lt;/p&gt;
  
  &lt;ul&gt;
    &lt;li&gt;
      操作系统 &amp;#8211; CentOS 7 64 位
    &lt;/li&gt;
    &lt;li&gt;
      web 服务器软件 &amp;#8211; Apache
    &lt;/li&gt;
  &lt;/ul&gt;
  
  &lt;p&gt;
    Ghost&lt;fnref target=&#34;14873.1&#34; /&gt; 基于 Node.js，它本身自带 web 服务器，不需要 Apache。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;_Ghost&#34;&gt;安装 Ghost&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;hey_Ghost&#34; href=&#34;#_Ghost&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    主要参照 Ghost 官方帮助&lt;fnref target=&#34;14873.2&#34; /&gt;。
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        下载 Ghost
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;$ curl -L https://ghost.org/zip/ghost-latest.zip -o ghost.zip
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        解压 Ghost
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;$ unzip -uo ghost.zip -d ghost
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        安装 Ghost
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;$ cd ghost
$ npm install --production
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        启动 Ghost
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;$ npm start --production
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    现在，你可以在 vps 上通过 &lt;code&gt;127.0.0.1:2368&lt;/code&gt; 路径访问到 Ghost 博客了。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;_Apache_Ghost&#34;&gt;配置 Apache 与 Ghost&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;hey_Apache_Ghost&#34; href=&#34;#_Apache_Ghost&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    当然，你的目的可不是在 vps 上访问 Ghost，而是通过域名访问 Ghost。
  &lt;/p&gt;
  
  &lt;p&gt;
    ghost 目录下有一个 &lt;code&gt;config.example.js&lt;/code&gt; 文件，用于配置相关信息&lt;fnref target=&#34;14873.3&#34; /&gt;，比如域名，端口等。
  &lt;/p&gt;
  
  &lt;p&gt;
    执行以下操作前，请先确保你在 DNS 服务器上把域名绑定到 vps 的 ip 地址。
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        复制一个 config.js
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;$ cd ghost
$ cp config.example.js config.js
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        修改 config.js
      &lt;/p&gt;
      
      &lt;p&gt;
        将 config.js 里 production 部分里的 &lt;code&gt;url: &#39;http://my-ghost-blog.com&#39;&lt;/code&gt; 改为 &lt;code&gt;url: &#39;http://example.com&#39;&lt;/code&gt;。
      &lt;/p&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        重启 Ghost
      &lt;/p&gt;
      
      &lt;p&gt;
        按 &lt;kbd&gt;Ctrl - C&lt;/kbd&gt; 关闭 Ghost，再执行 &lt;code&gt;npm start --production&lt;/code&gt; 启动它。
      &lt;/p&gt;
      
      &lt;p&gt;
        这时你能看到如下信息：
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;Migrations: Up to date at version 003
Ghost is running... 
Your blog is now available on http://example.com 
Ctrl+C to shut down
&lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;
        但这信息并不意味着我们能访问到 Ghost 了。因为 example.com 域名访问的是 80 端口，在这个端口上监听的是 Apache 而不是 Node.js &amp;#8211; 它是在 2368 端口监听着。
      &lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    所以我们还需要配置 Apache。
  &lt;/p&gt;
  
  &lt;p&gt;
    打开 &lt;code&gt;/etc/httpd/conf.d/vhost.conf&lt;/code&gt; 文件（CentOS 系统的情况），添加如下内容：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt; &amp;lt;VirtualHost *:80&amp;gt;
     ServerName www.frontbin.com
     ServerAlias frontbin.com
     ProxyPreserveHost on
     ProxyPass / http://localhost:2368/
     ProxyPassReverse / http://localhost:2368/
 &amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    重启 apache：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;$ sudo service httpd restart 
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这样，Apache 充当代理，会把它监听到的流量转发给 Node.js 监听的端口，这时访问 http://example.com，我们就能打开 Ghost 博客了。
  &lt;/p&gt;
  
  &lt;footnotes&gt;
    &lt;fn name=&#34;14873.1&#34;&gt;
      &lt;p&gt;
        &lt;a href=&#34;https://ghost.org/&#34;&gt;Ghost &amp;#8211; Just a blogging platform&lt;/a&gt;
      &lt;/p&gt;
    &lt;/fn&gt;
    
    &lt;fn name=&#34;14873.2&#34;&gt;
      &lt;p&gt;
        &lt;a href=&#34;http://support.ghost.org/installing-ghost-linux/&#34;&gt;Installing Ghost on Linux &amp;#8211; Ghost SupportGhost Support&lt;/a&gt;
      &lt;/p&gt;
    &lt;/fn&gt;
    
    &lt;fn name=&#34;14873.3&#34;&gt;
      &lt;p&gt;
        &lt;a href=&#34;http://support.ghost.org/config/&#34;&gt;Configuring Ghost &amp;#8211; Ghost SupportGhost Support&lt;/a&gt;
      &lt;/p&gt;
    &lt;/fn&gt;
  &lt;/footnotes&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>搭建前端开发环境</title>
      <link>https://www.zfanw.com/blog/front-end-development-env.html</link>
      <pubDate>Sat, 21 Jun 2014 05:30:44 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/front-end-development-env.html</guid>
      <description>&lt;p&gt;如果用&lt;a href=&#34;http://yeoman.io/&#34;&gt;Yeoman&lt;/a&gt;创建前端的开发目录，运行:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ grunt serve
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以通过&lt;code&gt;http://localhost:10000&lt;/code&gt;这样的网址访问到开发根目录，&lt;/p&gt;

&lt;p&gt;如果系统有Python 2.x，也可以搭建个简易的服务器。切换到开发目录，执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python -m SimpleHTTPServer 10000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python 3.x的命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python -m http.server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后，我们同样可以通过&lt;code&gt;http://localhost:10000&lt;/code&gt;网址访问到开发根目录。&lt;/p&gt;

&lt;p&gt;因为跟后端的开发不同步，所以后端数据通常需要在自己的电脑上模拟。&lt;/p&gt;

&lt;p&gt;Node.js的框架&lt;a href=&#34;http://expressjs.com&#34;&gt;express.js&lt;/a&gt;是个很方便的工具。&lt;/p&gt;

&lt;p&gt;在安装完express.js后，创建一个目录，目录里新建&lt;code&gt;app.js&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require(&#39;express&#39;);
var app = express();

app.use(function(req, res, next) { // 解决请求跨域
  res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);
  next();
});

app.get(&#39;/&#39;, function(req, res) {
  res.send(&#39;hello express&#39;);
});

app.post(&#39;/login&#39;, function(req, res) {
  res.json({
    state: 1,
    info: null
  });
});

app.listen(3000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行&lt;code&gt;node app.js&lt;/code&gt;，后端数据就可以通过&lt;code&gt;localhost:3000&lt;/code&gt;接口访问到。代码中&lt;code&gt;app.use&lt;/code&gt;部分用于解决端口不同造成的跨域禁止访问的问题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>dependencies 与 devDependencies 的区别</title>
      <link>https://www.zfanw.com/blog/difference-between-dependencies-and-devdependencies.html</link>
      <pubDate>Fri, 23 May 2014 17:36:09 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/difference-between-dependencies-and-devdependencies.html</guid>
      <description>&lt;p&gt;&lt;code&gt;npm install&lt;/code&gt; 在安装 npm 包时，有两种命令参数可以把它们的信息写入 &lt;code&gt;package.json&lt;/code&gt; 文件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&amp;#8211;save&lt;/li&gt;
&lt;li&gt;&amp;#8211;save-dev&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但它的文档里&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:12811-1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:12811-1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，只提到一个小区别，&lt;code&gt;--save&lt;/code&gt; 会把依赖包名称添加到 &lt;code&gt;package.json&lt;/code&gt; 文件 &lt;code&gt;dependencies&lt;/code&gt; 键下，&lt;code&gt;--save-dev&lt;/code&gt; 则添加到 &lt;code&gt;package.json&lt;/code&gt; 文件 &lt;code&gt;devDependencies&lt;/code&gt; 键下，譬如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;yo&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;0.0.0&amp;quot;,
  &amp;quot;dependencies&amp;quot;: {},
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;grunt&amp;quot;: &amp;quot;~0.4.1&amp;quot;,
    &amp;quot;grunt-contrib-copy&amp;quot;: &amp;quot;~0.4.1&amp;quot;,
    &amp;quot;grunt-contrib-concat&amp;quot;: &amp;quot;~0.3.0&amp;quot;,
    &amp;quot;grunt-contrib-uglify&amp;quot;: &amp;quot;~0.2.0&amp;quot;,
    &amp;quot;grunt-contrib-compass&amp;quot;: &amp;quot;~0.7.0&amp;quot;,
    &amp;quot;grunt-contrib-jshint&amp;quot;: &amp;quot;~0.7.0&amp;quot;,
    &amp;quot;grunt-contrib-cssmin&amp;quot;: &amp;quot;~0.7.0&amp;quot;,
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过这只是它们的表面区别。它们真正的区别是，&lt;code&gt;devDependencies&lt;/code&gt; 下列出的模块，是我们开发时用的，比如 grunt-contrib-uglify，我们用它混淆 js 文件，它们不会被部署到生产环境。&lt;code&gt;dependencies&lt;/code&gt; 下的模块，则是我们生产环境中需要的依赖。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:12811-1&#34;&gt;&lt;a href=&#34;https://www.npmjs.org/doc/cli/npm-install.html&#34;&gt;npm-install&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:12811-1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>