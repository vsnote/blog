<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bower on 陈三</title>
    <link>https://www.zfanw.com/blog/tags/bower/</link>
    <description>Recent content in Bower on 陈三</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 07 May 2015 12:55:32 +0000</lastBuildDate>
    <atom:link href="https://www.zfanw.com/blog/tags/bower/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>jspm &amp; SystemJS 教程</title>
      <link>https://www.zfanw.com/blog/jspm-systemjs.html</link>
      <pubDate>Thu, 07 May 2015 12:55:32 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/jspm-systemjs.html</guid>
      <description>&lt;div id=&#34;toc_container&#34; class=&#34;ml-l u-floatRight pure-u-1-1 pure-u-sm-2-5 toc_white no_bullets&#34;&gt;
  &lt;nav id=&#34;myaffix&#34;&gt;
  
  &lt;p class=&#34;toc-title&#34;&gt;
    目录
  &lt;/p&gt;
  
  &lt;ul class=&#34;toc-list nav&#34; role=&#34;menu&#34;&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;1&lt;/span&gt; 包管理器&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-2&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;2&lt;/span&gt; 加载器&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#jspm&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;3&lt;/span&gt; jspm&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;&lt;/nav&gt;
&lt;/div&gt;

&lt;div class=&#34;&#34;&gt;
  &lt;p&gt;
    我的经验，前端开发上要解决的问题能简单分为两个阶段：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      开发阶段
    &lt;/li&gt;
    &lt;li&gt;
      部署阶段
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    其中开发阶段要解决：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      第三方包安装、使用、依赖关系的维护
    &lt;/li&gt;
    &lt;li&gt;
      自有代码的依赖关系维护及使用
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    先来聊聊开发阶段的解决方案。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i&#34;&gt;包管理器&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi&#34; href=&#34;#i&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    最初在 jQuery 站点上，文档可能是这样写的：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      下载 jquery.min.js 文件
    &lt;/li&gt;
    &lt;li&gt;
      保存到 js 目录
    &lt;/li&gt;
    &lt;li&gt;
      在 HTML 文件中使用 &lt;code&gt;script&lt;/code&gt; 标签引用 jquery
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    因为 jQuery 不依赖其它库，所以相对来说，上面的操作还算简单。
  &lt;/p&gt;
  
  &lt;p&gt;
    但如果碰上有依赖关系的，比如 Bootstrap 依赖于 jQuery，我们可能就需要分开下载 Bootstrap 与 jQuery。好在这一类第三方库通常都在下载文件中打包好依赖了。但这样又有一个问题，如果另一个库也同样打包一个 jQuery，并且版本与 Bootstrap 里打包的不一致呢。可以想像，这样的情况并不少见，我们的开发目录最终容易失控 &amp;#8211; 添加包很容易，删除就难了。另外，手工来做这件事，效率太低。
  &lt;/p&gt;
  
  &lt;p&gt;
    包管理器的意义就在这里。它封装了细节，自动化处理我们的需求。我们只需要提问题，它们提供答案：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      我要使用 jQuery &amp;#8211; 好，&lt;code&gt;bower install jquery&lt;/code&gt;
    &lt;/li&gt;
    &lt;li&gt;
      我要使用 Bootstrap &amp;#8211; 好， &lt;code&gt;bower install bootstrap&lt;/code&gt;，顺便会把依赖 jQuery 一起安装了
    &lt;/li&gt;
    &lt;li&gt;
      我想了想，还是删除 Bootstrap 吧 &amp;#8211; 好， &lt;code&gt;bower uninstall bootstrap&lt;/code&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    包管理器会维护一个依赖清单，个中关系一目了然。
  &lt;/p&gt;
  
  &lt;p&gt;
    当然，以上只是用 &lt;a href=&#34;http://bower.io/&#34; title=&#34;bower 官网&#34;&gt;bower&lt;/a&gt; 举例，市面上同类产品还非常多，比如 &lt;a href=&#34;http://duojs.org/&#34; title=&#34;doujs 官网&#34;&gt;duojs&lt;/a&gt;，本文的主角 &lt;a href=&#34;http://jspm.io/&#34; title=&#34;jspm 官网&#34;&gt;jspm&lt;/a&gt; 也是一个，甚至 npm 都算。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-2&#34;&gt;加载器&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-2&#34; href=&#34;#i-2&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    包管理器解决了我们管理各种模块的需求。接下来，我们要利用这些模块来开发，那么就会碰上如何使用这些模块的问题了。
  &lt;/p&gt;
  
  &lt;p&gt;
    目前 ES6 模块的标准还没在浏览器中得到完全落实，过渡期间我们有许多规范或不规范的模块：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;a href=&#34;http://www.commonjs.org/&#34; title=&#34;commonjs 官网&#34;&gt;CommonJS&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;a href=&#34;https://github.com/amdjs/amdjs-api/wiki/AMD&#34; title=&#34;托管在 github 上的 AMD 说明&#34;&gt;AMD&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;a href=&#34;http://wiki.ecmascript.org/doku.php?id=harmony:modules&#34; title=&#34;ecmacript 上的 modules 文档&#34;&gt;ES6 Modules&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
      命名空间方式定义
    &lt;/li&gt;
    &lt;li&gt;
      其它
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    如果只使用单一规范，比如针对 AMD，我们可能会用 &lt;a href=&#34;http://requirejs.org/&#34; title=&#34;requirejs 官网&#34;&gt;RequireJS&lt;/a&gt;；ES6 的模块，我们可能会用到 &lt;a href=&#34;https://github.com/ModuleLoader/es6-module-loader&#34; title=&#34;es6-module-loader 的 github 库&#34;&gt;ES6 Module Loader Polyfill&lt;/a&gt;；CommonJS 规范的模块，我们可能用 &lt;a href=&#34;https://github.com/systemjs/systemjs&#34; title=&#34;systemJS 的 github 库&#34;&gt;SystemJS&lt;/a&gt; &amp;#8211; 它同样可用于加载 AMD/ES6 模块。
  &lt;/p&gt;
  
  &lt;h3&gt;
    CSS 加载器？？
  &lt;/h3&gt;
  
  &lt;p&gt;
    上面提及的加载器，通常是针对 JavaScript 模块的，CSS 并没有严格意义的模块，那它怎么管理？我们的包管理器当然会连着包的 CSS 文件一同管理。那我们该如何使用这些模块中的 CSS 呢？举 SystemJS 来说，我们可以通过它的插件执行 &lt;code&gt;import&lt;/code&gt; 命令动态插入 CSS。打包的时候，SystemJS 默认会把整个 CSS 文件打包入 JS 文件中。当然，我们也可以借助 bower 与 gulp.js 及 &lt;a href=&#34;https://github.com/taptapship/wiredep&#34; title=&#34;wiredep 插件&#34;&gt;gulp.js 的 wiredep 插件&lt;/a&gt; 这样的组合实现在页面上「主动」插入 &lt;code&gt;link&lt;/code&gt; 标签 &amp;#8211; 但这需要搭配 gulp.js 等工具。
  &lt;/p&gt;
  
  &lt;p&gt;
    走完开发阶段，我们来看看部署阶段要解决的几个明显问题：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      CSS 文件合并、压缩等
    &lt;/li&gt;
    &lt;li&gt;
      JavaScript 文件合并、压缩、混淆等
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    不过，还是先正式介绍 jspm 与 SystemJS 的用法。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;jspm&#34;&gt;jspm&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyjspm&#34; href=&#34;#jspm&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    如前所说的，jspm 是一个浏览器端包管理器。
  &lt;/p&gt;
  
  &lt;h3&gt;
    安装 jspm
  &lt;/h3&gt;
  
  &lt;pre&gt;&lt;code&gt;npm install jspm -g
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;h3&gt;
    初始化目录
  &lt;/h3&gt;
  
  &lt;p&gt;
    在安装完 jspm 后，我们在命令行下就有一个 &lt;code&gt;jspm&lt;/code&gt; 命令可用。
  &lt;/p&gt;
  
  &lt;p&gt;
    创建一个目录，执行 &lt;code&gt;jspm init&lt;/code&gt; 即可在该目录下初始化开发环境：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;Package.json file does not exist, create it? [yes]: 
Would you like jspm to prefix the jspm package.json properties under jspm? [yes]: 
Enter server baseURL (public folder path) [.]: 
Enter jspm packages folder [./jspm_packages]: 
Enter config file path [./config.js]: 
Configuration file config.js doesn&#39;t exist, create it? [yes]:
Enter client baseURL (public folder URL) [/]: 
Which ES6 transpiler would you like to use, Traceur or Babel? [traceur]:
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    如果你用过 &lt;a href=&#34;http://yeoman.io/&#34; title=&#34;yeoman 官网&#34;&gt;yeoman&lt;/a&gt; 一类工具，对这类提示应该非常熟悉。
  &lt;/p&gt;
  
  &lt;h3&gt;
    安装第三方库
  &lt;/h3&gt;
  
  &lt;p&gt;
    比如要安装 jQuery：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;jspm install jquery
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这条命令会从 github:components/jquery 上读取下载。
  &lt;/p&gt;
  
  &lt;p&gt;
    还可以从 npm 上下载安装：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;jspm install npm:jquery
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;h3&gt;
    创建 HTML 文件
  &lt;/h3&gt;
  
  &lt;p&gt;
    创建一个 index.html 文件如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt; &amp;lt;!doctype html&amp;gt;
  &amp;lt;script src=&#34;jspm_packages/system.js&#34;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script src=&#34;config.js&#34;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script&amp;gt;
    System.import(&#39;app&#39;);
  &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    首先我们需要引用 &lt;code&gt;jspm_packages/system.js&lt;/code&gt;，这个是 jspm 提供的万用加载器。之后是 &lt;code&gt;config.js&lt;/code&gt; 文件，我们安装的各种包、依赖等信息都在这个文件中维护，之后我们用全局的 &lt;code&gt;System.import&lt;/code&gt; 执行 index.html 同一目录下的 app.js 文件。
  &lt;/p&gt;
  
  &lt;p&gt;
    在 app.js 文件中，我们使用 ES6 语法：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;import $ from &#39;jquery&#39;;
$(function() {
  console.log($);
});
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    假定我们要在 index.html 中使用 Bootstrap，那么先通过 &lt;code&gt;jspm&lt;/code&gt; 安装：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;jspm install bootstrap
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    然后把 app.js 文件修改如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;import bootstrap from &#39;bootstrap&#39;;

$(function() {
    console.log($);
});
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    我们并没有 &lt;code&gt;import&lt;/code&gt; jQuery，这是因为 jspm 维护有 bootstrap 的依赖，会自动加载 jQuery，不需要我们再手动 &lt;code&gt;import&lt;/code&gt;。
  &lt;/p&gt;
  
  &lt;p&gt;
    &lt;code&gt;import bootstrap from &#39;bootstrap&#39;&lt;/code&gt; 一行是加载了 Bootstrap 的 js 模块。那么，Bootstrap 的 CSS 部分如何加载呢？我们需要用到 &lt;a href=&#34;https://github.com/jspm/jspm-cli/wiki/Plugins#css&#34; title=&#34;plugin css 说明&#34;&gt;jspm 的 CSS 插件&lt;/a&gt;。
  &lt;/p&gt;
  
  &lt;p&gt;
    首先，安装 jspm 的 css 插件：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;jspm install css
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    然后在 app.js 中添加一行：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;import &#39;bootstrap/css/bootstrap.css!&#39;;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    &lt;strong&gt;!&lt;/strong&gt; 表示这会经过插件处理。
  &lt;/p&gt;
  
  &lt;p&gt;
    这时如果在本地服务器上打开 index.html 文件，借助浏览器的开发者工具查看：
  &lt;/p&gt;
  
  &lt;p&gt;
    [resp_image id=&amp;#8217;16028&amp;#8242; caption=&amp;#8221; ]
  &lt;/p&gt;
  
  &lt;p&gt;
    Wow，请求有点多 &amp;#8211; 但这只是开发阶段。
  &lt;/p&gt;
  
  &lt;h3&gt;
    打包 JavaScript
  &lt;/h3&gt;
  
  &lt;p&gt;
    我们终于说到 JavaScript 的打包了。
  &lt;/p&gt;
  
  &lt;p&gt;
    jspm 里，js 文件的打包非常简单，举上面的例子说，如果我们只有一个 js 入口的话，则执行：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;jspm bundle-sfx app build.js --minify
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    就可以将所有需要的 js 文件包括 CSS 文件打包到一个 build.js 文件中。
  &lt;/p&gt;
  
  &lt;p&gt;
    之后修改 index.html 文件中 script 部分如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;&amp;lt;!--    &amp;lt;script src=&#34;jspm_packages/system.js&#34;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&#34;config.js&#34;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
        System.import(&#39;app&#39;);
    &amp;lt;/script&amp;gt;--&amp;gt;
    &amp;lt;script src=&#34;build.js&#34;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这时打开 index.html 页面，就只剩下 index.html 与 build.js 两个请求了。
  &lt;/p&gt;
  
  &lt;h3&gt;
    打包 CSS
  &lt;/h3&gt;
  
  &lt;p&gt;
    在上在一个步骤中，我们把 CSS 文件连着一起打包进了 js 中，这可能并不是多数人想要的结果。
  &lt;/p&gt;
  
  &lt;p&gt;
    我们可以通过定义 &lt;a href=&#34;https://github.com/jspm/jspm-cli/wiki/Plugins#css-builds&#34; title=&#34;jspm config.js 构建配置&#34;&gt;config.js 文件&lt;/a&gt;改变这种行为。
  &lt;/p&gt;
  
  &lt;p&gt;
    打开 config.js 文件，添加 &lt;code&gt;seperateCSS: true&lt;/code&gt;：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;System.config({
  &#34;baseURL&#34;: &#34;/&#34;,
  &#34;separateCSS&#34;: true
});
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    再次执行 &lt;code&gt;jspm bundle-sfx app build.js --minify&lt;/code&gt;，会在 index.html 同级目录下生成一个 build.js 与 build.css，在 index.html 中引用 build.css 文件即可。
  &lt;/p&gt;
  
  &lt;p&gt;
    对比 gulp.js 或 grunt.js 等工具，jspm 给我的体验非常好，解决了开发阶段、部署阶段的几个重要难题，目前只有 ember-cli 这样的环境能给我同样的感受。
  &lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>