<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Chrome on 陈三</title>
    <link>https://www.zfanw.com/blog/tags/chrome/</link>
    <description>Recent content in Chrome on 陈三</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sun, 06 Dec 2015 12:43:44 +0000</lastBuildDate>
    <atom:link href="https://www.zfanw.com/blog/tags/chrome/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Chrome 开发者工具之内存使用分析</title>
      <link>https://www.zfanw.com/blog/chrome-devtools-memory-profiling.html</link>
      <pubDate>Sun, 06 Dec 2015 12:43:44 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/chrome-devtools-memory-profiling.html</guid>
      <description>

&lt;p&gt;对我们 JavaScript 开发者来说，因为内存有自动回收机制，所以大部分时间，我们并没打算关心内存。&lt;/p&gt;

&lt;p&gt;但是，移动设备的内存通常有限，卡顿、崩溃的现象并不少见，于是我们又不得不开始关心内存。&lt;/p&gt;

&lt;p&gt;从哪里开始？怎样的一个步骤？&lt;/p&gt;

&lt;p&gt;（因为 chrome 开发者工具经常变动，所以这里说明一下，以下截图如果不是特别强调，用到的浏览器均指 Chrome 49.0.2582.0 (Official Build) canary (64-bit) 版本）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Chrome 内置的 task manager，（图片来自 &lt;a href=&#34;https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/memory-diagnosis?hl=en#monitor-memory-using-chrome-task-manager&#34;&gt;Google Devtools 网站&lt;/a&gt;），粗略观察&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/imgs/task-manager.png&#34; alt=&#34;chrome 任务管理器&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在 Chrome 内置任务管理器中发现内存可能有问题后，我们想知道，具体是怎样：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打开 Chrome Devtools&lt;/li&gt;
&lt;li&gt;点击 Timeline 标签页&lt;/li&gt;
&lt;li&gt;勾选 &lt;strong&gt;Memory&lt;/strong&gt; 选项&lt;/li&gt;
&lt;li&gt;点击录制按钮
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zfanw.com/blog/wp-content/uploads/2015/12/chrome-devtools-timeline-memory.png&#34; rel=&#34;attachment wp-att-17720&#34;&gt;&lt;img src=&#34;https://www.zfanw.com/blog/wp-content/uploads/2015/12/chrome-devtools-timeline-memory.png&#34; alt=&#34;chrome devtools timeline panel with memory option on&#34; width=&#34;792&#34; class=&#34;alignnone size-full wp-image-17720&#34; srcset=&#34;https://www.zfanw.com/blog/wp-content/uploads/2015/12/chrome-devtools-timeline-memory.png 792w, https://www.zfanw.com/blog/wp-content/uploads/2015/12/chrome-devtools-timeline-memory-300x197.png 300w, https://www.zfanw.com/blog/wp-content/uploads/2015/12/chrome-devtools-timeline-memory-100x66.png 100w, https://www.zfanw.com/blog/wp-content/uploads/2015/12/chrome-devtools-timeline-memory-768x505.png 768w, https://www.zfanw.com/blog/wp-content/uploads/2015/12/chrome-devtools-timeline-memory-520x342.png 520w&#34; sizes=&#34;(max-width: 792px) 100vw, 792px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如图，我们能看到，滚动页面时，内存用量在逐步升高。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;是谁引起的内存增加？增加的内存是否可以回收，如果不能，是否导致内存泄漏？Chrome 开发者工具 Profiles 面板下有两个内存分析的工具，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/heap-snapshots?hl=en&#34;&gt;Take Heap Snapshot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/allocation-profiler?hl=en&#34;&gt;Record Heap Allocations&lt;/a&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前者能够捕捉当前的内存分配情况，后者可纪录不同时间里内存分配与回收的情况。它们的用法，Chrome devtools 网站上均有说明，虽然文档配图部分老旧，但内容多数并没有问题。另外，这两个工具涉及到大量的内存知识，所以算是 devtools 里比较复杂的应用。&lt;/p&gt;

&lt;p&gt;我个人的经验，Take Heap Snapshot 用得更多，我们可以多次录制快照，然后比对快照，哪些操作引发了哪些类型的数据增加或减小，非常容易定位。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;扩展阅读&#34;&gt;扩展阅读&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;视频 &amp;#8211; [对我们 JavaScript 开发者来说，因为内存有自动回收机制，所以大部分时间，我们并没打算关心内存。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是，移动设备的内存通常有限，卡顿、崩溃的现象并不少见，于是我们又不得不开始关心内存。&lt;/p&gt;

&lt;p&gt;从哪里开始？怎样的一个步骤？&lt;/p&gt;

&lt;p&gt;（因为 chrome 开发者工具经常变动，所以这里说明一下，以下截图如果不是特别强调，用到的浏览器均指 Chrome 49.0.2582.0 (Official Build) canary (64-bit) 版本）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Chrome 内置的 task manager，（图片来自 &lt;a href=&#34;https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/memory-diagnosis?hl=en#monitor-memory-using-chrome-task-manager&#34;&gt;Google Devtools 网站&lt;/a&gt;），粗略观察&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/imgs/task-manager.png&#34; alt=&#34;chrome 任务管理器&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在 Chrome 内置任务管理器中发现内存可能有问题后，我们想知道，具体是怎样：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打开 Chrome Devtools&lt;/li&gt;
&lt;li&gt;点击 Timeline 标签页&lt;/li&gt;
&lt;li&gt;勾选 &lt;strong&gt;Memory&lt;/strong&gt; 选项&lt;/li&gt;
&lt;li&gt;点击录制按钮
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zfanw.com/blog/wp-content/uploads/2015/12/chrome-devtools-timeline-memory.png&#34; rel=&#34;attachment wp-att-17720&#34;&gt;&lt;img src=&#34;https://www.zfanw.com/blog/wp-content/uploads/2015/12/chrome-devtools-timeline-memory.png&#34; alt=&#34;chrome devtools timeline panel with memory option on&#34; width=&#34;792&#34; class=&#34;alignnone size-full wp-image-17720&#34; srcset=&#34;https://www.zfanw.com/blog/wp-content/uploads/2015/12/chrome-devtools-timeline-memory.png 792w, https://www.zfanw.com/blog/wp-content/uploads/2015/12/chrome-devtools-timeline-memory-300x197.png 300w, https://www.zfanw.com/blog/wp-content/uploads/2015/12/chrome-devtools-timeline-memory-100x66.png 100w, https://www.zfanw.com/blog/wp-content/uploads/2015/12/chrome-devtools-timeline-memory-768x505.png 768w, https://www.zfanw.com/blog/wp-content/uploads/2015/12/chrome-devtools-timeline-memory-520x342.png 520w&#34; sizes=&#34;(max-width: 792px) 100vw, 792px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如图，我们能看到，滚动页面时，内存用量在逐步升高。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;是谁引起的内存增加？增加的内存是否可以回收，如果不能，是否导致内存泄漏？Chrome 开发者工具 Profiles 面板下有两个内存分析的工具，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/heap-snapshots?hl=en&#34;&gt;Take Heap Snapshot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/allocation-profiler?hl=en&#34;&gt;Record Heap Allocations&lt;/a&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前者能够捕捉当前的内存分配情况，后者可纪录不同时间里内存分配与回收的情况。它们的用法，Chrome devtools 网站上均有说明，虽然文档配图部分老旧，但内容多数并没有问题。另外，这两个工具涉及到大量的内存知识，所以算是 devtools 里比较复杂的应用。&lt;/p&gt;

&lt;p&gt;我个人的经验，Take Heap Snapshot 用得更多，我们可以多次录制快照，然后比对快照，哪些操作引发了哪些类型的数据增加或减小，非常容易定位。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;扩展阅读-1&#34;&gt;扩展阅读&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;视频 &amp;#8211;]&lt;a href=&#34;https://www.youtube.com/watch?v=L3ugr9BJqIs&#34;&gt;5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;视频 &amp;#8211; &lt;a href=&#34;https://www.youtube.com/watch?v=x9Jlu_h_Lyw&#34;&gt;Google I/O 2013 &amp;#8211; A Trip Down Memory Lane with Gmail and DevTools&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Chrome 开发者工具之 Collect JavaScript CPU Profile</title>
      <link>https://www.zfanw.com/blog/chrome-devtools-collect-javascript-cpu-profile.html</link>
      <pubDate>Sat, 24 Oct 2015 09:46:53 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/chrome-devtools-collect-javascript-cpu-profile.html</guid>
      <description>&lt;p&gt;如果你想了解 JavaScript 程序的运行情况，Chrome 开发者工具下的 &lt;a href=&#34;https://developers.google.com/web/tools/chrome-devtools/profile/rendering-tools/js-execution&#34;&gt;Collect JavaScript CPU Profile&lt;/a&gt; 是个好帮手。&lt;/p&gt;

&lt;p&gt;可是它们的文档更新速度常常跟不上它们版本的更新速度。比如 Collect JavaScript CPU Profile 下的 Chart 视图，Chrome 46 以后版本的火焰图（flame chart）已经跟文档上的配图不一样了，是倒过来的。&lt;/p&gt;

&lt;p&gt;好在重要的名词没有倒过来。&lt;/p&gt;

&lt;p&gt;在 Collect JavaScript CPU Profile 中，我们主要关心&lt;strong&gt;函数&lt;/strong&gt;，比如：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;函数执行了多长时间&lt;/li&gt;
&lt;li&gt;函数调用了哪些函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Chrome 提供了三种查阅方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Heavy (Bottom Up)&lt;/li&gt;
&lt;li&gt;Tree (Top Down)&lt;/li&gt;
&lt;li&gt;Chart&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这三种视图，我比较喜欢 Chart。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zfanw.com/blog/wp-content/uploads/2015/10/flame-chart-chrome1.png&#34; rel=&#34;attachment wp-att-17616&#34;&gt;&lt;img src=&#34;https://www.zfanw.com/blog/wp-content/uploads/2015/10/flame-chart-chrome1.png&#34; alt=&#34;chrome devtools cpu profile flame chart&#34; width=&#34;1278&#34; class=&#34;alignnone size-full wp-image-17616&#34; srcset=&#34;https://www.zfanw.com/blog/wp-content/uploads/2015/10/flame-chart-chrome1.png 1278w, https://www.zfanw.com/blog/wp-content/uploads/2015/10/flame-chart-chrome1-300x237.png 300w, https://www.zfanw.com/blog/wp-content/uploads/2015/10/flame-chart-chrome1-1024x808.png 1024w, https://www.zfanw.com/blog/wp-content/uploads/2015/10/flame-chart-chrome1-100x79.png 100w, https://www.zfanw.com/blog/wp-content/uploads/2015/10/flame-chart-chrome1-768x606.png 768w, https://www.zfanw.com/blog/wp-content/uploads/2015/10/flame-chart-chrome1-520x411.png 520w&#34; sizes=&#34;(max-width: 1278px) 100vw, 1278px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如前面说过的，我们主要关心&lt;strong&gt;函数是否执行时间过长&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在火焰图上，水平方向表示我们录制的时间轴，垂直方向表示函数的 call stack，即函数调用了其它函数的情形。因为一个色块表示一个函数的执行情况，所以，假如某个色块在水平方向上很宽，则说明它执行的时间太长了，极可能有优化的空间，需要我们注意；至于垂直方向，按 Chrome devtools 文档的说法：so a tall flame is not necessarily significant，其实并不十分重要。&lt;/p&gt;

&lt;p&gt;再来说明一下上面的截图中的几个名词：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Name &amp;#8211; 表示函数的名称&lt;/li&gt;
&lt;li&gt;Self time &amp;#8211; 函数自身语句执行的时长，不包含调用其它函数&lt;/li&gt;
&lt;li&gt;Total time &amp;#8211; 函数整个 call stack 执行的时长&lt;/li&gt;
&lt;li&gt;Aggregated self time &amp;#8211; 在我们录制的整个时间段内，函数自身语句总共执行了多久&lt;/li&gt;
&lt;li&gt;Aggregated total time &amp;#8211; 在我们录制的整个时间段内，函数所有 call stack 执行了多久&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以截图中具体函数来说：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;函数的 name 是 &lt;code&gt;e.extend._hitTest&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;函数语句本身执行的时长是 0，当然，只是无限接近 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;e.extend._hitTest&lt;/code&gt; 的 call stack 执行时间 2.5ms&lt;/li&gt;
&lt;li&gt;在我录制的 4s 多时间内，函数自身语句总共执行了 0 秒&lt;/li&gt;
&lt;li&gt;在我录制的 4s 多时间内，函数的 call stack 总共执行了 3.90ms&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;情况并不算坏。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Chrome扩展开发中的标签页id变化</title>
      <link>https://www.zfanw.com/blog/chrome-extension-tab-id-change.html</link>
      <pubDate>Wed, 14 May 2014 13:46:23 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/chrome-extension-tab-id-change.html</guid>
      <description>&lt;p&gt;如果你认为，Chrome浏览器中，每一个标签页的id是唯一的，且打开时是不变的。那么你是对的。&lt;/p&gt;

&lt;p&gt;但在我的开发过程中，却出现tab id发生变化的情况。&lt;/p&gt;

&lt;p&gt;整个过程是大概这样的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;background.js监控到页面上的点击事件，创建一个新标签页，并将新标签页的id值赋给一个全局变量taskTab：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var taskTab;
chrome.tabs.create({url: &#39;http://www.zfanw.com/blog/}, function(tab) {
taskTab = tab.id;
});
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同时，在background.js里监听webNavigation的onCommitted事件，用于动态注入内容脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chrome.webNavigation.onCommitted.addListener(function(details) {
if (details.tabId === taskTab) {
    chrome.tabs.executeScripts(taskTab, {file: &#39;example.js&#39;}); 
}
});
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在新标签页打开并注入内容脚本后，内容脚本会找出页面里的链接&amp;#8221;&lt;a href=&#34;http://www.zfanw.com/blog/about&amp;amp;#8221;，并模拟点击。&#34;&gt;http://www.zfanw.com/blog/about&amp;amp;#8221;，并模拟点击。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;且假定新标签页页面HTML代码中还包含如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&amp;quot;prerender&amp;quot; href=&amp;quot;http://www.zfanw.com/blog/about&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;prerender&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:12710-1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:12710-1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;是Chrome浏览器的一个加速访问的特性。它可以在我们访问A页面时，先在背景加载好B页面，这样我们访问B页面时，就非常神速。&lt;/p&gt;

&lt;p&gt;摘取链接1中的一段描述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A hidden page is created for the prerendered URL, which will do full loading of all dependent resources, as well as execution of Javascript. If the user navigates to the page, the hidden page will be swapped into the current tab and made visible.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;B页面是在一个隐藏页中加载的，当我们点击B链接时，隐藏页就替入当前标签页并置为可见。&lt;/p&gt;

&lt;p&gt;从字面上看，没有任何字眼暗示说tab id会变化。&lt;/p&gt;

&lt;p&gt;但实际上，tab id确实变了，这可以在background.js里绑定一个onReplaced事件来检查。&lt;/p&gt;

&lt;p&gt;onReplaced&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:12710-2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:12710-2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;事件描述如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Fired when the contents of the tab is replaced by a different (usually previously pre-rendered) tab.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;绑定的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chrome.tabs.onReplaced.addListener(function(addedTabId, removedTabId) {
  console.log &amp;quot;added tabid: &amp;quot; + addedTabId;
  console.log &amp;quot;removed tabid: &amp;quot; + removedTabId;
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开背景页的开发者工具，我们就能看到，模拟的点击事件发生时，Chrome浏览器移除了一个标签页，并新增了一个。只是从我们肉眼来说，根本看不到置换过程。&lt;/p&gt;

&lt;p&gt;我的情况里，因为tab id变化，所以taskTab的值其实已经没用，结果导致点击打开的about页面没能注入内容脚本。如果你也碰上内容脚本动态注入失败的情况，不妨检查下标签页的id值。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:12710-1&#34;&gt;&lt;a href=&#34;http://www.chromium.org/developers/design-documents/prerender&#34;&gt;Chrome Prerendering &amp;#8211; The Chromium Projects&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:12710-1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:12710-2&#34;&gt;&lt;a href=&#34;https://developer.chrome.com/extensions/webNavigation#event-onTabReplaced&#34;&gt;chrome.webNavigation &amp;#8211; Google Chrome&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:12710-2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Firefox 文推荐</title>
      <link>https://www.zfanw.com/blog/firefox-post-recommend.html</link>
      <pubDate>Sat, 15 Dec 2012 11:43:42 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/firefox-post-recommend.html</guid>
      <description>&lt;p&gt;别看我导航上赫然有个 Firefox 分类，其实近于挂羊头卖狗肉，个中真正写 Firefox 的内容很少，多数只是打个擦边球，因为没其他合适分类可放，就只好放入 Firefox 中，如果要脑补下这场景，那就好像下雨天，大家挤在了屋檐下，互相客气地说，不好意思、不好意思。&lt;/p&gt;

&lt;p&gt;我在开始接触 &lt;a href=&#34;http://www.zfanw.com/blog/category/vimperator&#34;&gt;Vimperator&lt;/a&gt; 时，所搜寻的相关资料里，多会出现「不折腾会死系列」。内容丰富，于我是受益颇多。即便是现在偶尔翻起，也还是有新收获，所以略为整理，并作推荐，表示一点鄙人对那位阁下的感谢之情。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://deepintoabyss.appspot.com/minibrowser&#34;&gt;[不折腾会死][恶魔出没注意] 从最简界面的浏览器谈起&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://deepintoabyss.appspot.com/anti-chrome-101201&#34;&gt;[烽火再起][逆袭的圣战] 20+a条技巧，让Chrome无法超越Firefox&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://deepintoabyss.appspot.com/RvsT-Sacred&#34;&gt;[圣战]龟兔赛跑到底谁快？——谈软件效率&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://deepintoabyss.appspot.com/anti-chrome&#34;&gt;[圣战][谷粉慎入] 铬合金终不敌烈焰————喷析试用最新版Chrome各种不爽&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>