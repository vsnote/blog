<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Express.Js on 陈三</title>
    <link>https://www.zfanw.com/blog/tags/express/index.js/</link>
    <description>Recent content in Express.Js on 陈三</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 12 May 2016 12:06:15 +0000</lastBuildDate>
    <atom:link href="https://www.zfanw.com/blog/tags/express.js/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Express 路由</title>
      <link>https://www.zfanw.com/blog/express-js-router-edge-case.html</link>
      <pubDate>Thu, 12 May 2016 12:06:15 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/express-js-router-edge-case.html</guid>
      <description>&lt;p&gt;如果你的网站很小，又或者你不介意一个文件有成千上万行的代码，那大可以不必深入理解 express.js 的路由，只要知道 &lt;code&gt;app.get&lt;/code&gt; 一类的简单用法就行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import express from &#39;express&#39;
const app = express()
/**
 * @api {get} / 读取 xx
 */
app.get(&#39;/&#39;, (req, res, next) =&amp;gt; {})

/**
 * @api {post} / 创建 xx
 */
app.post(&#39;/&#39;, (req, res, next) =&amp;gt; {})

/**
 * @api {delete} /:id 删除 xx
 */
app.delete(&#39;/:id&#39;, (req, res, next) =&amp;gt; {})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只是事情远没那么简单。&lt;/p&gt;

&lt;p&gt;比如上面的 &lt;code&gt;post&lt;/code&gt; 与 &lt;code&gt;delete&lt;/code&gt;，需要用户登录后才能执行，则你就需要一个检查用户是否已登录的方法，如果已经登录，则继续执行，否则重定向到登录页。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @function restrict 验证 session 中 token 是否存在
 */
function restrict (req, res, next) {
  if (!req.session.token) {
    return res.redirect(&#39;/login&#39;)
  } else {
    next()
  }
}
app.post(&#39;/&#39;, restrict, (req, res, next) =&amp;gt; {})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://expressjs.com/en/api.html#app.METHOD&#34;&gt;app.METHOD&lt;/a&gt; 的用法是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.METHOD(path, callback [, callback ...])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恰如前面的例子中所看到的，我们可以给 &lt;code&gt;app.post&lt;/code&gt; 传递多个 callback，callback 会按顺序执行，除非前头排队执行的不调 &lt;code&gt;next()&lt;/code&gt;。譬如上面的 &lt;code&gt;restrict&lt;/code&gt;，在检查到 &lt;code&gt;token&lt;/code&gt; 不存在后，它就直接 &lt;code&gt;return&lt;/code&gt; 了，没有 &lt;code&gt;next()&lt;/code&gt;，再后面的 callback 函数就不再执行。而在 &lt;code&gt;token&lt;/code&gt; 存在的情况下，它执行了 &lt;code&gt;next()&lt;/code&gt;，即继续下一个 callback。&lt;/p&gt;

&lt;p&gt;在 &lt;a href=&#34;https://en.wikipedia.org/wiki/Representational_state_transfer&#34;&gt;RESTful&lt;/a&gt; 的规范里，我们的操作是围绕着资源（resources）的，比如这个博客，它有 posts 这个资源，针对它的增删改查（CRUD）在路由中体现为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @api {get} /posts 读取所有博客
 */
app.get(&#39;/posts&#39;, callback)

/**
 * @api {post} /posts 创建博客
 */
app.post(&#39;/posts&#39;, callback)

/**
 * @api {get} /posts/:postID 读取 id 为 postID 值的博客
 */
app.get(&#39;/posts/:postID&#39;, callback)

/**
 * @api {patch} /posts/:postID 修改 id 为 postID 值的博客
 */
app.patch(&#39;/posts/:postID&#39;, callback)

/**
 * @api {delete} /posts/:postID 删除 id 为 postID 值的博客
 */
app.delete(&#39;/posts/:postID&#39;, callback)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们为什么要把 &lt;code&gt;/posts/:postID&lt;/code&gt; 写上三遍甚至多遍？假如后期 URL 想做一点调整，我们就要改三次了。&lt;/p&gt;

&lt;p&gt;我们可以使用 &lt;a href=&#34;http://expressjs.com/en/api.html#app.route&#34;&gt;app.route&lt;/a&gt; 对上面的代码做一点改进：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.route(&#39;/posts&#39;)
  .get(callback)
  .post(callback)

app.route(&#39;/posts/:postID&#39;)
  .get(callback)
  .patch(callback)
  .delete(callback)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但我的博客上并不仅仅 posts 这类资源，还有 comments 资源，还有 users 资源，于是，我们的路由会慢慢变成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.route(&#39;/users&#39;)
  .all(restrict)
  .get(callback)
  .post(callback)

app.route(&#39;/posts&#39;)
  .get(callback)
  .post(callback)

app.route(&#39;/posts/:postID&#39;)
  .get(callback)
  .patch(callback)
  .delete(callback)

app.route(&#39;/posts/:postID/comments&#39;)
  .get(callback)
  .post(callback)

app.route(&#39;/posts/:postID/comments/:commentID&#39;)
  .get(callback)
  .patch(callback)
  .delete(callback)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想像一下，每个 &lt;code&gt;callback&lt;/code&gt; 乐观点，假设能用 20 行代码解决，我们的这个路由文件也至少要上 500 行。假如再加上注释，则这个文件估计要有上千行。rMBP 下，14 号大小，编辑器一屏能显示 37 行。&lt;/p&gt;

&lt;p&gt;分家的时候到了。&lt;/p&gt;

&lt;p&gt;怎么分？&lt;/p&gt;

&lt;p&gt;如果 &lt;code&gt;app.route&lt;/code&gt; 肯接收第二个参数就好了，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.route(&#39;/posts&#39;, callback)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就可以在单独的文件中定义 &lt;code&gt;/posts&lt;/code&gt; 路径下所有处理逻辑，然后 &lt;code&gt;import&lt;/code&gt; 进来给 &lt;code&gt;app.route&lt;/code&gt; 调用。&lt;/p&gt;

&lt;p&gt;但 &lt;code&gt;app.route&lt;/code&gt; 只接收一个 &lt;code&gt;path&lt;/code&gt; 参数。&lt;/p&gt;

&lt;p&gt;这里，我们有两个问题要解决：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如何把 &lt;code&gt;app.route(path)&lt;/code&gt; 后所附的各种逻辑独立到一个文件中&lt;/li&gt;
&lt;li&gt;如何将独立文件中的处理逻辑与 url 匹配起来&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一个问题的解决办法是使用 &lt;a href=&#34;http://expressjs.com/en/api.html#router&#34;&gt;Router&lt;/a&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let router = express.Router()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就创建了一个 Router 对象，Router 是一个 mini 的 app，所以我们前面所写的 &lt;code&gt;app.METHOD&lt;/code&gt; 的代码，Router 都可以同样使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let router = express.Router()
router.route(&#39;/&#39;)
  .all(restrict)
  .get(callback)
  .post(callback)
export default router
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就可以将某个 url 下对应的各种处理逻辑独立到一个文件里。&lt;/p&gt;

&lt;p&gt;接下来解决第二个问题。&lt;/p&gt;

&lt;p&gt;我们要用到 &lt;code&gt;app.use&lt;/code&gt;，它的用法与我们想像的 &lt;code&gt;app.route&lt;/code&gt; 的近似：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.use([path,] function [, function...])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们首先将独立文件 &lt;code&gt;import&lt;/code&gt; 进来，然后使用 &lt;code&gt;app.use&lt;/code&gt; 将它与 url 匹配起来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import userRouter from &#39;./userRouter&#39;
app.use(&#39;/users&#39;, userRouter)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，app 里所有 &lt;code&gt;/users/*&lt;/code&gt; 的请求都会进入 &lt;code&gt;userRouter&lt;/code&gt; 这个 mini app 中处理。&lt;/p&gt;

&lt;p&gt;但是我们要注意，&lt;code&gt;app.use(&#39;/users&#39;, userRouter)&lt;/code&gt; 这样的写法下，userRouter 中要匹配 &lt;code&gt;/users&lt;/code&gt; 路径，并不是下面这种写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.route(&#39;/users&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.route(&#39;/&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是的，我们的 url 路径现在分散了，一部分在入口文件中，一部分在 Router 文件中，如果我们切割得很厉害，则一个完整的 API 路径，会分散在多个文件中。假如代码不写注释，也不生成文档，则查阅 API 路径会非常麻烦。就我目前的经验，并没有一个很好的解决办法 &amp;#8211; 除了文档中标注。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：以上代码均指 express.js 4.x 的 API。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>