<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coffeescript on 陈三</title>
    <link>https://www.zfanw.com/blog/tags/coffeescript/</link>
    <description>Recent content in Coffeescript on 陈三</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 05 Apr 2014 17:27:39 +0000</lastBuildDate>
    <atom:link href="https://www.zfanw.com/blog/tags/coffeescript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>CoffeeScript 里 setTimeout 写法</title>
      <link>https://www.zfanw.com/blog/coffeescript-settimeout.html</link>
      <pubDate>Sat, 05 Apr 2014 17:27:39 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/coffeescript-settimeout.html</guid>
      <description>&lt;p&gt;CoffeeScript 中，要给一个函数传递参数并执行，可以用括号，也可以省略括号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;run = (a, b) -&amp;gt; # 定义 run 函数
  // code hear

run 1, 2 # 传递参数1、2给 run 函数并执行，省略了括号

run(1, 2) # 传递参数1、2给 run 函数并执行，带括号
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，你还可以将参数换行写，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;run 1,
2

run 1
, 2

run(1,
2)

run(1
, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要有带上逗号，你想怎么写都可以，CoffeeScript 的编译器都会识别出你的用意。&lt;/p&gt;

&lt;p&gt;假如要在 CoffeeScript 定义一个 &lt;code&gt;setTimeout&lt;/code&gt; 函数，可以这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setTimeout  -&amp;gt;
  console.log a, b
, 1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译出的结果是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setTimeout(function() {
  return console.log(a, b);
}, 1000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种可行的写法，是把第一个参数用括号包起来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setTimeout  (-&amp;gt;
  console.log a, b
), 1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种写法要更明白。&lt;/p&gt;

&lt;p&gt;不过最明白的，肯定是把函数定义在其他地方，然后给 setTimeout 传递函数名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func = -&amp;gt;
  console.log &#39;code&#39;
setTimeout(func, 1000)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>CoffeeScript 全局变量</title>
      <link>https://www.zfanw.com/blog/coffeescript-global-variable.html</link>
      <pubDate>Sun, 23 Mar 2014 14:11:08 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/coffeescript-global-variable.html</guid>
      <description>&lt;p&gt;CoffeeScript 下，没有全局变量，所有的代码封装到一个即时运行函数中，比如以下简单的一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = 5
b = -&amp;gt;
  return 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译出来的 JavaScript 代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function() {
  var a, b;

  a = 5;

  b = function() {
    return 5;
  };
}).call(this); // &amp;lt;- 定义一个匿名函数，并传入 `this` 这个上下文随即执行，a、b 都是局域变量
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但我们可能有定义全局变量的需要，所以 CoffeeScript 还是提供了声明的方法，没有灭绝全局变量：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you&amp;#8217;d like to create top-level variables for other scripts to use, attach them as properties on window, or on the exports object in CommonJS. The existential operator (covered below), gives you a reliable way to figure out where to add them; if you&amp;#8217;re targeting both CommonJS and the browser: exports ? this&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在浏览器环境下，你可以这样定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.foo = &#39;baz&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Node.js 环境下，你可以这样定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exports.foo = &#39;baz&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为增强代码健壮性，两头都适用，你可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root = exports ? this
root.foo = &#39;baz&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种比较脏的写法，是用一对 ` 符号包起来的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`foo = &#39;baz&#39;`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译后的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function() {
  foo = &#39;baz&#39;; // &amp;lt;- foo 是全局变量
}).call(this);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过这种是我们尽量应该避免的，因为连 &lt;code&gt;var&lt;/code&gt; 都没有加。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CoffeeScript Recompile 问题</title>
      <link>https://www.zfanw.com/blog/coffeescript-recompile-file-removed.html</link>
      <pubDate>Thu, 10 Jan 2013 15:14:18 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/coffeescript-recompile-file-removed.html</guid>
      <description>&lt;p&gt;CoffeeScript 提供了一个命令行参数 &lt;code&gt;--watch&lt;/code&gt; 用来监视 .coffee 文件的变化，如果该类文件有更新，将自动将其 compile 成 JavaScript 文件。&lt;/p&gt;

&lt;p&gt;但如果在 vim 下编辑 .coffee 文件，并且调用 coffee 命令监视：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;coffee -w -c xx.coffee
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 vim 中保存更新后，会出现如下错误：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;removed xx.coffee&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;按 &lt;a href=&#34;http://stackoverflow.com/questions/8280915/coffeescript-1-1-3-watch-only-works-once&#34;&gt;stackoverflow&lt;/a&gt; 上的说明，则应该是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;is that some programs save changes not by writing directly to the existing file, but rather by writing to a temporary file and then mv-ing that file on top of the existing one. From fs.watch&amp;#8217;s perspective, this means that the watched file has been deleted, and changes to the new file will be ignored.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;vim 的机制是先创建一个临时文件，然后在 &lt;code&gt;:w&lt;/code&gt; 命令时将该临时文件移动或复制一份并覆盖原有的文件，在 fs.watch 看来，该原文件就是被删除。于是就出现上述问题。&lt;/p&gt;

&lt;p&gt;一个解决办法是使用第三方工具，比如 &lt;a href=&#34;https://github.com/TrevorBurnham/jitter&#34;&gt;jitter&lt;/a&gt;，又或者第二个办法，通过 vim 的自动命令功能：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;autocmd BufWritePost,FileWritePost *.coffee silent !coffee -c &amp;lt;afile&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二个方法的不好之处是出错了看不到，第一个则可以随时显示编译的情况。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>