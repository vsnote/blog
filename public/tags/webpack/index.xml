<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Webpack on 陈三</title>
    <link>https://www.zfanw.com/blog/tags/webpack/</link>
    <description>Recent content in Webpack on 陈三</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Fri, 05 Feb 2016 14:01:43 +0000</lastBuildDate>
    <atom:link href="https://www.zfanw.com/blog/tags/webpack/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>React.js 服务端渲染</title>
      <link>https://www.zfanw.com/blog/react-js-server-render.html</link>
      <pubDate>Fri, 05 Feb 2016 14:01:43 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/react-js-server-render.html</guid>
      <description>&lt;div id=&#34;toc_container&#34; class=&#34;ml-l u-floatRight pure-u-1-1 pure-u-sm-2-5 toc_white no_bullets&#34;&gt;
  &lt;nav id=&#34;myaffix&#34;&gt;
  
  &lt;p class=&#34;toc-title&#34;&gt;
    目录
  &lt;/p&gt;
  
  &lt;ul class=&#34;toc-list nav&#34; role=&#34;menu&#34;&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#renderToString&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;1&lt;/span&gt; renderToString&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;2&lt;/span&gt; 准备工作&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-2&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;3&lt;/span&gt; 按部就班&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#_bundlejs&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;4&lt;/span&gt; 构建 bundle.js&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;&lt;/nav&gt;
&lt;/div&gt;

&lt;div class=&#34;&#34;&gt;
  &lt;p&gt;
    是否多此一举？
  &lt;/p&gt;
  
  &lt;p&gt;
    毕竟，从服务端渲染走到客户端渲染这一步，前端界可花了不少时间。
  &lt;/p&gt;
  
  &lt;p&gt;
    如果你对服务端渲染的必要性心存疑虑，不妨先看看&lt;a href=&#34;http://alistapart.com/article/interaction-is-an-enhancement&#34;&gt;这一篇&lt;/a&gt;文章。
  &lt;/p&gt;
  
  &lt;p&gt;
    但我还是在这儿简单介绍下，为什么这些客户端渲染的框架们要踏入服务端渲染的领域。
  &lt;/p&gt;
  
  &lt;p&gt;
    在客户端渲染时，我们的页面通常很简洁，比如，你可能见过这样的 HTML 文件：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;这是陈三&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;script src=&#39;http://code.jquery.com/jquery-2.1.4.min.js&#39;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&#39;http://example.com/test.bundle.js&#39;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    陈三在打开这个页面后，浏览器会加载：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      jquery-2.1.4.min.js
    &lt;/li&gt;
    &lt;li&gt;
      test.bundle.js
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    在这两个文件加载完成并执行以前，陈三只能看到一片空白。等了十来秒后，页面还没有动静，陈三找来专业人士，哦，jquery-2.1.4.min.js 文件不知道怎么回事，加载失败，导致 test.bundle.js 无法构建 HTML 代码。
  &lt;/p&gt;
  
  &lt;p&gt;
    实际上：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      任何 js 代码问题都可能导致陈三看不到页面
    &lt;/li&gt;
    &lt;li&gt;
      搜索引擎可能无法索引这样的页面（对，&lt;a href=&#34;https://googlewebmastercentral.blogspot.com/2015/10/deprecating-our-ajax-crawling-scheme.html&#34;&gt;Google 可以做到&lt;/a&gt;，但不是所有搜索引擎都是 Google）
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    那么，我们可以做得更好吗？
  &lt;/p&gt;
  
  &lt;p&gt;
    这正是 Ember.js、Angular.js 等努力的方向。这一篇，则是介绍 react.js 在这方面的情况。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;renderToString&#34;&gt;renderToString&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyrenderToString&#34; href=&#34;#renderToString&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    react 官网文档在服务端渲染上&lt;a href=&#34;https://facebook.github.io/react/docs/top-level-api.html#reactdomserver&#34;&gt;着墨不多&lt;/a&gt;：
  &lt;/p&gt;
  
  &lt;blockquote&gt;
    &lt;p&gt;
      Render a ReactElement to its initial HTML. This should only be used on the server. React will return an HTML string. You can use this method to generate HTML on the server and send the markup down on the initial request for faster page loads and to allow search engines to crawl your pages for SEO purposes.
    &lt;/p&gt;
    
    &lt;p&gt;
      If you call ReactDOM.render() on a node that already has this server-rendered markup, React will preserve it and only attach event handlers, allowing you to have a very performant first-load experience.
    &lt;/p&gt;
  &lt;/blockquote&gt;
  
  &lt;p&gt;
    简单说，&lt;code&gt;renderToString&lt;/code&gt; 方法在服务器上先渲染出组件的 HTML 结构，客户端上 react 在执行到 &lt;code&gt;render()&lt;/code&gt; 方法时，会检查是否有服务端渲染过的代码，如果有，则仅仅往上添加事件处理器。我们不妨这样认为，原来在客户端要执行的 js 代码被拆成两个部分：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      渲染 HTML 结构
    &lt;/li&gt;
    &lt;li&gt;
      往 HTML 结构上附加事件处理器
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    前者在服务端上完成，后者在客户端上完成。
  &lt;/p&gt;
  
  &lt;p&gt;
    那么，我们要怎么入手 react.js 服务端渲染？react.js 初期开发者 Pete Hunt 给了些&lt;a href=&#34;https://github.com/petehunt/react-howto#learning-server-rendering&#34;&gt;建议&lt;/a&gt;：
  &lt;/p&gt;
  
  &lt;blockquote&gt;
    &lt;p&gt;
      Server rendering still requires a lot of tooling to get right. Since it transparently supports React components written without server rendering in mind, you should build your app first and worry about server rendering later. You won&amp;#8217;t need to rewrite all of your components to support it.
    &lt;/p&gt;
  &lt;/blockquote&gt;
  
  &lt;p&gt;
    要做服务端渲染，我们要干的事还很多，但通常可以先构建 app，再来关心服务端渲染。我们并不会需要全部重写所有的组件。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i&#34;&gt;准备工作&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi&#34; href=&#34;#i&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    我们要先解决以下问题：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        server 端用什么框架？
      &lt;/p&gt;
      
      &lt;p&gt;
        对前端开发来说，基于 node.js 的框架通常更易于上手，所以这里选用了 &lt;a href=&#34;http://expressjs.com/&#34;&gt;expressjs&lt;/a&gt;。
      &lt;/p&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        要构建出前端使用的 js 文件，要用什么工具？
      &lt;/p&gt;
      
      &lt;p&gt;
        不论是 requirejs 还是 browserify 或 jspm 都可以用，这里使用 webpack。
      &lt;/p&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        react.js 在后端 render 时，如果要用 jsx 语法，要怎么解决？
      &lt;/p&gt;
      
      &lt;p&gt;
        使用 &lt;a href=&#34;https://www.zfanw.com/blog/babel-6.html#babel-register&#34;&gt;babel-register&lt;/a&gt;。
      &lt;/p&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        如果我想用 es2015 语法后 express.js 程序，要怎么做？
      &lt;/p&gt;
      
      &lt;p&gt;
        同第 3 点。
      &lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    接下来就是安装 react、react-dom、babel，并且配置 babel，&lt;a href=&#34;https://github.com/chenxsan/react-server-render/tree/810b2cd13ccdc9d59784e97f1937efe949de21ff&#34;&gt;点击查看项目代码&lt;/a&gt;。
  &lt;/p&gt;
  
  &lt;p&gt;
    好了，我们可以开始写代码了。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-2&#34;&gt;按部就班&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-2&#34; href=&#34;#i-2&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    首先，我们添加一个 Home 组件，代码如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;import React from &#39;react&#39;
export default class Home extends React.Component {
  render () {
    return (&amp;lt;div&amp;gt;
              hello from 陈三。
            &amp;lt;/div&amp;gt;)
  }
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这个组件目前只是渲染一段 div。
  &lt;/p&gt;
  
  &lt;p&gt;
    接下来是在 app.js 文件中引用它并渲染成 HTML：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;import express from &#39;express&#39;
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/server&#39;
import Home from &#39;./components/Home&#39;
let app = express()
app.get(&#39;/&#39;, (req, res) =&amp;gt; {
  res.send(ReactDOM.renderToString(React.createFactory(Home)()))
})
app.listen(3000, () =&amp;gt; {
  console.log(&#39;listen on 3000&#39;)
})

&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这里用到的两个方法：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;a href=&#34;https://facebook.github.io/react/docs/top-level-api.html#reactdomserver.rendertostring&#34;&gt;renderToString&lt;/a&gt; &amp;#8211; 将组件渲染成字符串。
    &lt;/li&gt;
    &lt;li&gt;
      &lt;a href=&#34;https://facebook.github.io/react/docs/top-level-api.html#react.createfactory&#34;&gt;createFactory&lt;/a&gt; &amp;#8211; 生成一个组件工厂方法，用于生成组件。之所以用它，是因为 renderToString 接受的参数是 ReactElement element，所以我们不能使用 jsx 的形式 &lt;code&gt;&amp;lt;Home /&amp;gt;&lt;/code&gt;。
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    执行 &lt;code&gt;node index.js&lt;/code&gt; 命令，可以在 http://localhost:3000 网址看到：
  &lt;/p&gt;
  
  &lt;blockquote&gt;
    &lt;p&gt;
      hello from 陈三。
    &lt;/p&gt;
  &lt;/blockquote&gt;
  
  &lt;p&gt;
    点击&lt;a href=&#34;https://github.com/chenxsan/react-server-render/tree/82ab7be8078743c31fa2e92cf62d0ffd9af69ad6&#34;&gt;查看这一步的项目代码&lt;/a&gt;。
  &lt;/p&gt;
  
  &lt;p&gt;
    目前为止，我们还没给组件添加任何交互行为，比如点击一下，&lt;strong&gt;字体颜色变化&lt;/strong&gt;。下面我们就来尝试给 Home 组件添加这一交互。
  &lt;/p&gt;
  
  &lt;p&gt;
    我们将 Home 组件改造如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;import React from &#39;react&#39;
export default class Home extends React.Component {
  constructor (props) {
    super(props)
    this.clickToChangeColor = this.clickToChangeColor.bind(this)
    this.state = {
      color: &#39;#&#39; + (Math.random() * 0xFFFFFF &amp;lt;&amp;lt; 0).toString(16)
    }
  }
  clickToChangeColor (e) {
    this.setState({
      color: &#39;#&#39; + (Math.random() * 0xFFFFFF &amp;lt;&amp;lt; 0).toString(16)
    })
  }
  render () {
    return (&amp;lt;div onClick={this.clickToChangeColor} style={{color: this.state.color}}&amp;gt;
              hello from 陈三。
            &amp;lt;/div&amp;gt;)
  }
}

&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    现在点击 div 块，字体颜色并不会出现任何变化，因为，目前为止，我们只是在后端渲染了 HTML 结构，事件绑定等工作，要在前端上完成。
  &lt;/p&gt;
  
  &lt;p&gt;
    但现在，我们还只是简单的生成一个页面，只有一个 &lt;code&gt;div&lt;/code&gt; 块，没有 &lt;code&gt;html&lt;/code&gt; 标签，没有 &lt;code&gt;meta&lt;/code&gt; 标签，也没有引用任何脚本。
  &lt;/p&gt;
  
  &lt;p&gt;
    我们需要一个完整的页面，这里，使用 &lt;a href=&#34;http://expressjs.com/en/guide/using-template-engines.html&#34;&gt;jade 模板引擎&lt;/a&gt;来生成页面。
  &lt;/p&gt;
  
  &lt;p&gt;
    我们在 views 目录下增加一个 &lt;code&gt;index.jade&lt;/code&gt; 模板：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;doctype html
html
    head
        title=&#39;react 服务端渲染&#39;
        meta(charset=&#39;utf-8&#39;)
    body
        #root!= react
        script(src=&#39;/bundle.js&#39;)
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    app.js 内容修改成：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;import express from &#39;express&#39;
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/server&#39;
import Home from &#39;./components/Home&#39;
let app = express()
app.use(express.static(&#39;public&#39;))
app.set(&#39;views&#39;, &#39;./views&#39;)
app.set(&#39;view engine&#39;, &#39;jade&#39;)
let html = ReactDOM.renderToString(React.createFactory(Home)())
app.get(&#39;/&#39;, (req, res) =&amp;gt; {
  res.render(&#39;index&#39;, {react: html})
})
app.listen(3000, () =&amp;gt; {
  console.log(&#39;listen on 3000&#39;)
})
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    目前为止，我们还没有一个叫 &lt;code&gt;bundle.js&lt;/code&gt; 的文件，它将由 webpack 来构建。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;_bundlejs&#34;&gt;构建 bundle.js&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;hey_bundlejs&#34; href=&#34;#_bundlejs&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    如果对 webpack 的构建不熟悉，可以先看看 &lt;a href=&#34;https://www.zfanw.com/blog/webpack-tutorial.html&#34;&gt;我写的 webpack 教程&lt;/a&gt;。这里跳过安装 webpack、babel 等步骤。
  &lt;/p&gt;
  
  &lt;p&gt;
    上面说到的 app.js 是服务端的入口文件，前端上同样需要一个入口，且把它叫 client.js：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;import Home from &#39;./components/Home&#39;
import ReactDOM from &#39;react-dom&#39;
import React from &#39;react&#39;
ReactDOM.render(&amp;lt;Home /&amp;gt;, document.getElementById(&#39;root&#39;))
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    另外，我们再定义一个 webpack.config.js 文件：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;var path = require(&#39;path&#39;)
module.exports = {
  entry: &#39;./src/client&#39;,
  output: {
    filename: &#39;bundle.js&#39;,
    path: path.join(__dirname, &#39;public&#39;)
  },
  module: {
    loaders: [
      {test: /\.js$/,
        loaders: [&#39;babel?presets[]=react,presets[]=es2015&#39;],
        include: [path.join(__dirname, &#39;src&#39;)]
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    在项目根目录下执行 &lt;code&gt;webpack&lt;/code&gt;，我们就会得到 &lt;code&gt;public/bundle.js&lt;/code&gt;，刷新我们的主页，点击 div 就能看到文字的颜色在改变了。
  &lt;/p&gt;
  
  &lt;p&gt;
    就这样，我们完成了一趟轻松、简单的 react.js 服务端渲染之旅。
  &lt;/p&gt;
  
  &lt;p&gt;
    如果对完整的代码有兴趣，请点击 &lt;a href=&#34;https://github.com/chenxsan/react-server-render&#34;&gt;github 上的 react-server-render 仓库&lt;/a&gt;，还可以点击&lt;a href=&#34;https://www.zfanw.com/react/server-render/&#34;&gt;示例&lt;/a&gt;查看最终效果。
  &lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>babel 6 教程</title>
      <link>https://www.zfanw.com/blog/babel-6.html</link>
      <pubDate>Fri, 29 Jan 2016 10:25:05 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/babel-6.html</guid>
      <description>&lt;div id=&#34;toc_container&#34; class=&#34;ml-l u-floatRight pure-u-1-1 pure-u-sm-2-5 toc_white no_bullets&#34;&gt;
  &lt;nav id=&#34;myaffix&#34;&gt;
  
  &lt;p class=&#34;toc-title&#34;&gt;
    目录
  &lt;/p&gt;
  
  &lt;ul class=&#34;toc-list nav&#34; role=&#34;menu&#34;&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#babel-cli&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;1&lt;/span&gt; babel-cli&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#babel&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;2&lt;/span&gt; babel 插件&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;3&lt;/span&gt; 预置套餐&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#babel-polyfill&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;4&lt;/span&gt; babel-polyfill&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#babel-runtime&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;5&lt;/span&gt; babel-runtime&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#webpack_babel-loader&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;6&lt;/span&gt; webpack 中定义 babel-loader&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#babel-register&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;7&lt;/span&gt; babel-register&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-2&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;8&lt;/span&gt; 扩展阅读&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;&lt;/nav&gt;
&lt;/div&gt;

&lt;div class=&#34;&#34;&gt;
  &lt;p&gt;
    babel 5.x -&gt; 6.x 的变化非常大，许多模块分离出去，只是一些文档还语焉不详，这里略作整理。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;babel-cli&#34;&gt;babel-cli&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heybabel-cli&#34; href=&#34;#babel-cli&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    如果你用过 CoffeeScript，或 TypeScript，那你对它们的编译过程一定很熟悉，&lt;a href=&#34;https://babeljs.io/docs/usage/cli/&#34;&gt;babel-cli&lt;/a&gt; 模块同样也是一个编译的作用。
  &lt;/p&gt;
  
  &lt;p&gt;
    比如有一个 test.js 文件，内容如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;let fun = () =&amp;gt; console.log(&#39;babel&#39;)
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    那么执行 &lt;code&gt;babel test.js&lt;/code&gt;，会输出以下内容：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;&#34;use strict&#34;;

var fun = function fun() {
  return console.log(&#39;babel&#39;);
};
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    除了 &lt;code&gt;babel&lt;/code&gt; 命令外，babel-cli 包另有一个 &lt;code&gt;babel-node&lt;/code&gt; 命令，它近似于 node，只不过它在运行代码前会预先编译 ES2015 的代码。
  &lt;/p&gt;
  
  &lt;p&gt;
    不论是 &lt;code&gt;babel&lt;/code&gt; 命令还是 &lt;code&gt;babel-node&lt;/code&gt; 命令，我们都可以通过命令行参数修改它们的行为，还可以通过新建一个 &lt;code&gt;.babelrc&lt;/code&gt; 文件来配置。
  &lt;/p&gt;
  
  &lt;p&gt;
    但以上是 babel 5.x 的用法。
  &lt;/p&gt;
  
  &lt;p&gt;
    如果在 babel 6 里，执行 &lt;code&gt;babel test.js&lt;/code&gt;，只会输出原样的文本，因为 &lt;code&gt;babel&lt;/code&gt; 不再包含任何 transform 功能，babel 6 里把它们作为插件（plugin）分割出去，需要我们自己定义，见下文说明。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;babel&#34;&gt;babel 插件&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heybabel&#34; href=&#34;#babel&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    在 babel 6 里，要转换 ES2015 的代码，需要自己配置插件，比如上面的示例：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;let fun = () =&amp;gt; console.log(&#39;babel&#39;)
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    我们执行 &lt;code&gt;babel test.js&lt;/code&gt;，babel 不会对文件做任何转换。我们需要一个 &lt;a href=&#34;http://babeljs.io/docs/plugins/transform-es2015-arrow-functions/&#34;&gt;ES2015 arrow functions transform&lt;/a&gt; 插件。
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        安装插件
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;npm install babel-plugin-transform-es2015-arrow-functions
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        在目录下创建一个 .babelrc 文件，用于配置 babel，添加如下内容：
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;{
  &#34;plugins&#34;: [&#34;transform-es2015-arrow-functions&#34;]
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        再执行 &lt;code&gt;babel test.js&lt;/code&gt;，我们得到如下转换结果：
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;let fun = function () {
  return console.log(&#39;babel&#39;);
};
&lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;
        基本上 ES2015/ES7 的各种功能，babel 都提供了相应的插件用于转换，但如果我们要一个一个配置 &amp;#8211; 那就太恼人了。所以 babel 还提供了一个方法：presets。
      &lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i&#34;&gt;预置套餐&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi&#34; href=&#34;#i&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    我们不妨把 presets 理解为套餐，不同套餐有不同的插件组合，比如 &lt;a href=&#34;http://babeljs.io/docs/plugins/preset-es2015/&#34;&gt;ES2015 preset&lt;/a&gt; 里打包了所有用于转换 ES2015 代码的插件，&lt;a href=&#34;http://babeljs.io/docs/plugins/preset-react/&#34;&gt;React preset&lt;/a&gt; 则打包了转换 react.js jsx 语法的插件。它们的用法同上面一致：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        安装 preset
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;npm install babel-preset-es2015
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        配置 .babelrc 文件
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;{
  &#34;presets&#34;: [&#34;es2015&#34;]
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        再执行 &lt;code&gt;babel test.js&lt;/code&gt;，我们会得到与 babel 5.x 一样的转换结果：
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;
var fun = function fun() {
  return console.log(&#39;babel&#39;);
};
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;babel-polyfill&#34;&gt;babel-polyfill&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heybabel-polyfill&#34; href=&#34;#babel-polyfill&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    babel 虽然可以转换各种 ES2015 语法及 jsx，但浏览器未提供原生支持的许多功能还是需要 polyfill，比如 Promise。
  &lt;/p&gt;
  
  &lt;p&gt;
    我们只要在代码中引入 babel-polyfill 就可以模拟出一个 ES2015 的环境，用法如下：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        安装 &lt;code&gt;babel-polyfill&lt;/code&gt;
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;npm install babel-polyfill --save
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        在入口文件中引用：
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;import babel-polyfill
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;babel-runtime&#34;&gt;babel-runtime&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heybabel-runtime&#34; href=&#34;#babel-runtime&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    与 babel-polyfill 一样，babel-runtime 的作用也是模拟 ES2015 环境。只不过，babel-polyfill 是针对全局环境的，引入它，我们的浏览器就好像具备了规范里定义的完整的特性 &amp;#8211; 虽然原生并未实现。
  &lt;/p&gt;
  
  &lt;p&gt;
    babel-runtime 更像是分散的 polyfill 模块，我们可以在自己的模块里单独引入，比如 &lt;code&gt;require(‘babel-runtime/core-js/promise’)&lt;/code&gt; ，它们不会在全局环境添加未实现的方法，只是，这样手动引用每个 polyfill 会非常低效。我们借助 &lt;a href=&#34;http://babeljs.io/docs/plugins/transform-runtime/&#34;&gt;Runtime transform&lt;/a&gt; 插件来自动化处理这一切。
  &lt;/p&gt;
  
  &lt;p&gt;
    至于要用 babel-polyfill 还是 babel-runtime，则需要根据具体需求。举个例子，如果一个库里引用了 babel-polyfill，别人的库也引用了 babel-polyfill，我们很可能会跑两个 babel-polyfill 实例，这里，使用 babel-runtime 会更合适。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;webpack_babel-loader&#34;&gt;webpack 中定义 babel-loader&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heywebpack_babel-loader&#34; href=&#34;#webpack_babel-loader&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    在 &lt;code&gt;webpack.config.js&lt;/code&gt; 里这样定义：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;module: {
  loaders:  [
    {
      test: /\.js/,
      loader: &#39;babel?presets[]=es2015,presets[]=react,plugins[]=transform-runtime&#39;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;babel-register&#34;&gt;babel-register&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heybabel-register&#34; href=&#34;#babel-register&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    &lt;a href=&#34;https://babeljs.io/docs/usage/require/&#34;&gt;babel-register&lt;/a&gt; 是放在 node 里使用的。它的作用是替代 node 的 &lt;code&gt;require&lt;/code&gt; 命令，与 node 自身的 &lt;code&gt;require&lt;/code&gt; 不同，它可以加载 es2015、jsx 等类型文件。
  &lt;/p&gt;
  
  &lt;p&gt;
    用法如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;require(&#39;babel-register&#39;)({presets: [&#39;es2015&#39;, &#39;react&#39;]})
require(&#39;./app&#39;)
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这样我们在 app 文件中就可以使用 es2015 与 jsx 语法了。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-2&#34;&gt;扩展阅读&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-2&#34; href=&#34;#i-2&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;a href=&#34;https://medium.com/@jcse/clearing-up-the-babel-6-ecosystem-c7678a314bf3#a7d5&#34;&gt;Clearing up the Babel 6 Ecosystem&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>webpack 与资源缓存</title>
      <link>https://www.zfanw.com/blog/webpack-assets-cache.html</link>
      <pubDate>Fri, 11 Sep 2015 16:11:23 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/webpack-assets-cache.html</guid>
      <description>

&lt;p&gt;你现在看到的这个网页，至少有三个 js 文件、一个 CSS 文件，还有一张图片。如果你是第一次访问这个页面，则至少要下载 200KB 大小的文件，耗时 6 秒多。&lt;/p&gt;

&lt;p&gt;你的时间非常值钱。&lt;/p&gt;

&lt;p&gt;所以浏览器提供了缓存功能，如果你是第二次访问这个页面，则很可能，你的浏览器只发送一个请求读取 HTML 页面，其它 js 文件、CSS 及图片都从本地的浏览器缓存中读取。缓存帮你节省了时间，也替你访问的网站节省流量。&lt;/p&gt;

&lt;p&gt;简单说，浏览器缓存大概是这样的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;你第一次访问页面&lt;/li&gt;
&lt;li&gt;页面的 HTTP 响应头中带有 &lt;strong&gt;Cache-Control&lt;/strong&gt;，其中设定了资源（JS、CSS、图片等）的有效时间&lt;/li&gt;
&lt;li&gt;有效期内，浏览器会直接从本地缓存中读取文件&lt;/li&gt;
&lt;li&gt;资源失效&lt;/li&gt;
&lt;li&gt;浏览器从远程服务器重新下载资源？？等等，如果远程服务器上的资源跟本地缓存中的还是一样，那我们完全没必要又下载一份一模一样的。其实，第 2 步中的响应头中其实还有一个 &lt;strong&gt;ETag&lt;/strong&gt;，它表示资源的一个指纹。浏览器在资源失效后，会携带这个 Etag 去验证服务器上的资源情况，如果没有变化，则本地的资源有效时间重新设过，我们不必要重新下载一份；如果 Etag 变化了，浏览器才会下载一份新的资源缓存到本地&lt;/li&gt;
&lt;li&gt;假如，缓存在浏览器本地的资源尚未过期，但远程服务器上，资源确实改变了，怎么办？&lt;/li&gt;
&lt;li&gt;修改资源的路径，浏览器会重新读取、缓存资源&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这第 7 步，正是 webpack 中可以轻易做到的。&lt;/p&gt;

&lt;p&gt;我们在开发 React.js 时，有许多第三方库的代码，基本不会修改，比如 react、react-router 或 jQuery，这些代码，在部署的时候，可以打包成一个 vendor.[chunkhash].js 文件，这样用户第一次访问需要下载，第二次访问就可以读取浏览器缓存。&lt;/p&gt;

&lt;p&gt;且看 webpack 的&lt;a href=&#34;http://webpack.github.io/docs/long-term-caching.html&#34;&gt;缓存配置用法&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var path = require( &#39;path&#39; )
var webpack = require( &#39;webpack&#39; )

module.exports = {
  entry: {
    app: [
      &#39;./script/app&#39;
    ],
    vendor: [&#39;react&#39;, &#39;react-router&#39;, &#39;jquery&#39;]
  },
  output: {
    path: path.join( __dirname, &#39;/dist&#39; ),
    filename: &#39;[name].[chunkhash].js&#39;
  },
  plugins: [ new webpack.optimize.CommonChunkPlugin({ name: &#39;vendor&#39; }) ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，运行 &lt;code&gt;webpack&lt;/code&gt; 命令打包后，会生成 &lt;strong&gt;vendors.46b0ed9caf9a53733d60.js&lt;/strong&gt; 这样的文件名，只要文件内容不变，chunkhash 部分就不会变，而文件内容一旦变化，chunkhash 就会变化。于是我们合理利用了浏览器的缓存功能，同时也保证缓存能够及时更新。&lt;/p&gt;

&lt;h2 id=&#34;扩展阅读&#34;&gt;扩展阅读&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=en&#34;&gt;HTTP caching — Web Fundamentals&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>webpack 使用教程</title>
      <link>https://www.zfanw.com/blog/webpack-tutorial.html</link>
      <pubDate>Fri, 28 Aug 2015 13:19:03 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/webpack-tutorial.html</guid>
      <description>&lt;div id=&#34;toc_container&#34; class=&#34;ml-l u-floatRight pure-u-1-1 pure-u-sm-2-5 toc_white no_bullets&#34;&gt;
  &lt;nav id=&#34;myaffix&#34;&gt;
  
  &lt;p class=&#34;toc-title&#34;&gt;
    目录
  &lt;/p&gt;
  
  &lt;ul class=&#34;toc-list nav&#34; role=&#34;menu&#34;&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#_8211_webpack&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;1&lt;/span&gt; 起手式 &amp;#8211; 安装 webpack&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;2&lt;/span&gt; 初始化项目&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#webpack&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;3&lt;/span&gt; webpack 配置&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-2&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;4&lt;/span&gt; 实时刷新&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-3&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;5&lt;/span&gt; 第三方库&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-4&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;6&lt;/span&gt; 模块化&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-5&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;7&lt;/span&gt; 打包、构建&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;&lt;/nav&gt;
&lt;/div&gt;

&lt;div class=&#34;&#34;&gt;
  &lt;p&gt;
    我最近大量使用 &lt;a href=&#34;https://www.zfanw.com/blog/tag/jspm&#34;&gt;jspm&lt;/a&gt;，但因为它搭建的环境里，测试代码不好写，而项目又有写测试的计划，所以决定改用 &lt;a href=&#34;http://webpack.github.io/&#34;&gt;webpack&lt;/a&gt;。
  &lt;/p&gt;
  
  &lt;p&gt;
    我还记得我刚接触 webpack 时的心情：零零碎碎。
  &lt;/p&gt;
  
  &lt;p&gt;
    就没个简单、现成、完整的方案？我是说，我真的不太关心 js 文件要配什么加载器。我只想快一点把开发环境搭起来好干活。总之，几经折腾，我嫌麻烦放弃了 webpack 这个方案。
  &lt;/p&gt;
  
  &lt;p&gt;
    但今天回头去看，其实它并没那么复杂。
  &lt;/p&gt;
  
  &lt;p&gt;
    那么，webpack 是什么？
  &lt;/p&gt;
  
  &lt;blockquote&gt;
    &lt;p&gt;
      MODULE BUNDLER
    &lt;/p&gt;
  &lt;/blockquote&gt;
  
  &lt;p&gt;
    它是这么自称的，&lt;strong&gt;模块打包器&lt;/strong&gt;。
  &lt;/p&gt;
  
  &lt;p&gt;
    在 webpack 里，所有类型的文件都可以是模块，包含我们最常见的 JavaScript，以及 css 文件、图片、json 文件等等。通过 webpack 的各种加载器，我们可以更有效地管理这些文件。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;_8211_webpack&#34;&gt;起手式 &amp;#8211; 安装 webpack&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;hey_8211_webpack&#34; href=&#34;#_8211_webpack&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    我们通过 &lt;code&gt;npm&lt;/code&gt; 全局安装 webpack：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;npm install webpack -g
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    安装完成后，我们可以使用 &lt;code&gt;webpack&lt;/code&gt; 命令，执行
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;webpack --help
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    能够查看 webpack 提供的所有命令。
  &lt;/p&gt;
  
  &lt;p&gt;
    &lt;strong&gt;不过，通常建议在项目目录中安装一份本地的 webpack：&lt;/strong&gt;
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;npm install webpack --save-dev
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    如果觉得 npm 安装太慢，可以尝试 npm 的替代工具 &lt;a href=&#34;http://gugel.io/ied/&#34;&gt;ied&lt;/a&gt; &amp;#8211; 我的使用经历，它的速度比 npm 快太多了。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i&#34;&gt;初始化项目&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi&#34; href=&#34;#i&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    安装好 webpack 后，我们要怎么开始一个项目？
  &lt;/p&gt;
  
  &lt;p&gt;
    如果你用过 grunt.js、gulpjs 一类工具，它们可以借助 &lt;a href=&#34;https://github.com/yeoman/generator-webapp&#34;&gt;yeoman 来初始化项目&lt;/a&gt;。webpack 的情况不太一样，我们可以把它当作 node.js 项目来初始化。当然，借用一些模板会更省事，比如 &lt;a href=&#34;https://github.com/gaearon/react-transform-boilerplate&#34;&gt;react transform boilerplate&lt;/a&gt;。
  &lt;/p&gt;
  
  &lt;p&gt;
    但这里还是聊聊如何手动初始化一个 webpack 项目。
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        创建一个 package.json 文件，用于保存项目版本、依赖关系等
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;npm init
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        在当前目录下安装 webpack
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;npm install webpack --save-dev
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    之后，我们的项目下有两个内容：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      package.json 文件
    &lt;/li&gt;
    &lt;li&gt;
      node_modules 文件夹
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    我们还需要一个 &lt;code&gt;index.html&lt;/code&gt; 文件，示例如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&#34;en&#34;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&#34;UTF-8&#34;&amp;gt;
    &amp;lt;title&amp;gt;webpack 教程&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    现在，我们可以通过 &lt;a href=&#34;https://github.com/tapio/live-server&#34;&gt;live-server&lt;/a&gt; 等访问到 index.html 页面。
  &lt;/p&gt;
  
  &lt;p&gt;
    目前页面上还是一片空白，除了一个标题。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;webpack&#34;&gt;webpack 配置&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heywebpack&#34; href=&#34;#webpack&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    在单页面应用里，项目通常会有一个入口（entry）文件，假设是 &lt;code&gt;main.js&lt;/code&gt;，我们通过配置 webpack 来指明它的位置。
  &lt;/p&gt;
  
  &lt;p&gt;
    首先，在项目根目录新建一个 &lt;code&gt;webpack.config.js&lt;/code&gt;，这是 webpack 默认的配置文件名称，添加以下内容：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;module.exports = {
  entry: &#39;./main.js&#39;
};
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这时在项目根目录执行 &lt;code&gt;webpack&lt;/code&gt;，会提示我们，
  &lt;/p&gt;
  
  &lt;blockquote&gt;
    &lt;p&gt;
      Output filename not configured.
    &lt;/p&gt;
  &lt;/blockquote&gt;
  
  &lt;p&gt;
    因为我们只是设定了入口（entry），还没有设定一个输出文件的路径与名称。
  &lt;/p&gt;
  
  &lt;p&gt;
    在 &lt;code&gt;webpack.config.js&lt;/code&gt; 中添加一个 &lt;code&gt;output&lt;/code&gt;：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;module.exports = {
    entry: &#39;./main.js&#39;,
    output: {
        path: __dirname, // 输出文件的保存路径
        filename: &#39;bundle.js&#39; // 输出文件的名称
    }
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    现在在项目里执行 &lt;code&gt;webpack&lt;/code&gt; 命令，我们的根目录下会多出一个 &lt;code&gt;bundle.js&lt;/code&gt; 文件：
  &lt;/p&gt;
  
  &lt;p&gt;
    &lt;a href=&#34;//www.zfanw.com/blog/wp-content/uploads/2015/06/Screen-Shot-2015-06-05-at-20.53.08.png&#34; rel=&#34;attachment wp-att-16394&#34;&gt;&lt;img src=&#34;//www.zfanw.com/blog/wp-content/uploads/2015/06/Screen-Shot-2015-06-05-at-20.53.08.png&#34; alt=&#34;webpack build&#34; width=&#34;766&#34; class=&#34;alignnone size-full wp-image-16394&#34; srcset=&#34;https://www.zfanw.com/blog/wp-content/uploads/2015/06/Screen-Shot-2015-06-05-at-20.53.08.png 766w, https://www.zfanw.com/blog/wp-content/uploads/2015/06/Screen-Shot-2015-06-05-at-20.53.08-300x82.png 300w, https://www.zfanw.com/blog/wp-content/uploads/2015/06/Screen-Shot-2015-06-05-at-20.53.08-100x27.png 100w, https://www.zfanw.com/blog/wp-content/uploads/2015/06/Screen-Shot-2015-06-05-at-20.53.08-520x143.png 520w&#34; sizes=&#34;(max-width: 766px) 100vw, 766px&#34; /&gt;&lt;/a&gt;
  &lt;/p&gt;
  
  &lt;p&gt;
    接下来，在 index.html 中引用 bundle.js 文件：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&#34;en&#34;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&#34;UTF-8&#34;&amp;gt;
    &amp;lt;title&amp;gt;webpack 教程&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;script src=&#34;./bundle.js&#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!-- 在 index.html 文件中添加这一行代码 --&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    大功告成。
  &lt;/p&gt;
  
  &lt;p&gt;
    这是 webpack 与 browserify 一类工具的特点，它们在 HTML 文件中直接引用构建后的 js 文件，而不是源文件。
  &lt;/p&gt;
  
  &lt;p&gt;
    当然，这可能会引发性能问题，毕竟，如果每一点文件修改都会导致整个 bundle.js 文件重新构建的话，碰上大一点的项目，有几千个源文件要编译，编译速度降下来是必然的。webpack 有它的解决办法，具体参见&lt;a href=&#34;https://webpack.github.io/docs/build-performance.html&#34;&gt;它的文档&lt;/a&gt;。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-2&#34;&gt;实时刷新&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-2&#34; href=&#34;#i-2&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    在 html 文件中引用 bundle.js 文件后，我们有几个问题需要解决。
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        &lt;code&gt;main.js&lt;/code&gt; 或它所引用的模块的变化如何通知 webpack，重新生成 &lt;code&gt;bundle.js&lt;/code&gt;？
      &lt;/p&gt;
      
      &lt;p&gt;
        非常简单，在根目录下执行 &lt;code&gt;webpack --watch&lt;/code&gt; 就可以监控目录下的文件变化并实时重新构建。
      &lt;/p&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        上面只是实时构建，我们该如何把结果通知给浏览器页面，让 HTML 页面上的 bundle.js 内容保持最新？
      &lt;/p&gt;
      
      &lt;p&gt;
        webpack 提供了 &lt;a href=&#34;http://webpack.github.io/docs/webpack-dev-server.html&#34;&gt;webpack-dev-server&lt;/a&gt; 解决实时刷新页面的问题，同时解决实时构建的问题。
      &lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    ​
  &lt;/p&gt;
  
  &lt;h3&gt;
    安装 webpack-dev-server
  &lt;/h3&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        在全局环境中安装 webpack-dev-server：
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;npm install webpack-dev-server -g
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        在项目根目录下执行命令：
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;$ webpack-dev-server
&lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;
        这样，我们就可以在默认的 &lt;code&gt;http://localhost:8080&lt;/code&gt; 网址上打开我们的 index.html。
      &lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    此时，我们可能认为事情是按以下顺序发生的，
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      js 文件修改
    &lt;/li&gt;
    &lt;li&gt;
      webpack-dev-server 监控到变化
    &lt;/li&gt;
    &lt;li&gt;
      webpack 在内存中重新构建 bundle.js
    &lt;/li&gt;
    &lt;li&gt;
      webpack-dev-server 保证页面引用的 bundle.js 文件与内存中一致
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    但不幸的是，我们「自以为是」了。&lt;code&gt;http://localhost:8080/index.html&lt;/code&gt; 对 js 文件的变化无动于衷。
  &lt;/p&gt;
  
  &lt;p&gt;
    webpack-dev-server 提供了&lt;a href=&#34;http://webpack.github.io/docs/webpack-dev-server.html#automatic-refresh&#34;&gt;两种模式&lt;/a&gt;用于自动刷新页面：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        iframe 模式
      &lt;/p&gt;
      
      &lt;p&gt;
        我们不访问 &lt;code&gt;http://localhost:8080&lt;/code&gt;，而是访问 &lt;code&gt;http://localhost:8080/webpack-dev-server/index.html&lt;/code&gt;
      &lt;/p&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        inline 模式
      &lt;/p&gt;
      
      &lt;p&gt;
        在命令行中指定该模式，&lt;code&gt;webpack-dev-server --inline&lt;/code&gt;。这样 &lt;code&gt;http://localhost:8080/index.html&lt;/code&gt; 页面就会在 js 文件变化后自动刷新了。
      &lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    以上说的两个页面自动刷新的模式都是指刷新整个页面，相当于点击了浏览器的&lt;strong&gt;刷新&lt;/strong&gt;按钮。
  &lt;/p&gt;
  
  &lt;p&gt;
    webpack-dev-server 还提供了一种 &lt;a href=&#34;https://webpack.github.io/docs/hot-module-replacement.html&#34;&gt;&lt;code&gt;--hot&lt;/code&gt; 模式&lt;/a&gt;，属于较高阶的应用。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-3&#34;&gt;第三方库&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-3&#34; href=&#34;#i-3&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    webpack 并不是包管理器，所以如果我们要使用第三方库，需要借助 npm。比如，在项目里安装 &lt;code&gt;jQuery&lt;/code&gt;：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;npm install jquery --save
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这样我们在当前项目目录下安装了 jquery，并将它写入 package.json 里的依赖里。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-4&#34;&gt;模块化&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-4&#34; href=&#34;#i-4&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;h3&gt;
    模块化 JavaScript
  &lt;/h3&gt;
  
  &lt;p&gt;
    如果我想用 ES6 的方式引入某个 es6 模块，比如：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;import $ from &#39;whatever&#39;;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    怎么办？浏览器目前还不提供原生支持，webpack 原生也仅支持 CommonJS 的那种写法，但借助 &lt;a href=&#34;http://babeljs.io/docs/setup/#webpack&#34;&gt;babel-loader&lt;/a&gt; ，我们可以加载 es6 模块：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        安装 babel-loader
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;npm install babel-loader babel-core babel-preset-es2015 --save-dev
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        配置 webpack.config.js
      &lt;/p&gt;
      
      &lt;p&gt;
        在 &lt;code&gt;module.exports&lt;/code&gt; 值中添加 &lt;code&gt;module&lt;/code&gt;：
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;module.exports = {
entry: {
    app: [&#39;./main.js&#39;]
},
output: {
    filename: &#39;bundle.js&#39;
},
module: {
    loaders: [{
        test: /\.js$/,
        loaders: [&#39;babel?presets[]=es2015&#39;],
        exclude: /node_modules/
    }]
}
}
&lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;
        这样我们就可以在我们的 js 文件中使用 ES6 语法，babel-loader 负责翻译。
      &lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    上面的方法，是在 webpack.config.js 文件中给某一类型文件定义加载器，我们还可以在代码中直接指定：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;import $ from &#39;babel!whatever&#39;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    当然，前一种方法会更优雅。
  &lt;/p&gt;
  
  &lt;h3&gt;
    CSS 加载器
  &lt;/h3&gt;
  
  &lt;p&gt;
    我们可以按传统方法使用 CSS，即在 HTML 文件中添加：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&#34;stylesheet&#34; href=&#34;style/app.css&#34;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    但 webpack 里，CSS 同样可以模块化，使用 &lt;code&gt;import&lt;/code&gt; 导入。
  &lt;/p&gt;
  
  &lt;p&gt;
    因此我们不再使用 &lt;code&gt;link&lt;/code&gt; 标签来引用 CSS，而是通过 webpack 的 &lt;a href=&#34;https://github.com/webpack/style-loader&#34;&gt;style-loader&lt;/a&gt; 及 &lt;a href=&#34;https://github.com/webpack/css-loader&#34;&gt;css-loader&lt;/a&gt;。前者将 css 文件以 &lt;code&gt;&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;&lt;/code&gt; 标签插入 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 头部，后者负责解读、加载 CSS 文件。
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        安装 CSS 相关的加载器
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;npm install style-loader css-loader --save-dev
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        配置 webpack.config.js 文件
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;{
// ...
module: {
    loaders: [
        { test: /\.css$/, loaders: [&#39;style&#39;, &#39;css&#39;] }
    ]
}
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        在 main.js 文件中引入 css
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;import&#39;./style/app.css&#39;;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    这样，在执行 &lt;code&gt;webpack&lt;/code&gt; 后，我们的 CSS 文件就会被打包进 bundle.js 文件中，如果不想它们被打包进去，可以使用 &lt;a href=&#34;https://github.com/webpack/extract-text-webpack-plugin&#34;&gt;extract text 扩展&lt;/a&gt;。
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      重启 webpack-dev-server
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;h3&gt;
    模块化 CSS
  &lt;/h3&gt;
  
  &lt;p&gt;
    上一步里，我们 &lt;code&gt;import&lt;/code&gt; 到 JavaScript 文件中的 CSS 文件中的 CSS 在打包后是仍然是全局的，也就是说，我们只是换了种加载 CSS 的方式，在书写 CSS 的时候，还是需要注意使用&lt;a href=&#34;https://en.bem.info/method/definitions/&#34;&gt;命名规范，比如使用 BEM&lt;/a&gt;，否则全局环境 CSS 类的冲突等问题不会消失。
  &lt;/p&gt;
  
  &lt;p&gt;
    这里，webpack 做了一个&lt;a href=&#34;https://medium.com/seek-ui-engineering/the-end-of-global-css-90d2a4a06284&#34;&gt;模块化 CSS 的尝试&lt;/a&gt;，真正意思上的「模块化」，即 CSS 类不会泄露到全局环境中，而只会定义在 UI 模块内 &amp;#8211; 类似 react.js 这类模块，或者 &lt;a href=&#34;http://www.w3.org/wiki/WebComponents/&#34; title=&#34;w3c web components&#34;&gt;web components&lt;/a&gt;。
  &lt;/p&gt;
  
  &lt;h3&gt;
    autoprefixer
  &lt;/h3&gt;
  
  &lt;p&gt;
    我们在写 CSS 时，按 CSS 规范写，构建时利用 autoprefixer 可以输出 -webkit、-moz 这样的浏览器前缀，webpack 同样是通过 &lt;a href=&#34;https://github.com/passy/autoprefixer-loader&#34; title=&#34;github autoprefixer 加载器&#34;&gt;loader 提供该功能&lt;/a&gt;。
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        安装 autoprefixer-loader
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;npm install autoprefixer-loader --save-dev
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        配置 webpack.config.js
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;loaders: [{
test: /\.css$/,
loader: &#39;style!css!autoprefixer?{browsers:[&#34;last 2 version&#34;, &#34;&amp;gt; 1%&#34;]}&#39;,
//...
}]
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        重启 webpack-dev-server
      &lt;/p&gt;
      
      &lt;p&gt;
        假如我们在 CSS 中写了 &lt;code&gt;body { display: flex; }&lt;/code&gt; 规则，再查看 &lt;code&gt;bundle.js&lt;/code&gt; 文件的话，我们能看到类似如下的代码：
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;body {\n\tdisplay: -webkit-box;\n\tdisplay: -webkit-flex;\n\tdisplay: -ms-flexbox;\n\tdisplay: flex;\n}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;h3&gt;
    图片
  &lt;/h3&gt;
  
  &lt;p&gt;
    图片同样可以是模块，但使用的是 &lt;a href=&#34;https://github.com/webpack/file-loader&#34;&gt;file loader&lt;/a&gt; 或者 &lt;a href=&#34;https://github.com/webpack/url-loader&#34;&gt;url loader&lt;/a&gt;，后者会根据定义的大小范围来判断是否使用 data url。
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;import loadingIMG from &#39;file!../img/loading.gif&#39;

React.render(&amp;lt;img src={loadingIMG} /&amp;gt;, document.getElementById(&#39;app&#39;));
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-5&#34;&gt;打包、构建&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-5&#34; href=&#34;#i-5&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    项目结束后，代码要压缩、混淆、合并等，只需要在命令行执行：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;webpack
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    即可，webpack 根据 webpack.config.js 文件中的配置路径、构建文件名生成相应的文件。通常，我们会额外定义一个专门用于生产环境的配置文件，比如 &lt;strong&gt;webpack.production.config.js&lt;/strong&gt;，其中可以做许多代码优化。
  &lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>