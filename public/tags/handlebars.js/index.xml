<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Handlebars.Js on 陈三</title>
    <link>https://www.zfanw.com/blog/tags/handlebars/index.js/</link>
    <description>Recent content in Handlebars.Js on 陈三</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Fri, 10 Jan 2014 14:10:14 +0000</lastBuildDate>
    <atom:link href="https://www.zfanw.com/blog/tags/handlebars.js/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Handlebars.js 预编译</title>
      <link>https://www.zfanw.com/blog/handlebars-js-precompilation.html</link>
      <pubDate>Fri, 10 Jan 2014 14:10:14 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/handlebars-js-precompilation.html</guid>
      <description>

&lt;p&gt;Handlebars.js 官网上对预编译&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:11247-1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:11247-1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;是这样说的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;你需要安装 Node.js&lt;/li&gt;
&lt;li&gt;你需要在全局环境中，通过 Npm 安装 handlebars 包&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后你就可以通过命令预编译你的 handlebars 模板文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ handlebars &amp;lt;input&amp;gt; --output &amp;lt;output&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设我有一个模板文件，名称为 person.handlebars，内容很简单，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;This is {{firstname}} {{lastname}}&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假定编译后输出文件的名称为 person.js&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:11247-2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:11247-2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;，检查 person.js 文件内容，可以看到，一个 Handlebars.templates 对象下增加了一个 &lt;code&gt;person&lt;/code&gt; 属性名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};
templates[&#39;person&#39;] = template(function (Handlebars,depth0,helpers,partials,data) {
    ......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后，我们只要在页面 HTML 页面引用 handlebars.runtime.js、person.js 文件，并且通过 js 传入数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Handlebar.js 模板&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;person&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script src=&amp;quot;js/handlebars.runtime.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;js/person.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
        var compiledTemplate = Handlebars.templates[&#39;person&#39;],
        html = compiledTemplate({&amp;quot;firstname&amp;quot;: &amp;quot;三&amp;quot;, &amp;quot;lastname&amp;quot;: &amp;quot;陈&amp;quot;});
        document.getElementById(&#39;person&#39;).innerHTML = html;
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在浏览器打开 HTML 页面，可以看到最终结果：This is 三 陈。&lt;/p&gt;

&lt;p&gt;OK，看完 Handlebars.js 官网提供的纯手工预编译模板的方法后，再来看看 Grunt.js 是怎样全自动预编译模板的。&lt;/p&gt;

&lt;h2 id=&#34;grunt-contrib-handlebars-11247-3&#34;&gt;grunt-contrib-handlebars&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:11247-3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:11247-3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;

&lt;p&gt;因为是基于 Grunt.js，所以假定环境中已经安装好 Node.js、Npm，&lt;code&gt;grunt&lt;/code&gt; 命令也能正常运行。&lt;/p&gt;

&lt;p&gt;首先，需要在工作目录下需要安装 &lt;code&gt;grunt-contrib-handlebars&lt;/code&gt; 模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd myJob
$ npm install grunt-contrib-handlebars --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完 grunt-contrib-handlebars 模块后，我们需要在 Gruntfile.js 文件中加载它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt.loadNpmTasks(&#39;grunt-contrib-handlebars&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，还是在 Gruntfile.js 文件中，配置预编译任务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;handlebars: { //定义预编译任务
    compile: {
        options: {
            namespace: &amp;quot;JST&amp;quot; //命名空间，这个很重要，后面会提到
        },
        files: [{
            expand: true,
            cwd: &#39;js/src/handlebars&#39;,
            src: &#39;**/*.handlebars&#39;, //模板文件
            dest: &#39;js/dest/handlebars/&#39;, //编译后的文件存放位置
            ext: &#39;.js&#39; //编译后的文件格式          
        }]
        //如果要把所有模板文件编译到一个 .js 文件，则可以写成：
        //files: {&amp;quot;js/dest/template.js&amp;quot;: [&#39;js/src/handlebars/**/*.handlebars&#39;]}
    }
}
watch: { //监控文件变化并自动执行预编译任务
    precompile: {
        files: &#39;js/src/handlebars/**/*.handlebars&#39;,
        tasks: [&#39;handlebars&#39;]
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，如果等不及 &lt;code&gt;grunt watch&lt;/code&gt;，可以先执行 &lt;code&gt;grunt handlebars&lt;/code&gt; 命令预编译，得到的 person.js &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:11247-4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:11247-4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this[&amp;quot;JST&amp;quot;] = this[&amp;quot;JST&amp;quot;] || {};

this[&amp;quot;JST&amp;quot;][&amp;quot;js/person.handlebars&amp;quot;] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
this.compilerInfo = [4,&#39;&amp;gt;= 1.0.0&#39;];
......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个版本跟手工生成的可不太一样。当然，如果想生成与手工一样的结果也很简单，只要把选项中的 &lt;code&gt;namespace&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;好了，现在我们的 &lt;code&gt;person&lt;/code&gt; 存放的位置变了，不再是之前的 &lt;code&gt;templates[&#39;person&#39;]&lt;/code&gt;，而是 &lt;code&gt;this[&amp;quot;JST&amp;quot;][&amp;quot;js/person.handlebars&amp;quot;]&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:11247-5&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:11247-5&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;，那么，在 HTML 里，我们的 &lt;code&gt;compiledTemplate&lt;/code&gt; 是怎么获取？很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var compiledTemplate = JST[&amp;quot;js/person.handlebars&amp;quot;],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为，在 grunt-contrib-handlebars 自动预编译的文件中，&lt;code&gt;this&lt;/code&gt; 在浏览器环境下指向 window 对象，所以我们不过是把模板对象存放到一个新的命名空间 JST 下的 &amp;#8220;js/person.handlebars&amp;#8221; 属性名里，结果是，代码冲突的可能性更小了。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:11247-1&#34;&gt;&lt;a href=&#34;http://handlebarsjs.com/precompilation.html&#34;&gt;Handlebars.js: Minimal Templating on Steroids&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:11247-1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:11247-2&#34;&gt;&lt;a href=&#34;https://gist.github.com/chenxsan/8351314#file-person-js&#34;&gt;Handlebars.js 预编译的结果&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:11247-2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:11247-3&#34;&gt;&lt;a href=&#34;https://github.com/gruntjs/grunt-contrib-handlebars&#34;&gt;gruntjs/grunt-contrib-handlebars&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:11247-3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:11247-4&#34;&gt;&lt;a href=&#34;https://gist.github.com/chenxsan/8352178&#34;&gt;Grunt 自动编译的 Handlebars.js 模板&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:11247-4&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:11247-5&#34;&gt;&lt;a href=&#34;http://danburzo.ro/grunt/chapters/handlebars/&#34;&gt;Pre-compile your Handlebars templates&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:11247-5&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>