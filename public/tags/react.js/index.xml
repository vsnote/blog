<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>React.Js on 陈三</title>
    <link>https://www.zfanw.com/blog/tags/react/index.js/</link>
    <description>Recent content in React.Js on 陈三</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 09 Jun 2016 08:41:15 +0000</lastBuildDate>
    <atom:link href="https://www.zfanw.com/blog/tags/react.js/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>错误分类</title>
      <link>https://www.zfanw.com/blog/different-errors.html</link>
      <pubDate>Thu, 09 Jun 2016 08:41:15 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/different-errors.html</guid>
      <description>&lt;p&gt;​如果你在网页上看到错误提示，它们的来源大致有两种，一种来自前端，一种来自后端。&lt;/p&gt;

&lt;p&gt;比如说有一个邮箱地址的输入框，用户试图提交空值，我们会报告一个前端上的错误：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;请填写邮箱地址&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在 react.js 里，这个错误是一个 &lt;a href=&#34;https://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html#what-shouldnt-go-in-state&#34;&gt;computed 值&lt;/a&gt;（计算值 &amp;#8211; 即依赖其它 state 计算出来的）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Email extends React.Component {
  state = {
    email: &#39;&#39;
  }
  render () {
    const computedError = email.trim() === &#39;&#39; ? &#39;请填写邮箱地址&#39; : &#39;&#39;
    return &amp;lt;div&amp;gt;
      &amp;lt;input type=&#39;text&#39; value={this.state.email}/&amp;gt;
      &amp;lt;span&amp;gt;{computedError}&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为，&lt;code&gt;state&lt;/code&gt; 多了，代码难以管理，所以有些数据我们要尽量从其它数据中推演，而不是新建一个。&lt;/p&gt;

&lt;p&gt;但上面的示例里，email 地址提交到服务端，还可能返回一种错误：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;该邮箱地址已经被人注册&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这一种错误，并没办法通过 &lt;code&gt;email&lt;/code&gt; 数据推演，我的做法是，新建一个 state 用来存储。不过这类表单数据多了，整个组件就会非常庞大，很容易出错。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>redux.js 的盛行</title>
      <link>https://www.zfanw.com/blog/redux-js-prevail.html</link>
      <pubDate>Wed, 01 Jun 2016 02:35:36 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/redux-js-prevail.html</guid>
      <description>&lt;p&gt;在 react.js 里，如果把一个组件写在另一个组件的 &lt;code&gt;render&lt;/code&gt; 方法里，则其它组件要用它的话，我们又要重复一遍代码。所以我们要抽取它，独立成一个组件。可是，这时它的 &lt;code&gt;state&lt;/code&gt; 应该放在哪里？&lt;/p&gt;

&lt;p&gt;如果我们把 &lt;code&gt;state&lt;/code&gt; 放在组件内部，则父组件有读取子组件数据的需求时，父组件内部就要创建一个变量，还要提供给子组件一个回调，这样，同样的 &lt;code&gt;state&lt;/code&gt; 我们会在父、子两个地方实现，则不如 &lt;code&gt;state&lt;/code&gt; 只定义在父组件中，通过 &lt;code&gt;props&lt;/code&gt; 传递给子组件，这样，子组件的功能就比较单一，便于复用。&lt;/p&gt;

&lt;p&gt;但是，又有一个新的问题产生。举一个 Email 组件来说，它可能在登录表单组件里使用，也可能在注册表单组件里使用，这两个父组件的逻辑是不一样的，无法复用，而它们在使用 Email 组件时，却都需要提供给 Email 组件一个变量及一个回调函数 &amp;#8211; 它们在两个父组件中显然又是重复的。&lt;/p&gt;

&lt;p&gt;比如我的一个使用 &lt;a href=&#34;https://github.com/mobxjs/mobx&#34;&gt;mobx&lt;/a&gt; 的注册组件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import React, { Component } from &#39;react&#39;
import { observable, action, computed } from &#39;mobx&#39;
import Email from &#39;../common/Email&#39;

@observer
class Register extends Component {
  @observable email = &#39;&#39;
  @computed get emailError () {
    if (this.email.trim() === &#39;&#39;) {
      return &#39;请填写邮箱地址&#39;
    }
    if (!emailRegExp.test(this.email.trim())) {
      return &#39;请填写正确的邮箱地址&#39;
    }
    return &#39;&#39;
  }
  render () {
    return (
      &amp;lt;div&amp;gt;
          &amp;lt;Email email={this.email}
            changeEmail={this.changeEmail}
            emailError={this.emailError}
            /&amp;gt;
      &amp;lt;/div&amp;gt;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在登录组件中，几乎一模一样的代码，我又要重复一遍。&lt;/p&gt;

&lt;p&gt;Don&amp;#8217;t repeat yourself 说起来当然是简单，但做起来并不容易。就说我们上面所做的演进，目的是满足需求的同时消除重复，但结果我们只是把 repeat 从一个地方迁移到了另一个地方。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://redux.js.org/index.html&#34;&gt;Redux&lt;/a&gt; 能解决我们的问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将父组件中重复的变量存储到 store 中&lt;/li&gt;
&lt;li&gt;回调函数拆为 reducer + action&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样，我们就不必在多个父组件里重复变量及回调函数。但是，因为我们把变量存储在 store 里，把回调函数拆为 reducer + action，则我们在使用时，就又多了一个读取过程，在 redux.js 里，这通过 &lt;a href=&#34;https://github.com/reactjs/react-redux/blob/master/docs/api.md#api&#34;&gt;react-redux&lt;/a&gt; 实现。&lt;/p&gt;

&lt;p&gt;当然，像 redux 这样提取父组件中重复变量然后复用的做法并不能满足所有需求。很多时候，我们确实需要两份数据，这时，redux &lt;a href=&#34;https://github.com/reactjs/redux/issues/822#issuecomment-186614362&#34;&gt;也没有&lt;/a&gt;好的&lt;a href=&#34;https://github.com/reactjs/redux/issues/897#issuecomment-148233789&#34;&gt;解决办法&lt;/a&gt;，因为 action 没法复用，reducer 也没法复用。&lt;/p&gt;

&lt;p&gt;在 redux 的定义里，组件有两种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Container component&lt;/li&gt;
&lt;li&gt;Presentational component&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面的例子里，Email 组件是 Presentational component，要做到它的复用十分容易，而登录或注册组件则属于 Container component，它们的复用性就非常低，代码上的重复也很难避免 &amp;#8211; 目前我还没看到较好的解决办法。&lt;/p&gt;

&lt;p&gt;如果你有，欢迎留言：）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>React.js 服务端渲染</title>
      <link>https://www.zfanw.com/blog/react-js-server-render.html</link>
      <pubDate>Fri, 05 Feb 2016 14:01:43 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/react-js-server-render.html</guid>
      <description>&lt;div id=&#34;toc_container&#34; class=&#34;ml-l u-floatRight pure-u-1-1 pure-u-sm-2-5 toc_white no_bullets&#34;&gt;
  &lt;nav id=&#34;myaffix&#34;&gt;
  
  &lt;p class=&#34;toc-title&#34;&gt;
    目录
  &lt;/p&gt;
  
  &lt;ul class=&#34;toc-list nav&#34; role=&#34;menu&#34;&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#renderToString&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;1&lt;/span&gt; renderToString&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;2&lt;/span&gt; 准备工作&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-2&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;3&lt;/span&gt; 按部就班&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#_bundlejs&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;4&lt;/span&gt; 构建 bundle.js&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;&lt;/nav&gt;
&lt;/div&gt;

&lt;div class=&#34;&#34;&gt;
  &lt;p&gt;
    是否多此一举？
  &lt;/p&gt;
  
  &lt;p&gt;
    毕竟，从服务端渲染走到客户端渲染这一步，前端界可花了不少时间。
  &lt;/p&gt;
  
  &lt;p&gt;
    如果你对服务端渲染的必要性心存疑虑，不妨先看看&lt;a href=&#34;http://alistapart.com/article/interaction-is-an-enhancement&#34;&gt;这一篇&lt;/a&gt;文章。
  &lt;/p&gt;
  
  &lt;p&gt;
    但我还是在这儿简单介绍下，为什么这些客户端渲染的框架们要踏入服务端渲染的领域。
  &lt;/p&gt;
  
  &lt;p&gt;
    在客户端渲染时，我们的页面通常很简洁，比如，你可能见过这样的 HTML 文件：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;这是陈三&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;script src=&#39;http://code.jquery.com/jquery-2.1.4.min.js&#39;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&#39;http://example.com/test.bundle.js&#39;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    陈三在打开这个页面后，浏览器会加载：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      jquery-2.1.4.min.js
    &lt;/li&gt;
    &lt;li&gt;
      test.bundle.js
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    在这两个文件加载完成并执行以前，陈三只能看到一片空白。等了十来秒后，页面还没有动静，陈三找来专业人士，哦，jquery-2.1.4.min.js 文件不知道怎么回事，加载失败，导致 test.bundle.js 无法构建 HTML 代码。
  &lt;/p&gt;
  
  &lt;p&gt;
    实际上：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      任何 js 代码问题都可能导致陈三看不到页面
    &lt;/li&gt;
    &lt;li&gt;
      搜索引擎可能无法索引这样的页面（对，&lt;a href=&#34;https://googlewebmastercentral.blogspot.com/2015/10/deprecating-our-ajax-crawling-scheme.html&#34;&gt;Google 可以做到&lt;/a&gt;，但不是所有搜索引擎都是 Google）
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    那么，我们可以做得更好吗？
  &lt;/p&gt;
  
  &lt;p&gt;
    这正是 Ember.js、Angular.js 等努力的方向。这一篇，则是介绍 react.js 在这方面的情况。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;renderToString&#34;&gt;renderToString&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyrenderToString&#34; href=&#34;#renderToString&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    react 官网文档在服务端渲染上&lt;a href=&#34;https://facebook.github.io/react/docs/top-level-api.html#reactdomserver&#34;&gt;着墨不多&lt;/a&gt;：
  &lt;/p&gt;
  
  &lt;blockquote&gt;
    &lt;p&gt;
      Render a ReactElement to its initial HTML. This should only be used on the server. React will return an HTML string. You can use this method to generate HTML on the server and send the markup down on the initial request for faster page loads and to allow search engines to crawl your pages for SEO purposes.
    &lt;/p&gt;
    
    &lt;p&gt;
      If you call ReactDOM.render() on a node that already has this server-rendered markup, React will preserve it and only attach event handlers, allowing you to have a very performant first-load experience.
    &lt;/p&gt;
  &lt;/blockquote&gt;
  
  &lt;p&gt;
    简单说，&lt;code&gt;renderToString&lt;/code&gt; 方法在服务器上先渲染出组件的 HTML 结构，客户端上 react 在执行到 &lt;code&gt;render()&lt;/code&gt; 方法时，会检查是否有服务端渲染过的代码，如果有，则仅仅往上添加事件处理器。我们不妨这样认为，原来在客户端要执行的 js 代码被拆成两个部分：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      渲染 HTML 结构
    &lt;/li&gt;
    &lt;li&gt;
      往 HTML 结构上附加事件处理器
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    前者在服务端上完成，后者在客户端上完成。
  &lt;/p&gt;
  
  &lt;p&gt;
    那么，我们要怎么入手 react.js 服务端渲染？react.js 初期开发者 Pete Hunt 给了些&lt;a href=&#34;https://github.com/petehunt/react-howto#learning-server-rendering&#34;&gt;建议&lt;/a&gt;：
  &lt;/p&gt;
  
  &lt;blockquote&gt;
    &lt;p&gt;
      Server rendering still requires a lot of tooling to get right. Since it transparently supports React components written without server rendering in mind, you should build your app first and worry about server rendering later. You won&amp;#8217;t need to rewrite all of your components to support it.
    &lt;/p&gt;
  &lt;/blockquote&gt;
  
  &lt;p&gt;
    要做服务端渲染，我们要干的事还很多，但通常可以先构建 app，再来关心服务端渲染。我们并不会需要全部重写所有的组件。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i&#34;&gt;准备工作&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi&#34; href=&#34;#i&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    我们要先解决以下问题：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        server 端用什么框架？
      &lt;/p&gt;
      
      &lt;p&gt;
        对前端开发来说，基于 node.js 的框架通常更易于上手，所以这里选用了 &lt;a href=&#34;http://expressjs.com/&#34;&gt;expressjs&lt;/a&gt;。
      &lt;/p&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        要构建出前端使用的 js 文件，要用什么工具？
      &lt;/p&gt;
      
      &lt;p&gt;
        不论是 requirejs 还是 browserify 或 jspm 都可以用，这里使用 webpack。
      &lt;/p&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        react.js 在后端 render 时，如果要用 jsx 语法，要怎么解决？
      &lt;/p&gt;
      
      &lt;p&gt;
        使用 &lt;a href=&#34;https://www.zfanw.com/blog/babel-6.html#babel-register&#34;&gt;babel-register&lt;/a&gt;。
      &lt;/p&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        如果我想用 es2015 语法后 express.js 程序，要怎么做？
      &lt;/p&gt;
      
      &lt;p&gt;
        同第 3 点。
      &lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    接下来就是安装 react、react-dom、babel，并且配置 babel，&lt;a href=&#34;https://github.com/chenxsan/react-server-render/tree/810b2cd13ccdc9d59784e97f1937efe949de21ff&#34;&gt;点击查看项目代码&lt;/a&gt;。
  &lt;/p&gt;
  
  &lt;p&gt;
    好了，我们可以开始写代码了。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-2&#34;&gt;按部就班&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-2&#34; href=&#34;#i-2&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    首先，我们添加一个 Home 组件，代码如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;import React from &#39;react&#39;
export default class Home extends React.Component {
  render () {
    return (&amp;lt;div&amp;gt;
              hello from 陈三。
            &amp;lt;/div&amp;gt;)
  }
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这个组件目前只是渲染一段 div。
  &lt;/p&gt;
  
  &lt;p&gt;
    接下来是在 app.js 文件中引用它并渲染成 HTML：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;import express from &#39;express&#39;
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/server&#39;
import Home from &#39;./components/Home&#39;
let app = express()
app.get(&#39;/&#39;, (req, res) =&amp;gt; {
  res.send(ReactDOM.renderToString(React.createFactory(Home)()))
})
app.listen(3000, () =&amp;gt; {
  console.log(&#39;listen on 3000&#39;)
})

&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这里用到的两个方法：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;a href=&#34;https://facebook.github.io/react/docs/top-level-api.html#reactdomserver.rendertostring&#34;&gt;renderToString&lt;/a&gt; &amp;#8211; 将组件渲染成字符串。
    &lt;/li&gt;
    &lt;li&gt;
      &lt;a href=&#34;https://facebook.github.io/react/docs/top-level-api.html#react.createfactory&#34;&gt;createFactory&lt;/a&gt; &amp;#8211; 生成一个组件工厂方法，用于生成组件。之所以用它，是因为 renderToString 接受的参数是 ReactElement element，所以我们不能使用 jsx 的形式 &lt;code&gt;&amp;lt;Home /&amp;gt;&lt;/code&gt;。
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    执行 &lt;code&gt;node index.js&lt;/code&gt; 命令，可以在 http://localhost:3000 网址看到：
  &lt;/p&gt;
  
  &lt;blockquote&gt;
    &lt;p&gt;
      hello from 陈三。
    &lt;/p&gt;
  &lt;/blockquote&gt;
  
  &lt;p&gt;
    点击&lt;a href=&#34;https://github.com/chenxsan/react-server-render/tree/82ab7be8078743c31fa2e92cf62d0ffd9af69ad6&#34;&gt;查看这一步的项目代码&lt;/a&gt;。
  &lt;/p&gt;
  
  &lt;p&gt;
    目前为止，我们还没给组件添加任何交互行为，比如点击一下，&lt;strong&gt;字体颜色变化&lt;/strong&gt;。下面我们就来尝试给 Home 组件添加这一交互。
  &lt;/p&gt;
  
  &lt;p&gt;
    我们将 Home 组件改造如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;import React from &#39;react&#39;
export default class Home extends React.Component {
  constructor (props) {
    super(props)
    this.clickToChangeColor = this.clickToChangeColor.bind(this)
    this.state = {
      color: &#39;#&#39; + (Math.random() * 0xFFFFFF &amp;lt;&amp;lt; 0).toString(16)
    }
  }
  clickToChangeColor (e) {
    this.setState({
      color: &#39;#&#39; + (Math.random() * 0xFFFFFF &amp;lt;&amp;lt; 0).toString(16)
    })
  }
  render () {
    return (&amp;lt;div onClick={this.clickToChangeColor} style={{color: this.state.color}}&amp;gt;
              hello from 陈三。
            &amp;lt;/div&amp;gt;)
  }
}

&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    现在点击 div 块，字体颜色并不会出现任何变化，因为，目前为止，我们只是在后端渲染了 HTML 结构，事件绑定等工作，要在前端上完成。
  &lt;/p&gt;
  
  &lt;p&gt;
    但现在，我们还只是简单的生成一个页面，只有一个 &lt;code&gt;div&lt;/code&gt; 块，没有 &lt;code&gt;html&lt;/code&gt; 标签，没有 &lt;code&gt;meta&lt;/code&gt; 标签，也没有引用任何脚本。
  &lt;/p&gt;
  
  &lt;p&gt;
    我们需要一个完整的页面，这里，使用 &lt;a href=&#34;http://expressjs.com/en/guide/using-template-engines.html&#34;&gt;jade 模板引擎&lt;/a&gt;来生成页面。
  &lt;/p&gt;
  
  &lt;p&gt;
    我们在 views 目录下增加一个 &lt;code&gt;index.jade&lt;/code&gt; 模板：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;doctype html
html
    head
        title=&#39;react 服务端渲染&#39;
        meta(charset=&#39;utf-8&#39;)
    body
        #root!= react
        script(src=&#39;/bundle.js&#39;)
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    app.js 内容修改成：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;import express from &#39;express&#39;
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom/server&#39;
import Home from &#39;./components/Home&#39;
let app = express()
app.use(express.static(&#39;public&#39;))
app.set(&#39;views&#39;, &#39;./views&#39;)
app.set(&#39;view engine&#39;, &#39;jade&#39;)
let html = ReactDOM.renderToString(React.createFactory(Home)())
app.get(&#39;/&#39;, (req, res) =&amp;gt; {
  res.render(&#39;index&#39;, {react: html})
})
app.listen(3000, () =&amp;gt; {
  console.log(&#39;listen on 3000&#39;)
})
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    目前为止，我们还没有一个叫 &lt;code&gt;bundle.js&lt;/code&gt; 的文件，它将由 webpack 来构建。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;_bundlejs&#34;&gt;构建 bundle.js&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;hey_bundlejs&#34; href=&#34;#_bundlejs&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    如果对 webpack 的构建不熟悉，可以先看看 &lt;a href=&#34;https://www.zfanw.com/blog/webpack-tutorial.html&#34;&gt;我写的 webpack 教程&lt;/a&gt;。这里跳过安装 webpack、babel 等步骤。
  &lt;/p&gt;
  
  &lt;p&gt;
    上面说到的 app.js 是服务端的入口文件，前端上同样需要一个入口，且把它叫 client.js：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;import Home from &#39;./components/Home&#39;
import ReactDOM from &#39;react-dom&#39;
import React from &#39;react&#39;
ReactDOM.render(&amp;lt;Home /&amp;gt;, document.getElementById(&#39;root&#39;))
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    另外，我们再定义一个 webpack.config.js 文件：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;var path = require(&#39;path&#39;)
module.exports = {
  entry: &#39;./src/client&#39;,
  output: {
    filename: &#39;bundle.js&#39;,
    path: path.join(__dirname, &#39;public&#39;)
  },
  module: {
    loaders: [
      {test: /\.js$/,
        loaders: [&#39;babel?presets[]=react,presets[]=es2015&#39;],
        include: [path.join(__dirname, &#39;src&#39;)]
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    在项目根目录下执行 &lt;code&gt;webpack&lt;/code&gt;，我们就会得到 &lt;code&gt;public/bundle.js&lt;/code&gt;，刷新我们的主页，点击 div 就能看到文字的颜色在改变了。
  &lt;/p&gt;
  
  &lt;p&gt;
    就这样，我们完成了一趟轻松、简单的 react.js 服务端渲染之旅。
  &lt;/p&gt;
  
  &lt;p&gt;
    如果对完整的代码有兴趣，请点击 &lt;a href=&#34;https://github.com/chenxsan/react-server-render&#34;&gt;github 上的 react-server-render 仓库&lt;/a&gt;，还可以点击&lt;a href=&#34;https://www.zfanw.com/react/server-render/&#34;&gt;示例&lt;/a&gt;查看最终效果。
  &lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>React.js 动画</title>
      <link>https://www.zfanw.com/blog/react-js-animation.html</link>
      <pubDate>Wed, 23 Sep 2015 14:24:19 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/react-js-animation.html</guid>
      <description>

&lt;p&gt;我猜你看过 &lt;a href=&#34;https://facebook.github.io/react/docs/animation.html&#34;&gt;React.js 动画&lt;/a&gt;的文档，并且不下三遍。&lt;/p&gt;

&lt;p&gt;我看了不下十遍，还是觉得 &lt;a href=&#34;https://github.com/facebook/react/blob/master/src/addons/transitions/ReactCSSTransitionGroupChild.js&#34; title=&#34;源代码&#34;&gt;ReactCSSTransitionGroup&lt;/a&gt; 这 high-level API 跟魔法似的，另外，&lt;a href=&#34;https://github.com/facebook/react/search?q=ReactCSSTransitionGroup&amp;amp;type=Issues&amp;amp;utf8=✓&#34;&gt;奇奇怪怪的 bug&lt;/a&gt; 还不少。&lt;/p&gt;

&lt;p&gt;最后我决定试试更底层的 &lt;a href=&#34;https://facebook.github.io/react/docs/animation.html#low-level-api-reacttransitiongroup&#34;&gt;TransitionGroup&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;TransitionGroup 定义了动画组件的六个生命周期：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;componentWillAppear(callback)&lt;/li&gt;
&lt;li&gt;componentDidAppear()&lt;/li&gt;
&lt;li&gt;componentWillEnter(callback)&lt;/li&gt;
&lt;li&gt;componentDidEnter()&lt;/li&gt;
&lt;li&gt;componentWillLeave(callback)&lt;/li&gt;
&lt;li&gt;componentDidLeave()&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果你了解 componentDidMount 等，则这六个生命周期的概念是相近的，只不过，它们是动画组件才会有的。&lt;/p&gt;

&lt;p&gt;简单说，一个 TransitionGroup 容器中的组件，在它：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;加入容器&lt;/li&gt;
&lt;li&gt;或是从容器中移除&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;就会经历以上 6 个生命周期。&lt;/p&gt;

&lt;p&gt;我们操纵它在这些生命周期中的样式，也就产生了动画。&lt;/p&gt;

&lt;p&gt;来看一个简单模样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  render () {
    let todos = this.state.todos.map((todo, index) =&amp;gt; {
      return (
         &amp;lt;Animation key={index}&amp;gt;&amp;lt;li&amp;gt;{todo}&amp;lt;/li&amp;gt;&amp;lt;/Animation&amp;gt;
      )
    })
    return (
        &amp;lt;ReactTransitionGroup component=&#39;ul&#39;&amp;gt;
          {todos}
        &amp;lt;/ReactTransitionGroup&amp;gt;
    )
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ReactTransitionGroup 是容器，Animation 是容器中的元素。&lt;/p&gt;

&lt;p&gt;之所以要有一个 Animation 组件包装真正的元素，只是我为了便于代码复用。&lt;/p&gt;

&lt;p&gt;Animation 组件中，componentWillEnter 周期中的代码是这样的（&lt;strong&gt;注意，这是我理想中的版本&lt;/strong&gt;，具体情况见文末链接）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  componentWillEnter (cb) {
    let el = React.findDOMNode(this)
    el.classList.add(styles.enter)
    requestAnimationFrame(() =&amp;gt; {
      el.classList.add(styles.active)
    })
    el.addEventListener(&#39;transitionend&#39;, () =&amp;gt; {
      if (cb) cb()
    el.classList.remove(styles.enter)
    el.classList.remove(styles.active)
    })
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在 &lt;strong&gt;componentWillEnter&lt;/strong&gt; 里给 Animation 组件添加了 styles.enter 样式类，然后在浏览器下一个 tick 加入 styles.active 样式类 &amp;#8211; 这里使用了 requestAnimationFrame，也可以使用 setTimeout，另外我们还监听 &amp;#8216;transitionend&amp;#8217; 事件，transitionend 事件发生时执行回调 cb 并移除 styles.enter 与 styles.active 两个样式类（如果不了解这一种样式用法，请参见 &lt;a href=&#34;https://www.zfanw.com/blog/css-modularize.html&#34;&gt;CSS 模块化&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;相应的 CSS 文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.enter {
  opacity: 0;
}
.enter.active {
  opacity: 1;
  transition: opacity 0.5s ease-in;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，现实比较刺人，transitionend 事件并不稳定、时有时没有，所以我写的真实的代码其实是&lt;a href=&#34;https://github.com/chenxsan/demo-jest-test-flux-store/blob/master/src/animation/Animation.js&#34; title=&#34;访问 github&#34;&gt;这样&lt;/a&gt;，它基于 khan Academy 的 &lt;a href=&#34;https://github.com/Khan/react-components/blob/master/js/timeout-transition-group.jsx&#34;&gt;timeout-transition-group&lt;/a&gt; 组件做了改造，最后的动画效果请点击&lt;a href=&#34;https://www.zfanw.com/react/demo-store-test/&#34;&gt;示例&lt;/a&gt;查看。&lt;/p&gt;

&lt;p&gt;不过据说，我们有望在 react.js 0.14 中用上可靠的 &lt;a href=&#34;https://github.com/facebook/react/pull/4561&#34;&gt;ReactCSSTransitionGroup&lt;/a&gt; &amp;#8211; 现在是 react.js 0.14 rc 1。&lt;/p&gt;

&lt;p&gt;谢天谢地。&lt;div class=timeline&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-s&#34;&gt;P.S&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;2015-10-02 可以尝试 twitter fabric 团队出的 &lt;a href=&#34;https://github.com/twitter-fabric/velocity-react&#34;&gt;velocity-react&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2015-10-11 &lt;a href=&#34;http://facebook.github.io/react/blog/2015/10/07/react-v0.14.html&#34;&gt;react.js 0.14 正式版本&lt;/a&gt;已经发布，其中动画部分说明如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;To improve reliability, CSSTransitionGroup will no longer listen to transition events. Instead, you should specify transition durations manually using props such as transitionEnterTimeout={500}.&lt;/div&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>React.js 测试与重构</title>
      <link>https://www.zfanw.com/blog/react-js-test-and-refactor.html</link>
      <pubDate>Mon, 21 Sep 2015 23:07:32 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/react-js-test-and-refactor.html</guid>
      <description>&lt;p&gt;我有时在给 react.js 组件写测试时，总是想发笑，因为，好像都是在测试些显然的东西，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expect(loading.type).toBe(&#39;div&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我说，见鬼了，为什么我要 &lt;code&gt;expect&lt;/code&gt; 它的 type 是 &lt;code&gt;div&lt;/code&gt;？其它的就不行吗？比如 &lt;code&gt;span&lt;/code&gt;？老实说，它到底是 block 元素还是 inline 元素又有什么关系，反正有 CSS 规则可以控制。&lt;/p&gt;

&lt;p&gt;但我看 react.js 官方的测试说明里经常出现这样的语句，心想无害，不妨也先写上，也许哪天就突然明白了。&lt;/p&gt;

&lt;p&gt;但至今为止，我还是没有明白。&lt;/p&gt;

&lt;p&gt;只是这并不妨碍我继续热衷给组件写测试。&lt;/p&gt;

&lt;p&gt;因为我发现，组件的代码，与测试的代码，有一种正比关系：如果组件的代码太复杂，那么测试的代码就会非常恶心，比如有一次，我写出这样的测试代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expect(loading.props.children[0].props.children.type).toBe(&#39;span&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果再要测试 &lt;code&gt;click&lt;/code&gt; 事件，则简直想把电脑扔出窗外 &amp;#8211; 22 层。&lt;/p&gt;

&lt;p&gt;我马上醒悟，这可能就是所谓的 &lt;a href=&#34;https://en.wikipedia.org/wiki/Code_smell&#34;&gt;code smell&lt;/a&gt;，我的 react 组件需要重构了。&lt;/p&gt;

&lt;p&gt;我觉得这是 react.js 可爱的地方，它竟然让人生出一种不断解构组件的冲动 &amp;#8211; 有人会说我现在拿 react.js 当锤子，看见什么都当钉子。&lt;/p&gt;

&lt;p&gt;我承认，我现在是有这么种倾向。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>react.js 里测试 flux 架构的 store</title>
      <link>https://www.zfanw.com/blog/react-js-flux-test-store.html</link>
      <pubDate>Mon, 21 Sep 2015 12:55:26 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/react-js-flux-test-store.html</guid>
      <description>

&lt;p&gt;在 &lt;a href=&#34;https://facebook.github.io/flux/&#34;&gt;flux 架构&lt;/a&gt;​的 react.js 项目里，我写过 component 的测试，略为无趣；但 store 的测试则相对有趣多了。&lt;/p&gt;

&lt;p&gt;​想想，一个 action 分发后，store 就会相应做出变化，就好像你跟喜欢的人​​表白，保证能得到 yes 的回应似的 &amp;#8211; 让人欣喜。&lt;/p&gt;

&lt;p&gt;我们要用到的测试框架不是 &lt;a href=&#34;http://mochajs.org/&#34;&gt;Mocha&lt;/a&gt;，不是 &lt;a href=&#34;http://jasmine.github.io/&#34;&gt;Jasmine&lt;/a&gt;，而是 facebook 出品的基于 Jasmine 的 &lt;a href=&#34;https://github.com/facebook/jest&#34;&gt;jest&lt;/a&gt;，据 react.js 官方说，他们都用这个测试，不过我敢保证，你一定会遇上各种问题。&lt;/p&gt;

&lt;p&gt;且把这些担忧放到一边，来看一个简单的 &lt;a href=&#34;https://www.zfanw.com/react/demo-store-test/&#34;&gt;react.js 项目&lt;/a&gt;，源码托管在 &lt;a href=&#34;https://github.com/chenxsan/demo-jest-test-flux-store/blob/master/__tests__/TodoStore.test.js&#34;&gt;github&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;它只有一个输入框，&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;输入内容并回车&lt;/li&gt;
&lt;li&gt;触发一个 action&lt;/li&gt;
&lt;li&gt;这个 action 继而触发了 store 里的回调&lt;/li&gt;
&lt;li&gt;回调修改了 store 中的 model 数据&lt;/li&gt;
&lt;li&gt;store 射出事件&lt;/li&gt;
&lt;li&gt;监听 store 的 view 重新读取 store 中的数据、设置 state、重新 render 组件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这是 flux 原始实现的整个流程。&lt;/p&gt;

&lt;p&gt;因为 store 中的操作都是同步的，所以测试就非常便捷了。&lt;/p&gt;

&lt;p&gt;但使用 jest 有几个注意事项：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;最好使用 node.js 4.x.x&lt;/li&gt;
&lt;li&gt;如果你要用 es6 写法，需要使用 &lt;a href=&#34;https://github.com/babel/babel-jest&#34;&gt;babel-jest&lt;/a&gt; 一类预处理器&lt;/li&gt;
&lt;li&gt;如果用 es6 写法，要测试的 store 不能使用 &lt;code&gt;import&lt;/code&gt;，而必须使用 &lt;code&gt;require&lt;/code&gt;，因为 &lt;code&gt;import&lt;/code&gt; &lt;a href=&#34;https://github.com/babel/babel-jest/issues/16#issuecomment-104063719&#34;&gt;会被置前&lt;/a&gt;，导致 &lt;code&gt;jest.dontMock&lt;/code&gt; 失效&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;来看测试代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jest.dontMock(&#39;object-assign&#39;)
jest.dontMock(&#39;../src/stores/Todo&#39;)

describe(&#39;TodoStore&#39;, () =&amp;gt; {
  let AppDispatcher
  let TodoStore
  let callback

  // mock actions
  let actionNewTodo = {
    type: &#39;NEW_TODO&#39;,
    todo: &#39;hello world&#39;
  }

  beforeEach(() =&amp;gt; {
    AppDispatcher = require(&#39;../src/dispatcher/AppDispatcher&#39;)
    TodoStore = require(&#39;../src/stores/Todo&#39;)
    callback = AppDispatcher.register.mock.calls[0][0]
  })

  it(&#39;registers a callback with the dispatcher&#39;, () =&amp;gt; {
    expect(AppDispatcher.register.mock.calls.length).toBe(1)
  })

  it(&#39;初始化时为空&#39;, () =&amp;gt; {
    expect(TodoStore.getTodos()).toEqual([])
  })

  it(&#39;创建一个新的 todo&#39;, () =&amp;gt; {
    callback(actionNewTodo)
    expect(TodoStore.getTodos().length).toBe(1)
    expect(TodoStore.getTodos()[0]).toEqual(&#39;hello world&#39;)
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;callback = AppDispatcher.register.mock.calls[0][0]&lt;/code&gt; 是一个黑魔法，它能够执行我们的 action，而 store 将会相应地变化，就如上面的代码中：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;初始化时 &lt;code&gt;TodoStore.getTodos()&lt;/code&gt; 返回一个空数组&lt;/li&gt;
&lt;li&gt;在执行 &lt;code&gt;callback(actionNewTodo)&lt;/code&gt; 后，TodoStore 里插入了 &lt;code&gt;&#39;hello world&#39;&lt;/code&gt;，我们就能预计它的长度为 1，且第一条数据是 &lt;code&gt;&#39;hello world&#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在命令行下跑 &lt;code&gt;npm test&lt;/code&gt;，就能看到 &amp;#8220;1 test passed&amp;#8221; 的字眼了。&lt;/p&gt;

&lt;p&gt;真是让人感动：我们前端终于有机会写单元测试，并且还十分轻松。&lt;/p&gt;

&lt;h2 id=&#34;扩展阅读&#34;&gt;扩展阅读&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://facebook.github.io/flux/docs/testing-flux-applications.html&#34;&gt;Flux | Application Architecture for Building User Interfaces&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>React.js Flux 概念</title>
      <link>https://www.zfanw.com/blog/react-js-flux.html</link>
      <pubDate>Sat, 15 Aug 2015 11:04:50 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/react-js-flux.html</guid>
      <description>&lt;p&gt;假设一个最简单的 todo 应用，它只有添加 todo 的功能：&lt;div class=demo&gt; &lt;div id=main&gt;&lt;/div&gt; &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;则应用 &lt;a href=&#34;https://facebook.github.io/flux/docs/overview.html&#34;&gt;flux 架构&lt;/a&gt;的话，整个过程可以做如下描述：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Todo 组件首先从 store 中读入所有的 todos 数据，并赋给 &lt;code&gt;state&lt;/code&gt;，&lt;code&gt;render&lt;/code&gt; 方法根据 &lt;code&gt;state&lt;/code&gt; 的值渲染组件&lt;/li&gt;
&lt;li&gt;Todo 组件在 &lt;code&gt;componentDidMount&lt;/code&gt; 中监听 store 中的数据变化，并传入一个回调，回调执行时，会重新设置组件的 &lt;code&gt;state&lt;/code&gt;；另外我们还在 &lt;code&gt;componentWillUnmount&lt;/code&gt; 中解除监听&lt;/li&gt;
&lt;li&gt;Todo 组件中，&lt;code&gt;新增&lt;/code&gt; 按键触发了 &lt;code&gt;ADD_TODO&lt;/code&gt; 的动作（action）&lt;/li&gt;
&lt;li&gt;store 中，监听 &lt;code&gt;ADD_TODO&lt;/code&gt; 动作的回调接收到 &lt;code&gt;ADD_TODO&lt;/code&gt; 的动作而执行，改变了 store 中 todos 数据，并 emit 出 &lt;code&gt;CHANGE&lt;/code&gt; 事件&lt;/li&gt;
&lt;li&gt;Todo 组件监听到 store 数据变化，于是执行了重新设置组件 &lt;code&gt;state&lt;/code&gt; 值的回调。因为 &lt;code&gt;state&lt;/code&gt; 变化，于是组件又重新渲染&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在 flux 的设计中，数据是单向流转的。从我们人脑角度说，非常容易理解。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>React.js 测试</title>
      <link>https://www.zfanw.com/blog/react-js-test.html</link>
      <pubDate>Thu, 30 Jul 2015 14:40:30 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/react-js-test.html</guid>
      <description>&lt;p&gt;你写了一个 React.js 的组件，现在打算给组件写测试代码，怎么写？&lt;/p&gt;

&lt;p&gt;react.js 官方提供了一个 &lt;a href=&#34;https://facebook.github.io/react/docs/test-utils.html&#34;&gt;Test Utilities&lt;/a&gt;，有两种用法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;渲染到 DOM 后再测试 &amp;#8211; &lt;code&gt;renderIntoDocument&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;只是生成组件的一个实例，然后对测试该实践 &amp;#8211; 即文档中所说的 Shallow rendering&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里介绍第二种用法，全部测试代码见我 &lt;a href=&#34;https://github.com/chenxsan/react-date-picker-cs/blob/master/test/week.js&#34; title=&#34;打开 github 库&#34;&gt;github 上的 react 日期组件库&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;用到的工具有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://mochajs.org/&#34; title=&#34;打开 mocha 首页&#34;&gt;mocha&lt;/a&gt; &amp;#8211; 测试框架&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://chaijs.com/&#34; title=&#34;打开 chaijs 首页&#34;&gt;Chai&lt;/a&gt; &amp;#8211; 断言库&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://babeljs.io/docs/setup/#mocha&#34; title=&#34;如何在 mocha 框架中使用 babelJS&#34;&gt;babeljs&lt;/a&gt; &amp;#8211; 用于编译 jsx 文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以下测试代码经常简化，并加上注释说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 导入 React，这个 React 附带 addons
import React from &#39;react/addons&#39;; 

// 从 `chai` 包中导入 `expect`
import {expect} from &#39;chai&#39;; 

// 导入要测试的 react 组件
import Week from &#39;../src/week&#39;; 

describe(&#39;Week component&#39;, function() {
    let {TestUtils} = React.addons; // ES6 写法
    let shallowRenderer = TestUtils.createRenderer();

    // 使用 react 的 测试方法渲染 react 组件
    shallowRenderer.render(&amp;lt;Week days={[undefined, undefined, 1, 2, 3, 4, 5]} selectDay={function(){}} highlight={true} day={1}/&amp;gt;);
    let week;
    before(&#39;return Week component&#39;, () =&amp;gt; {

        // 从渲染的组件中返回结果
        week = shallowRenderer.getRenderOutput();

        // 你可以通过 console.log(week) 来查看 week 对象的结构
    });

    // 以下是测试
    it(&#39;should have tr as container&#39;, () =&amp;gt; {
        expect(week.type).to.equal(&#39;tr&#39;);
    });
    it(&#39;should have 7 td children&#39;, () =&amp;gt; {
        expect(week.props.children.length).to.equal(7);
    });
    // ...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你对写测试的必要性不敢确定 &amp;#8211; 我知道绝大部分前端开发都不写测试的，可以看看这一篇&lt;a href=&#34;http://www.onjava.com/pub/a/onjava/2003/04/02/javaxpckbk.html&#34;&gt;单元测试的十二个理由&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>模块化 React.js CSS</title>
      <link>https://www.zfanw.com/blog/react-js-modular-css.html</link>
      <pubDate>Tue, 09 Jun 2015 09:22:51 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/react-js-modular-css.html</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://facebook.github.io/react/&#34; title=&#34;react.js 官网&#34;&gt;React.js&lt;/a&gt; 的法国开发者 Christopher Chedeau &lt;a href=&#34;https://speakerdeck.com/vjeux/react-css-in-js&#34; title=&#34;演示稿&#34;&gt;分享过一期 react css in js&lt;/a&gt;，里面罗列他们如何解决 CSS 中的七个难题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CSS 天然的全局命名空间导致的命名冲突&lt;/li&gt;
&lt;li&gt;依赖&lt;/li&gt;
&lt;li&gt;无用代码清理&lt;/li&gt;
&lt;li&gt;命名压缩，比如 &lt;code&gt;.button&lt;/code&gt; -&amp;gt; &lt;code&gt;.ifd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;共享规则&lt;/li&gt;
&lt;li&gt;不确定的解析&lt;/li&gt;
&lt;li&gt;代码分离&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;React 最后解决这些问题的方法是用 JavaScript 写 CSS 规则，并&lt;a href=&#34;https://facebook.github.io/react/tips/inline-styles.html&#34; title=&#34;react 官网的样式文档&#34;&gt;内联样式&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;但内联样式一样存在问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;:hover&lt;/code&gt;、&lt;code&gt;:active&lt;/code&gt; 这些伪类无法使用&lt;/li&gt;
&lt;li&gt;媒体查询无法使用&lt;/li&gt;
&lt;li&gt;样式代码也会出现大量重复&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;诚然我们有&lt;a href=&#34;http://projects.formidablelabs.com/radium/&#34; title=&#34;radium 用法&#34;&gt;各种&lt;/a&gt; &lt;a href=&#34;https://github.com/js-next/react-style&#34; title=&#34;react-style 库&#34;&gt;workarounds&lt;/a&gt; 解决伪类、媒体查询等问题，但我有些担心它们的可用性、可维护性 &amp;#8211; 说到底，它们只是 workaround。&lt;/p&gt;

&lt;p&gt;还是回到 CSS 命名约定上。&lt;/p&gt;

&lt;p&gt;Google 工程师 &lt;a href=&#34;http://philipwalton.com/&#34; title=&#34;Philip Walton 个人站点&#34;&gt;Philip Walton&lt;/a&gt; 一直推荐 BEM，因为 BEM 可以很好地解决我们的 CSS 模块化问题，在 BEM 的定义里，我们可以把模块样式写在&lt;a href=&#34;https://en.bem.info/method/filesystem/&#34; title=&#34;BEM 中文件系统的使用&#34;&gt;以模块名命名的 CSS 文件&lt;/a&gt;中，注意，我们的操作系统不允许同一目录下存在同名 CSS 文件，于是我们就巧妙地绕过了 CSS 命名冲突的问题 &amp;#8211; 我承认，项目庞大的话，后面可能出现「行者孙、孙行者、者行孙」这样的奇怪命名。把 BEM 的这个思路应用到 React 上，则我们解决了模块化问题，也不会碰上 React 内联样式里伪类、媒体查询无法使用的问题。&lt;/p&gt;

&lt;p&gt;但是，如果把 CSS 文件分散到各个 CSS 文件中，我们就会碰上合并、打包 CSS 的问题。不过 BEM 是成套的，我们最常说及的只是它的命名约定，围绕命名约定，它还提供&lt;a href=&#34;https://en.bem.info/tools/bem/bem-tools/&#34;&gt;整套的工具&lt;/a&gt;。又或者，如果你跟我一样，也在使用 &lt;a href=&#34;http://www.zfanw.com/blog/tag/jspm&#34; title=&#34;本博客 jspm 相关内容&#34;&gt;jspm&lt;/a&gt;，则它已经可以解决 CSS 的合并、打包问题。&lt;/p&gt;

&lt;p&gt;比如我的一个业余项目，样式表结构如下：&lt;/p&gt;

&lt;p&gt;[resp_image id=&amp;#8217;16505&amp;#8242; caption=&amp;#8221; ]&lt;/p&gt;

&lt;p&gt;在执行 &lt;code&gt;jspm bundle-sfx script/app --minify&lt;/code&gt; 命令后，所有 CSS 文件就被打包到一个 build.css 中了。&lt;/p&gt;

&lt;p&gt;当然，使用命名规范并不能解决前面罗列的全部问题。技术常常是一种取舍，世间并没有银子弹。&lt;/p&gt;

&lt;div class=&#39;timeline&#39;&gt;
  &lt;h2&gt;
    修订历史
  &lt;/h2&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;span itemprop=&#39;dateModified&#39;&gt;2015.06.10 今天恰巧看到一篇&lt;a href=&#34;http://keithjgrant.com/posts/against-css-in-js.html&#34; title=&#34;打开文章链接&#34;&gt;反对 React 的 CSS 用法的文章&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>