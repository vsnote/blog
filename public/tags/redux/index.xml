<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Redux on 陈三</title>
    <link>https://www.zfanw.com/blog/tags/redux/</link>
    <description>Recent content in Redux on 陈三</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Fri, 17 Jun 2016 08:15:47 +0000</lastBuildDate>
    <atom:link href="https://www.zfanw.com/blog/tags/redux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>一个 react-native 下使用 redux 的错误</title>
      <link>https://www.zfanw.com/blog/react-native-redux-expected-a-component-class-got-object-object.html</link>
      <pubDate>Fri, 17 Jun 2016 08:15:47 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/react-native-redux-expected-a-component-class-got-object-object.html</guid>
      <description>&lt;p&gt;我在 react-native 项目里写的 &lt;code&gt;index.ios.js&lt;/code&gt; 文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import React from &#39;react&#39;
import { AppRegistry } from &#39;react-native&#39;
import rn from &#39;./src/app&#39;
import { Provider } from &#39;react-redux&#39;
import configureStore from &#39;./src/store/configureStore&#39;
const store = configureStore()
const App = () =&amp;gt; {
  return (
    &amp;lt;Provider store={store}&amp;gt;
      &amp;lt;rn /&amp;gt;
    &amp;lt;/Provider&amp;gt;
    )
}
AppRegistry.registerComponent(&#39;rn&#39;, () =&amp;gt; App)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行时一直报告这个错误：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Expected a component class, got [object Object].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;App&lt;/code&gt; 当然是一个 Component，问题出在哪？&lt;/p&gt;

&lt;p&gt;问题出在 &lt;code&gt;AppRegistry.registerComponent&lt;/code&gt; 注册的组件名也叫 &lt;code&gt;rn&lt;/code&gt;，而我在前头 &lt;code&gt;import&lt;/code&gt; 了同样的一个 &lt;code&gt;rn&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;修改如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import React from &#39;react&#39;
import { AppRegistry } from &#39;react-native&#39;
import Root from &#39;./src/app&#39;
import { Provider } from &#39;react-redux&#39;
import configureStore from &#39;./src/store/configureStore&#39;
const store = configureStore()
const App = () =&amp;gt; {
  return (
    &amp;lt;Provider store={store}&amp;gt;
      &amp;lt;Root /&amp;gt;
    &amp;lt;/Provider&amp;gt;
    )
}
AppRegistry.registerComponent(&#39;rn&#39;, () =&amp;gt; App)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就不再有问题了。&lt;/p&gt;

&lt;p&gt;一个非常简单却很容易忽略的错误。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>redux-saga 回调中执行 put</title>
      <link>https://www.zfanw.com/blog/redux-saga-put-in-callback.html</link>
      <pubDate>Sat, 11 Jun 2016 08:05:11 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/redux-saga-put-in-callback.html</guid>
      <description>&lt;p&gt;在 &lt;a href=&#34;https://github.com/yelouafi/redux-saga&#34;&gt;redux-saga&lt;/a&gt; 下，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;postWithLoadingEffect(API.user, user).then(
    (response) =&amp;gt; {
      console.log(response)
      // yield put(userActions.setCurrentUser(response.data))
    }
  ).catch(
    (error) =&amp;gt; {
      console.error(error)
    }
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;yield put&lt;/code&gt; 放在回调中是不会执行的，因为回调函数并不是 generator 函数。&lt;/p&gt;

&lt;p&gt;但这种需求在实际代码里会经常出现。我们可以绕个圈子实现它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  try {
    let response = yield call(postWithLoadingEffect, API.user, user)
    if (response) {
      console.log(response)
      window.localStorage.setItem(&#39;authToken&#39;, response.meta.jwt)
      yield put(userActions.setCurrentUser(response.data))
    }
  } catch (error) {
    console.error(error)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://yelouafi.github.io/redux-saga/docs/api/index.html#callfn-args&#34;&gt;call&lt;/a&gt; 是 redux-saga 提供的一个 effect，它会执行传递给它的函数。这样我们就取得了结果，可以正常使用 &lt;code&gt;yield put&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;但很多时候，我觉得在 saga 中直接使用 &lt;code&gt;dispatch&lt;/code&gt; 会更方便，只是这样 redux-saga 的好处便又丢了 &amp;#8211; 不如回去写 redux-thunk。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>redux.js 的盛行</title>
      <link>https://www.zfanw.com/blog/redux-js-prevail.html</link>
      <pubDate>Wed, 01 Jun 2016 02:35:36 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/redux-js-prevail.html</guid>
      <description>&lt;p&gt;在 react.js 里，如果把一个组件写在另一个组件的 &lt;code&gt;render&lt;/code&gt; 方法里，则其它组件要用它的话，我们又要重复一遍代码。所以我们要抽取它，独立成一个组件。可是，这时它的 &lt;code&gt;state&lt;/code&gt; 应该放在哪里？&lt;/p&gt;

&lt;p&gt;如果我们把 &lt;code&gt;state&lt;/code&gt; 放在组件内部，则父组件有读取子组件数据的需求时，父组件内部就要创建一个变量，还要提供给子组件一个回调，这样，同样的 &lt;code&gt;state&lt;/code&gt; 我们会在父、子两个地方实现，则不如 &lt;code&gt;state&lt;/code&gt; 只定义在父组件中，通过 &lt;code&gt;props&lt;/code&gt; 传递给子组件，这样，子组件的功能就比较单一，便于复用。&lt;/p&gt;

&lt;p&gt;但是，又有一个新的问题产生。举一个 Email 组件来说，它可能在登录表单组件里使用，也可能在注册表单组件里使用，这两个父组件的逻辑是不一样的，无法复用，而它们在使用 Email 组件时，却都需要提供给 Email 组件一个变量及一个回调函数 &amp;#8211; 它们在两个父组件中显然又是重复的。&lt;/p&gt;

&lt;p&gt;比如我的一个使用 &lt;a href=&#34;https://github.com/mobxjs/mobx&#34;&gt;mobx&lt;/a&gt; 的注册组件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import React, { Component } from &#39;react&#39;
import { observable, action, computed } from &#39;mobx&#39;
import Email from &#39;../common/Email&#39;

@observer
class Register extends Component {
  @observable email = &#39;&#39;
  @computed get emailError () {
    if (this.email.trim() === &#39;&#39;) {
      return &#39;请填写邮箱地址&#39;
    }
    if (!emailRegExp.test(this.email.trim())) {
      return &#39;请填写正确的邮箱地址&#39;
    }
    return &#39;&#39;
  }
  render () {
    return (
      &amp;lt;div&amp;gt;
          &amp;lt;Email email={this.email}
            changeEmail={this.changeEmail}
            emailError={this.emailError}
            /&amp;gt;
      &amp;lt;/div&amp;gt;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在登录组件中，几乎一模一样的代码，我又要重复一遍。&lt;/p&gt;

&lt;p&gt;Don&amp;#8217;t repeat yourself 说起来当然是简单，但做起来并不容易。就说我们上面所做的演进，目的是满足需求的同时消除重复，但结果我们只是把 repeat 从一个地方迁移到了另一个地方。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://redux.js.org/index.html&#34;&gt;Redux&lt;/a&gt; 能解决我们的问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将父组件中重复的变量存储到 store 中&lt;/li&gt;
&lt;li&gt;回调函数拆为 reducer + action&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样，我们就不必在多个父组件里重复变量及回调函数。但是，因为我们把变量存储在 store 里，把回调函数拆为 reducer + action，则我们在使用时，就又多了一个读取过程，在 redux.js 里，这通过 &lt;a href=&#34;https://github.com/reactjs/react-redux/blob/master/docs/api.md#api&#34;&gt;react-redux&lt;/a&gt; 实现。&lt;/p&gt;

&lt;p&gt;当然，像 redux 这样提取父组件中重复变量然后复用的做法并不能满足所有需求。很多时候，我们确实需要两份数据，这时，redux &lt;a href=&#34;https://github.com/reactjs/redux/issues/822#issuecomment-186614362&#34;&gt;也没有&lt;/a&gt;好的&lt;a href=&#34;https://github.com/reactjs/redux/issues/897#issuecomment-148233789&#34;&gt;解决办法&lt;/a&gt;，因为 action 没法复用，reducer 也没法复用。&lt;/p&gt;

&lt;p&gt;在 redux 的定义里，组件有两种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Container component&lt;/li&gt;
&lt;li&gt;Presentational component&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面的例子里，Email 组件是 Presentational component，要做到它的复用十分容易，而登录或注册组件则属于 Container component，它们的复用性就非常低，代码上的重复也很难避免 &amp;#8211; 目前我还没看到较好的解决办法。&lt;/p&gt;

&lt;p&gt;如果你有，欢迎留言：）&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>