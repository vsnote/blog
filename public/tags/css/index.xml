<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Css on 陈三</title>
    <link>https://www.zfanw.com/blog/tags/css/</link>
    <description>Recent content in Css on 陈三</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 19 Sep 2015 01:36:05 +0000</lastBuildDate>
    <atom:link href="https://www.zfanw.com/blog/tags/css/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>失控的 CSS</title>
      <link>https://www.zfanw.com/blog/unpredict-css.html</link>
      <pubDate>Sat, 19 Sep 2015 01:36:05 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/unpredict-css.html</guid>
      <description>

&lt;p&gt;我觉得很多人对 CSS 太过轻视，以至于完全不知道，全局 CSS 的危险。&lt;/p&gt;

&lt;p&gt;举个例子，A 君在 CSS 中加了一个规则如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;strong { font-weight: 700; font-size: 17px; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;B 君别有一个 strong，想扩展这个样式，于是，B 君可能这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.widget strong { color: red; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C 君可能也有个模块类名叫 &lt;code&gt;.widget&lt;/code&gt;，里面恰恰有个 strong 也想用这个样式，既然别人写好了，就用它吧。&lt;/p&gt;

&lt;p&gt;时间过了半个月，D 君接手这个项目，他想重构下 CSS 代码，&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;他不敢动 &lt;code&gt;strong&lt;/code&gt; 样式，因为他不知道，动了会发生什么&lt;/li&gt;
&lt;li&gt;他不敢动 &lt;code&gt;.widget strong&lt;/code&gt;，原因同上&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;全局的 CSS，没人敢删，唯一敢让人拍胸脯的，只能是不断地提高 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity&#34;&gt;css specificity&lt;/a&gt;，于是规则越来越多，也越来越长。&lt;/p&gt;

&lt;p&gt;再后来，A 君改了 &lt;code&gt;strong&lt;/code&gt; 的样式，B 君的样式坏了，C 君的也一样。&lt;/p&gt;

&lt;p&gt;我们的 CSS 规则，变得神秘莫测。&lt;/p&gt;

&lt;h2 id=&#34;解药&#34;&gt;解药&lt;/h2&gt;

&lt;p&gt;许多人觉得，SASS/SCSS、LESS、Stylus 这类 CSS 预处理器能解决全局 CSS 冲突问题，但是，只要它们生成的 css 类名还是 .xx-xx-xx 这样，上面提及的问题就只能减少，无法消灭，而况， CSS 预处理器本来是在解决 CSS 复用、继承等问题，至于迁移或减小了 CSS 样式冲突的风险，更像是意外所得。&lt;/p&gt;

&lt;p&gt;同样的问题，在 JavaScript 领域同样遭遇。&lt;/p&gt;

&lt;p&gt;一开始，大家都把变量名写在顶级作用域中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function a () {}
function b () {}
function c () {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但名称总是有限，冲突注定会出现，于是大家开始加命名空间：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var com = {}
var com.utils = {}
var com.utils.a = function () {}
var com.utils.b = function () {}
var com.utils.c = function () {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，这么写非常累人，于是又有各种变体。&lt;/p&gt;

&lt;p&gt;再之后我们有 &lt;a href=&#34;http://wiki.commonjs.org/wiki/CommonJS&#34;&gt;CommonJS&lt;/a&gt; 尝试定义 JavaScript 模块，但它更多是针对服务器端，于是又出现了 &lt;a href=&#34;http://requirejs.org/docs/whyamd.html&#34;&gt;AMD&lt;/a&gt;，专门针对浏览器环境，并且有各种辅助工具如 RequireJS 等。&lt;/p&gt;

&lt;p&gt;再后来，我们就迎来了 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&#34;&gt;ES6(ES2005) 模块&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;回顾 JavaScript 的模块化进程，我们就会发现，CSS 的模块化还停留在命名空间的阶段，哪怕是 &lt;a href=&#34;https://en.bem.info/method/naming-convention/&#34;&gt;BEM&lt;/a&gt; 这类命名约定。所以 JavaScript 在那个阶段会碰上的问题，CSS 一样会碰上，Sass 等预处理器，最多，只是让 CSS 拥有了 JavaScript 的那些可复用、可继承的特性罢了，并没有解决 CSS 真正模块化的问题。&lt;/p&gt;

&lt;p&gt;那么既然 JavaScript 已经走到 es6 模块化的阶段，CSS 为什么不能利用它的好处呢？这就是 &lt;a href=&#34;https://github.com/css-modules/css-modules&#34;&gt;css modules&lt;/a&gt; 所尝试的。&lt;/p&gt;

&lt;p&gt;它确切地&lt;a href=&#34;http://glenmaddern.com/articles/css-modules&#34;&gt;解决了 CSS 命名冲突的问题&lt;/a&gt;，让 CSS 同样变得可以预测。这样，你想删除某段模块化 CSS 代码时，可以放心删除，不用害怕可能破坏别人的样式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一段可以放心删除的 CSS&lt;/strong&gt;，我觉得这应该列入写 CSS 的标准。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JSPM 模块化 CSS</title>
      <link>https://www.zfanw.com/blog/jspm-css-modularize.html</link>
      <pubDate>Fri, 26 Jun 2015 12:35:17 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/jspm-css-modularize.html</guid>
      <description>&lt;div id=&#34;toc_container&#34; class=&#34;ml-l u-floatRight pure-u-1-1 pure-u-sm-2-5 toc_white no_bullets&#34;&gt;
  &lt;nav id=&#34;myaffix&#34;&gt;
  
  &lt;p class=&#34;toc-title&#34;&gt;
    目录
  &lt;/p&gt;
  
  &lt;ul class=&#34;toc-list nav&#34; role=&#34;menu&#34;&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#_jspm-loader-css&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;1&lt;/span&gt; 安装 jspm-loader-css&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#_CSS&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;2&lt;/span&gt; 模块 CSS 规则&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#_CSS-2&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;3&lt;/span&gt; 使用 CSS 模块&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;&lt;/nav&gt;
&lt;/div&gt;

&lt;div class=&#34;&#34;&gt;
  &lt;p&gt;
    之前我写过两篇模块化 CSS 的内容：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;a href=&#34;http://www.zfanw.com/blog/css-modularize.html&#34; title=&#34;模块化 CSS&#34;&gt;当下前端界在模块化 CSS 上的种种尝试&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;a href=&#34;http://www.zfanw.com/blog/react-js-modular-css.html&#34; title=&#34;react.js 模块化 css&#34;&gt;React.js 中内联 CSS 的问题&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    其中提到 &lt;a href=&#34;https://github.com/systemjs/plugin-css/issues/30&#34; title=&#34;github systemjs plugin-css&#34;&gt;jspm 在模块化 CSS 上的尝试&lt;/a&gt;。
  &lt;/p&gt;
  
  &lt;p&gt;
    现在，jspm 贡献者已经完成&lt;a href=&#34;https://github.com/geelen/jspm-loader-css&#34;&gt;这一功能&lt;/a&gt;，只待整合进 jspm。
  &lt;/p&gt;
  
  &lt;p&gt;
    来看看，jspm 里，要怎么使用这个功能。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;_jspm-loader-css&#34;&gt;安装 jspm-loader-css&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;hey_jspm-loader-css&#34; href=&#34;#_jspm-loader-css&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    在命令行下运行命令：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;jspm install css=npm:jspm-loader-css
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    jspm 默认使用的 CSS 加载器是 &lt;a href=&#34;https://github.com/systemjs/plugin-css&#34;&gt;plugin-css&lt;/a&gt;，上一条命令让 jspm-loader-css 取代 plugin-css，安装完成后，config.js 文件中 &lt;code&gt;System.config&lt;/code&gt; 里的 &lt;code&gt;map&lt;/code&gt; 下 &lt;code&gt;css&lt;/code&gt; 条目变成：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;&#34;css&#34;: &#34;npm:jspm-loader-css@0.1.4&#34;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;_CSS&#34;&gt;模块 CSS 规则&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;hey_CSS&#34; href=&#34;#_CSS&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    假设模块保存在 Components/book 目录下，
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;- Components
  - book
    + book.js
    + book.css
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    在 book.css 文件中，我们这样定义 CSS 模块：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;:local(.book) { color: red; }
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    &lt;code&gt;:local()&lt;/code&gt; 指定该样式类为局域样式。
  &lt;/p&gt;
  
  &lt;p&gt;
    当然，旧的写法仍然支持：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;.test { color: red; }
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这条规则表示 &lt;code&gt;.test&lt;/code&gt; 在全局环境中均可以使用。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;_CSS-2&#34;&gt;使用 CSS 模块&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;hey_CSS-2&#34; href=&#34;#_CSS-2&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    在 book.js 文件中：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;import styles from &#39;./book.css!css&#39;;
import React from &#39;react&#39;;

export default class extends React.Component {
    render() {
        return (
            &amp;lt;li className={styles.book}&amp;gt;

            &amp;lt;/li&amp;gt;
            );
    }
};
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这是一个 React.js 项目文件。
  &lt;/p&gt;
  
  &lt;p&gt;
    查看生成的页面，生成的 &lt;code&gt;li&lt;/code&gt; 的 class 类名是 &lt;code&gt;_Components_book_book__book&lt;/code&gt;。
  &lt;/p&gt;
  
  &lt;p&gt;
    如果嫌 CSS 中总写 &lt;code&gt;:local&lt;/code&gt; 麻烦，则可以使用另一个 CSS 加载器 &lt;a href=&#34;https://github.com/geelen/jspm-loader-css-modules&#34;&gt;jspm-loader-css-module&lt;/a&gt;，这个加载器默认所有的 CSS 类名是局域的，而非全局，使用它就不需要写 &lt;code&gt;:local&lt;/code&gt;。
  &lt;/p&gt;
  
  &lt;p&gt;
    &lt;strong&gt;最值得提及的一点是&lt;/strong&gt;，jspm-loader-css 默认启用 autoprefixer，实际上，因为 jspm-loader-css 依赖 &lt;a href=&#34;https://github.com/css-modules/css-modules-loader-core&#34;&gt;css-modules/css-modules-loader-core&lt;/a&gt;，而后者又是基于 &lt;a href=&#34;https://github.com/postcss/postcss&#34; title=&#34;postcss 库&#34;&gt;postcss&lt;/a&gt;，所以 postcss 的插件，我们都可以使用，&lt;a href=&#34;https://github.com/geelen/jspm-loader-css#customize-your-own-loader&#34; title=&#34;jspm-loader-css 配置 postcss 插件&#34;&gt;具体用法见文档说明&lt;/a&gt;。
  &lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>模块化 React.js CSS</title>
      <link>https://www.zfanw.com/blog/react-js-modular-css.html</link>
      <pubDate>Tue, 09 Jun 2015 09:22:51 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/react-js-modular-css.html</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://facebook.github.io/react/&#34; title=&#34;react.js 官网&#34;&gt;React.js&lt;/a&gt; 的法国开发者 Christopher Chedeau &lt;a href=&#34;https://speakerdeck.com/vjeux/react-css-in-js&#34; title=&#34;演示稿&#34;&gt;分享过一期 react css in js&lt;/a&gt;，里面罗列他们如何解决 CSS 中的七个难题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CSS 天然的全局命名空间导致的命名冲突&lt;/li&gt;
&lt;li&gt;依赖&lt;/li&gt;
&lt;li&gt;无用代码清理&lt;/li&gt;
&lt;li&gt;命名压缩，比如 &lt;code&gt;.button&lt;/code&gt; -&amp;gt; &lt;code&gt;.ifd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;共享规则&lt;/li&gt;
&lt;li&gt;不确定的解析&lt;/li&gt;
&lt;li&gt;代码分离&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;React 最后解决这些问题的方法是用 JavaScript 写 CSS 规则，并&lt;a href=&#34;https://facebook.github.io/react/tips/inline-styles.html&#34; title=&#34;react 官网的样式文档&#34;&gt;内联样式&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;但内联样式一样存在问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;:hover&lt;/code&gt;、&lt;code&gt;:active&lt;/code&gt; 这些伪类无法使用&lt;/li&gt;
&lt;li&gt;媒体查询无法使用&lt;/li&gt;
&lt;li&gt;样式代码也会出现大量重复&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;诚然我们有&lt;a href=&#34;http://projects.formidablelabs.com/radium/&#34; title=&#34;radium 用法&#34;&gt;各种&lt;/a&gt; &lt;a href=&#34;https://github.com/js-next/react-style&#34; title=&#34;react-style 库&#34;&gt;workarounds&lt;/a&gt; 解决伪类、媒体查询等问题，但我有些担心它们的可用性、可维护性 &amp;#8211; 说到底，它们只是 workaround。&lt;/p&gt;

&lt;p&gt;还是回到 CSS 命名约定上。&lt;/p&gt;

&lt;p&gt;Google 工程师 &lt;a href=&#34;http://philipwalton.com/&#34; title=&#34;Philip Walton 个人站点&#34;&gt;Philip Walton&lt;/a&gt; 一直推荐 BEM，因为 BEM 可以很好地解决我们的 CSS 模块化问题，在 BEM 的定义里，我们可以把模块样式写在&lt;a href=&#34;https://en.bem.info/method/filesystem/&#34; title=&#34;BEM 中文件系统的使用&#34;&gt;以模块名命名的 CSS 文件&lt;/a&gt;中，注意，我们的操作系统不允许同一目录下存在同名 CSS 文件，于是我们就巧妙地绕过了 CSS 命名冲突的问题 &amp;#8211; 我承认，项目庞大的话，后面可能出现「行者孙、孙行者、者行孙」这样的奇怪命名。把 BEM 的这个思路应用到 React 上，则我们解决了模块化问题，也不会碰上 React 内联样式里伪类、媒体查询无法使用的问题。&lt;/p&gt;

&lt;p&gt;但是，如果把 CSS 文件分散到各个 CSS 文件中，我们就会碰上合并、打包 CSS 的问题。不过 BEM 是成套的，我们最常说及的只是它的命名约定，围绕命名约定，它还提供&lt;a href=&#34;https://en.bem.info/tools/bem/bem-tools/&#34;&gt;整套的工具&lt;/a&gt;。又或者，如果你跟我一样，也在使用 &lt;a href=&#34;http://www.zfanw.com/blog/tag/jspm&#34; title=&#34;本博客 jspm 相关内容&#34;&gt;jspm&lt;/a&gt;，则它已经可以解决 CSS 的合并、打包问题。&lt;/p&gt;

&lt;p&gt;比如我的一个业余项目，样式表结构如下：&lt;/p&gt;

&lt;p&gt;[resp_image id=&amp;#8217;16505&amp;#8242; caption=&amp;#8221; ]&lt;/p&gt;

&lt;p&gt;在执行 &lt;code&gt;jspm bundle-sfx script/app --minify&lt;/code&gt; 命令后，所有 CSS 文件就被打包到一个 build.css 中了。&lt;/p&gt;

&lt;p&gt;当然，使用命名规范并不能解决前面罗列的全部问题。技术常常是一种取舍，世间并没有银子弹。&lt;/p&gt;

&lt;div class=&#39;timeline&#39;&gt;
  &lt;h2&gt;
    修订历史
  &lt;/h2&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;span itemprop=&#39;dateModified&#39;&gt;2015.06.10 今天恰巧看到一篇&lt;a href=&#34;http://keithjgrant.com/posts/against-css-in-js.html&#34; title=&#34;打开文章链接&#34;&gt;反对 React 的 CSS 用法的文章&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>模块化 CSS</title>
      <link>https://www.zfanw.com/blog/css-modularize.html</link>
      <pubDate>Mon, 01 Jun 2015 22:52:24 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/css-modularize.html</guid>
      <description>&lt;p&gt;CSS 是失控的。&lt;/p&gt;

&lt;p&gt;我们无妨把 CSS 想象成一头野马，我们所有的 CSS 命名规范上的尝试，无论是 &lt;a href=&#34;https://suitcss.github.io/&#34;&gt;SUITCSS&lt;/a&gt; 还是 &lt;a href=&#34;https://en.bem.info/&#34;&gt;BEM&lt;/a&gt;、&lt;a href=&#34;https://smacss.com/&#34;&gt;SMACSS&lt;/a&gt; 或是&lt;a href=&#34;http://www.zfanw.com/blog/css-worst-practice-complex-tag-selectors.html&#34;&gt;其它&lt;/a&gt;，都是打算给 CSS 套上缰绳，但我们只是往正确的方向走了一小步。命名规范只是一种约定，如果开发者有意或无意地忽视，哪怕只是代码中的一小部分，也会给以后埋下问题。&lt;/p&gt;

&lt;p&gt;所以我们可以看到，在 JavaScript 模块化非常成熟、各类工具齐全的今天，前端界开始往 CSS 模块化方向努力。&lt;/p&gt;

&lt;p&gt;我最早了解到的这方面努力是 &lt;a href=&#34;https://github.com/ebryn/ember-component-css&#34;&gt;ember-component-css&lt;/a&gt;，比如 &lt;code&gt;app/my-component/styles.css&lt;/code&gt; 文件内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp; {
  padding: 2px;
}
.urgent {
  color: red;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构建后的 CSS 如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.my-component-a34fba {
  padding: 2px;
}
.my-component-a34fba .urgent {
  color: red;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构建后的 CSS 作用域不再是全局，而是限定在&lt;strong&gt;这个&lt;/strong&gt;组件中，我们把 CSS 关进模块化的笼子。我们不用担心它的作用会渗透到其他代码，我们现在对我们的代码作用范围非常有信心 &amp;#8211; 它现在更像是狙击枪，而不是手榴弹。&lt;/p&gt;

&lt;p&gt;接下来，我在用 &lt;a href=&#34;http://www.zfanw.com/blog/jspm-systemjs.html&#34;&gt;JSPM&lt;/a&gt; 时也看到&lt;a href=&#34;https://github.com/systemjs/plugin-css/issues/30&#34;&gt;模块化 CSS 的努力&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;然后是 webpack 的 &lt;a href=&#34;https://github.com/webpack/css-loader/#module-mode&#34;&gt;CSS Module mode&lt;/a&gt;，开发这块功能的这位甚至宣布了&lt;a href=&#34;https://medium.com/seek-ui-engineering/the-end-of-global-css-90d2a4a06284&#34;&gt;全局 CSS 的终结&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;从上面的简单介绍中可以看到，CSS 的模块化依赖于特定工具，比如 ember-cli、webpack、jspm，如果我们不用这类工具的话，就基本无法对 CSS 做模块化，这样移植性似乎差了点，而且因为没有标准规范，所以它们的实施也不尽相同。可是这年头，不用这类工具辅助的代码，恐怕代码在可维护性、可扩展方面都会很糟糕吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CSS 最糟实践之复杂标签</title>
      <link>https://www.zfanw.com/blog/css-worst-practice-complex-tag-selectors.html</link>
      <pubDate>Mon, 18 May 2015 12:06:51 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/css-worst-practice-complex-tag-selectors.html</guid>
      <description>&lt;p&gt;我开始学 CSS 时，写过很多现在来看非常糟糕的 CSS。这是我想写这一个系列的直接原因：也许我们不知道要怎么做，但知道了什么不该做，就约略知道要怎么做了。&lt;/p&gt;

&lt;p&gt;这篇是 CSS 最糟实践系列的第一集，&lt;strong&gt;复杂标签选择器&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;假设 A 君写了这么一条规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;header ul li a { color: white; background: #333; text-decoration: none; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置 &lt;code&gt;header&lt;/code&gt; 元素里的 &lt;code&gt;ul&lt;/code&gt; 下的 &lt;code&gt;li&lt;/code&gt; 的 &lt;code&gt;a&lt;/code&gt; 链接前景色为白色，背景色为 &lt;code&gt;#333&lt;/code&gt;，无下划线。&lt;/p&gt;

&lt;p&gt;我们在未来可能碰上以下问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;HTML 结构变了，这条规则失效，需要修改。但是没人敢动这条规则，因为谁也不敢确认，这条规则有没有什么地方用到，所以我们为减少意外，又根据变化后的 HTML 结构加了一条 CSS 规则 &amp;#8211; CSS 文件越来越大。&lt;/li&gt;
&lt;li&gt;其他人写了一条特异性更高的规则，比如 &lt;code&gt;header .menu-item { color: blue; }&lt;/code&gt; &amp;#8211; 我们无法阻止这样的副作用发生，换句话说，我们的 CSS 规则变得不可预测 &amp;#8211; 它可能是前景白、背景黑，也可能压根不是这个样子，对，我们写的不是 CSS，是薛定锷的猫。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而如果我们这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.link {
  text-decoration: none;
}
.link--standout { color: white; background: #333; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在 HTML 中应用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;header&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a class=&#39;link link--standout&#39;&amp;gt;陈三的博客&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/header&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们就解决了前面的规则可能引起的问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;HTML 结构变化现在对我们的 CSS 规则没什么影响&lt;/li&gt;
&lt;li&gt;因为样式是通过 CSS 类应用的，所以我们根本不担心其他人的规则无端渗入&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;是的，CSS 的全称叫层叠样式表，但实际上，层叠的样式只是灾难 &amp;#8211; 除非你写的页面像我&lt;a href=&#34;http://www.zfanw.com&#34;&gt;首页&lt;/a&gt;这么简单。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTML 表单元素对齐</title>
      <link>https://www.zfanw.com/blog/html-form-element-align.html</link>
      <pubDate>Mon, 04 May 2015 05:14:58 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/html-form-element-align.html</guid>
      <description>&lt;p&gt;网页里，常见如下的表单代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
  &amp;lt;label for=&#39;email&#39;&amp;gt;邮箱地址：&amp;lt;/label&amp;gt;
  &amp;lt;input name=&#39;email&#39; type=&#39;text&#39;/&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;
  &amp;lt;label for=&#39;password&#39;&amp;gt;密码：&amp;lt;/label&amp;gt;
  &amp;lt;input name=&#39;password&#39; type=&#39;text&#39;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常，我们想达到下面这种排版效果：&lt;/p&gt;

&lt;div class=&#39;u-textRight&#39;&gt;
  &lt;label for=&#39;email&#39;&gt;邮箱地址：&lt;/label&gt; &lt;input name=&#39;email&#39; type=&#39;text&#39; /&gt;
&lt;/div&gt;

&lt;div class=&#39;u-textRight&#39;&gt;
  &lt;label for=&#39;password&#39;&gt;密码：&lt;/label&gt; &lt;input name=&#39;password&#39; type=&#39;text&#39; /&gt;
&lt;/div&gt;

&lt;p&gt;Bootstrap 里是这么写&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:15858-1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:15858-1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form class=&amp;quot;form-horizontal&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;
    &amp;lt;label for=&amp;quot;inputEmail3&amp;quot; class=&amp;quot;col-sm-2 control-label&amp;quot;&amp;gt;Email&amp;lt;/label&amp;gt;
    &amp;lt;div class=&amp;quot;col-sm-10&amp;quot;&amp;gt;
      &amp;lt;input type=&amp;quot;email&amp;quot; class=&amp;quot;form-control&amp;quot; id=&amp;quot;inputEmail3&amp;quot; placeholder=&amp;quot;Email&amp;quot;&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;
    &amp;lt;label for=&amp;quot;inputPassword3&amp;quot; class=&amp;quot;col-sm-2 control-label&amp;quot;&amp;gt;Password&amp;lt;/label&amp;gt;
    &amp;lt;div class=&amp;quot;col-sm-10&amp;quot;&amp;gt;
      &amp;lt;input type=&amp;quot;password&amp;quot; class=&amp;quot;form-control&amp;quot; id=&amp;quot;inputPassword3&amp;quot; placeholder=&amp;quot;Password&amp;quot;&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码中用到了 grid，然后两个 &lt;code&gt;label&lt;/code&gt; 设定同样的宽度，并且 &lt;code&gt;label&lt;/code&gt; 内的文本右对齐。&lt;/p&gt;

&lt;p&gt;但如果不考虑移动端的情况的话，我觉得可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;.u-textRight { text-align: right !important; }&amp;lt;/style&amp;gt;

&amp;lt;div class=&#39;u-textRight&#39;&amp;gt;
  &amp;lt;label for=&#39;email&#39;&amp;gt;邮箱地址：&amp;lt;/label&amp;gt;
  &amp;lt;input name=&#39;email&#39; type=&#39;text&#39;/&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&#39;u-textRight&#39;&amp;gt;
  &amp;lt;label for=&#39;password&#39;&amp;gt;密码：&amp;lt;/label&amp;gt;
  &amp;lt;input name=&#39;password&#39; type=&#39;text&#39;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;label&lt;/code&gt; 与 &lt;code&gt;input&lt;/code&gt; 都是 inline 元素，我在它们的包含块上设定右对齐，这样不需要给 label 指定宽度，代码也更简洁。&lt;/p&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;div class=&#39;u-textRight&#39;&gt;
  &lt;label for=&#39;email&#39;&gt;邮箱地址：&lt;/label&gt; &lt;input name=&#39;email&#39; type=&#39;text&#39; /&gt;
&lt;/div&gt;

&lt;div class=&#39;u-textRight&#39;&gt;
  &lt;label for=&#39;password&#39;&gt;密码：&lt;/label&gt; &lt;input name=&#39;password&#39; type=&#39;text&#39; /&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:15858-1&#34;&gt;&lt;a href=&#34;http://getbootstrap.com/css/#forms-horizontal&#34;&gt;Bootstrap horizontal form&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:15858-1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>自定义input radio的样式</title>
      <link>https://www.zfanw.com/blog/input-radio-style.html</link>
      <pubDate>Tue, 12 Aug 2014 12:15:07 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/input-radio-style.html</guid>
      <description>&lt;p&gt;HTML的radio单选按钮，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;radio&amp;quot; value=&amp;quot;河西&amp;quot; name=&#39;flow&#39;&amp;gt;河西
&amp;lt;input type=&amp;quot;radio&amp;quot; value=&amp;quot;河东&amp;quot; name=&#39;flow&#39;&amp;gt;河东
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;样式大抵如下：&lt;/p&gt;

&lt;p&gt;&lt;input type=&#34;radio&#34; value=&#34;河西&#34; name=&#39;flow&#39; /&gt;河西 &lt;input type=&#34;radio&#34; value=&#34;河东&#34; name=&#39;flow&#39; /&gt;河东&lt;/p&gt;

&lt;p&gt;桌面端上不同浏览器看，上面的样式可能不一样；换到移动端上，通常也会有差异。&lt;/p&gt;

&lt;p&gt;那么我们如果想自定义radio的样式如何？&lt;/p&gt;

&lt;p&gt;比如下面（请在webkit内核下的浏览器下查看）这样：&lt;/p&gt;

&lt;div class=&#39;example&#39;&gt;
  &lt;input type=&#34;radio&#34; value=&#34;河西&#34; name=&#39;flow&#39; /&gt;河西 &lt;input type=&#34;radio&#34; value=&#34;河东&#34; name=&#39;flow&#39; /&gt;河东
&lt;/div&gt;

&lt;p&gt;这里用到一个非标准的CSS属性&lt;code&gt;-webkit-appearance&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:13303-1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:13303-1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，将其值设为&lt;code&gt;none&lt;/code&gt;，预先移除浏览器默认的样式，接着添加自定义样式，具体代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;input[type=&amp;quot;radio&amp;quot;]{
  -webkit-appearance: none;
  background: red;
  width: 16px;
  height: 16px;
  border-radius: 50%;
}
input[type=radio]:checked{
  background: orange;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为&lt;code&gt;appearance&lt;/code&gt;是非标准的属性，所以各个浏览器的实现并不一样，有些浏览器则根本没有该属性。不过如果只是兼容iOS与Android手机上的webkit内核浏览器，倒是无妨用上。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:13303-1&#34;&gt;&lt;a href=&#34;http://caniuse.com/#feat=css-appearance&#34;&gt;Can I use&amp;#8230; Support tables for HTML5, CSS3, etc&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:13303-1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>background-position 的百分比</title>
      <link>https://www.zfanw.com/blog/background-position-percentage.html</link>
      <pubDate>Mon, 02 Jun 2014 11:52:17 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/background-position-percentage.html</guid>
      <description>&lt;p&gt;平常使用 &lt;code&gt;background-position&lt;/code&gt;，一般是用固定值，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.hello {
  background-position: 50px 50px; // 背景图片左上角离包含块左上角距离为水平方向 50px，竖直方向 50px
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示意如下：&lt;/p&gt;

&lt;div class=&#34;hello&#34;&gt;
  &lt;p&gt;
    50&amp;#215;50的色块
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;居中背景图片的话，则常常用百分比：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.hello {
  background-position:50% 50%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这似乎理所当然。&lt;/p&gt;

&lt;p&gt;那如果上面的固定值 50px，我坚持要写成百分比如何？&lt;/p&gt;

&lt;p&gt;已知背景图片大小为 150&amp;#215;150，包含块大小为 200&amp;#215;200。&lt;/p&gt;

&lt;p&gt;答案是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.hello {
  background-position: 100% 100%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个值是这样计算的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;50/(200-150)*100% = 100%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为 &lt;code&gt;background-position&lt;/code&gt; 在使用百分比时，概念跟固定取值并不一样。&lt;/p&gt;

&lt;p&gt;举上面的示例说，如果设置 &lt;code&gt;background-postion:10% 30%;&lt;/code&gt;，则是背景图片水平方向 10% 位置的点与包含块水平方向 10% 位置的点重合。换算成固定取值的话：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(200-50)*10% = 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示意如下：&lt;/p&gt;

&lt;div class=&#34;hello2&#34;&gt;
  &lt;p&gt;
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;但如果我们使用负的百分比，则浏览器的处理方式又跟绝对值一样了，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.test {
  background-position: -10%, -50%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是让背景图片起点定位到包含块 (-10%, -50%) 的位置。&lt;/p&gt;

&lt;p&gt;这个概念不十分直观，所以没细究的话，很容易误解。&lt;/p&gt;

&lt;p&gt;附：&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/CSS/background-position&#34;&gt;background-position &amp;#8211; CSS | MDN&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sass</title>
      <link>https://www.zfanw.com/blog/sass.html</link>
      <pubDate>Mon, 07 Oct 2013 05:55:48 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/sass.html</guid>
      <description>&lt;div id=&#34;toc_container&#34; class=&#34;ml-l u-floatRight pure-u-1-1 pure-u-sm-2-5 toc_white no_bullets&#34;&gt;
  &lt;nav id=&#34;myaffix&#34;&gt;
  
  &lt;p class=&#34;toc-title&#34;&gt;
    目录
  &lt;/p&gt;
  
  &lt;ul class=&#34;toc-list nav&#34; role=&#34;menu&#34;&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#CSS&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;1&lt;/span&gt; CSS 类命名&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#Sass&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;2&lt;/span&gt; Sass 变量&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;3&lt;/span&gt; 扩展阅读&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;&lt;/nav&gt;
&lt;/div&gt;

&lt;div class=&#34;&#34;&gt;
  &lt;p&gt;
    现在为止，我还坚持一个看法，就是，如果我们对 CSS 模块化、&lt;a href=&#34;http://www.zfanw.com/blog/css-architecture.html&#34;&gt;架构&lt;/a&gt;等没有一个全局把握，那么，任何 CSS 预处理器，不管它是 LESS，还是 &lt;a href=&#34;http://sass-lang.com/&#34;&gt;Sass&lt;/a&gt; 或者 Stylus，带来的好处只会小于它们带来的坏处。
  &lt;/p&gt;
  
  &lt;p&gt;
    但我终于想写一篇关于 Sass 的内容。一来是上一篇写 &lt;a href=&#34;http://www.zfanw.com/blog/compass-sprite.html&#34;&gt;Compass 与 CSS 贴图定位&lt;/a&gt;时其实已经用到 Sass，二来自身对 CSS 架构有些了解，夸张地说，就是想试一下身手。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;CSS&#34;&gt;CSS 类命名&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyCSS&#34; href=&#34;#CSS&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    还是先来聊一下 CSS 类命名。
  &lt;/p&gt;
  
  &lt;p&gt;
    页面上有一 A 块，它的 margin-top 值为20px，从类的可复用性出发，我们可能这样给它命名：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;.mt-20 {
    margin-top:20px;
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    在 HTML 代码中应用到 A 块则是如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;&amp;lt;p id=&#34;A&#34; class=&#34;mt-20&#34;&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    假如 B、C、D 也一样的 margin-top 值，那么我们的 HTML 代码会出现如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;&amp;lt;p id=&#34;B&#34; class=&#34;mt-20&#34;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p id=&#34;C&#34; class=&#34;mt-20&#34;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p id=&#34;D&#34; class=&#34;mt-20&#34;&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    一旦数值20发生变化，比如说要微调成21,那么，上面的代码中，我们要改 CSS 文件中2处、HTML 文件中4处。显然，情况糟透了。
  &lt;/p&gt;
  
  &lt;p&gt;
    以前，我曾尝试过上述命名方法，并且见到有人鼓励这样的命名方式，但随后就发现问题不少。那么，怎样的命名方式会更合理？
  &lt;/p&gt;
  
  &lt;p&gt;
    从 font-size 的可能取值里我们可以得到启发：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;font-size: xx-small
font-size: x-small
font-size: small
font-size: medium
font-size: large
font-size: x-large
font-size: xx-large
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    是的，我们的 .mt-20 可以考虑命名成 .mt-large，这样我们就脱离了具体的数值，也让 CSS 类名更有语义。bootstrap 的&lt;a href=&#34;http://getbootstrap.com/css/#grid-options&#34;&gt;网格系统&lt;/a&gt;命名则是 .col-xs-、.col-sm-、.col-md-、.col-lg- 这样。更进一步缩减代码。Yahoo &lt;a href=&#34;https://github.com/chenxsan/HTML5Boilerplate/blob/master/css/helper.css&#34;&gt;走得更远&lt;/a&gt;，它的 CSS 里是这样写的：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;.mt-l {
    margin-top: 20px;
}
.mr-l {
    margin-right: 20px;
}
.mb-l {
    margin-bottom: 20px;
}
.ml-l {
    margin-left: 20px;
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这也是我现在采用的命名。(Yahoo 的页面里，其实有很多 &lt;a href=&#34;http://oocss.org/&#34;&gt;oocss&lt;/a&gt; 的影子，上面的命名只不过是一个体现。)
  &lt;/p&gt;
  
  &lt;p&gt;
    在拟定上述的命名方法后，再来说 Sass 在其中的应用。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;Sass&#34;&gt;Sass 变量&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heySass&#34; href=&#34;#Sass&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    在上面代码中，我们定义 large 值为20px，假如后期需要微调，比如降成19px，这下我们又要修改起码4处的值，对的，我们又在干重复的事情。代码一旦出现重复，就会容易出错。Sass 可以解决这个问题。
  &lt;/p&gt;
  
  &lt;p&gt;
    在 .scss 文件中，我们事先定义一个 $large 变量，然后在定义类时使用该变量：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;$large: 20px;

.mt-l{margin-top: $large;}
.mr-l{margin-right: $large;}
.mb-l{margin-bottom: $large;}
.ml-l{margin-left: $large;}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这样，后期 large 值出现变化，我们也只要修改一处。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i&#34;&gt;扩展阅读&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi&#34; href=&#34;#i&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;a href=&#34;http://ianstormtaylor.com/oocss-plus-sass-is-the-best-way-to-css/&#34;&gt;OOCSS + Sass = The best way to CSS&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Compass 与 CSS 贴图定位</title>
      <link>https://www.zfanw.com/blog/compass-sprite.html</link>
      <pubDate>Fri, 04 Oct 2013 14:01:29 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/compass-sprite.html</guid>
      <description>&lt;div id=&#34;toc_container&#34; class=&#34;ml-l u-floatRight pure-u-1-1 pure-u-sm-2-5 toc_white no_bullets&#34;&gt;
  &lt;nav id=&#34;myaffix&#34;&gt;
  
  &lt;p class=&#34;toc-title&#34;&gt;
    目录
  &lt;/p&gt;
  
  &lt;ul class=&#34;toc-list nav&#34; role=&#34;menu&#34;&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#_Ruby&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;1&lt;/span&gt; 安装 Ruby&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#_compass&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;2&lt;/span&gt; 安装 compass&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#_compass-2&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;3&lt;/span&gt; 配置 compass&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#_scss&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;4&lt;/span&gt; 书写 scss 文件&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;&lt;/nav&gt;
&lt;/div&gt;

&lt;div class=&#34;&#34;&gt;
  &lt;p&gt;
    在我的前端开发工作里，CSS 贴图定位占用的时间不少。首先要切出小图片，然后放置到 sprite 大图里，确定 x、y 位置，最后写到 CSS 规则里：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;body {
    background:url(../img/sprite.png) no-repeat -100px 0;
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    Photoshop 提供的确定 x、y 位置的方法并不高效，而况我还要在 CSS 文件里手写 x、y 值，完全是低效的体力劳动。后期如果还对 Sprite 做修改，那更让人头大。
  &lt;/p&gt;
  
  &lt;p&gt;
    Compass 提供了一个相对高效的&lt;a href=&#34;http://compass-style.org/help/tutorials/spriting/&#34;&gt;贴图定位方法&lt;/a&gt;，我们要做的，只是切出小图，给它们命名，然后统一保存到某文件夹下，配置好 Compass，然后写 sass 文件，再运行命令：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;compass watch
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    接着，Compass 自动生成贴图定位的类，我们在 HTML 代码中添加相应类名就好了。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;_Ruby&#34;&gt;安装 Ruby&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;hey_Ruby&#34; href=&#34;#_Ruby&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    compass 是一个 Ruby 包，所以我们需要事先安装 &lt;a href=&#34;https://www.ruby-lang.org/en/&#34;&gt;Ruby&lt;/a&gt;。最新版本的 Ruby 里已经包含 RubyGems，不需要另外安装。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;_compass&#34;&gt;安装 compass&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;hey_compass&#34; href=&#34;#_compass&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    打开命令行工具：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;gem install compass
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这个命令会同时安装 Compass 与 Sass。我们可以通过 &lt;code&gt;compass version&lt;/code&gt; 命令查看安装情况。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;_compass-2&#34;&gt;配置 compass&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;hey_compass-2&#34; href=&#34;#_compass-2&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    根据项目情况，全新创建的，还是已有项目，我们会有不同的&lt;a href=&#34;http://compass-style.org/install/&#34;&gt;配置命令&lt;/a&gt;。
  &lt;/p&gt;
  
  &lt;p&gt;
    比如我要在一个已有项目中配置：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;compass create --css-dir &#34;css&#34; --javascripts-dir &#34;js&#34; --images-dir &#34;img&#34;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    Compass 会自动生成一个 sass 文件夹。
  &lt;/p&gt;
  
  &lt;p&gt;
    在运行 &lt;code&gt;compass watch&lt;/code&gt; 命令后，sass 文件夹下的 .scss 文件会自动编译到 css 文件夹下。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;_scss&#34;&gt;书写 scss 文件&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;hey_scss&#34; href=&#34;#_scss&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    假定要应用贴图定位的图片全部放在 img/icon/ 目录下，总共有三张：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      upload.png
    &lt;/li&gt;
    &lt;li&gt;
      download.png
    &lt;/li&gt;
    &lt;li&gt;
      pause.png
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    则 sass 目录下，我们的 .scss 文件这样写：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;@import &#34;icon/*.png&#34;;
@include all-icon-sprites;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    &lt;strong&gt;注意&lt;/strong&gt;：scss 文件中的 &lt;strong&gt;icon&lt;/strong&gt; 是对应于 img 目录下的 &lt;strong&gt;icon&lt;/strong&gt; 目录名称的。
  &lt;/p&gt;
  
  &lt;p&gt;
    &lt;code&gt;compass watch&lt;/code&gt; 命令在 css 目录下编译出的 css 文件如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;/* line 58, icon/*.png */
.icon-sprite, .icon-download, .icon-pause, .icon-upload {
  background: url(&#39;/img/icon-seab081b7aa.png&#39;) no-repeat;
}

/* line 60, ../../../.rvm/gems/ruby-2.0.0-p247/gems/compass-0.12.2/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icon-download {
  background-position: 0 0;
}

/* line 60, ../../../.rvm/gems/ruby-2.0.0-p247/gems/compass-0.12.2/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icon-pause {
  background-position: 0 -256px;
}

/* line 60, ../../../.rvm/gems/ruby-2.0.0-p247/gems/compass-0.12.2/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icon-upload {
  background-position: 0 -512px;
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    另外，img 目录下多出一个 icon-xxxxxxx.png 的图片，这是 compass 自动组合生成的，不需要我们操心。
  &lt;/p&gt;
  
  &lt;p&gt;
    接下来，我们在 HTML 代码中引用上述类即可：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;&amp;lt;i class=&#34;icon-upload&#34;&amp;gt;&amp;lt;/i&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    如果我们要明确每个贴图的宽度、高度，只要在 scss 文件中的 &lt;code&gt;@include all-icon-sprites&lt;/code&gt; 后加个 &lt;code&gt;true&lt;/code&gt;：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;@include all-icon-sprites(true);
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    生成的 CSS 会变成如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;/* line 58, icon/*.png */
.icon-sprite, .icon-download, .icon-pause, .icon-upload {
  background: url(&#39;/img/icon-seab081b7aa.png&#39;) no-repeat;
}

/* line 60, ../../../.rvm/gems/ruby-2.0.0-p247/gems/compass-0.12.2/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icon-download {
  background-position: 0 0;
  height: 256px;
  width: 256px;
}

/* line 60, ../../../.rvm/gems/ruby-2.0.0-p247/gems/compass-0.12.2/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icon-pause {
  background-position: 0 -256px;
  height: 256px;
  width: 256px;
}

/* line 60, ../../../.rvm/gems/ruby-2.0.0-p247/gems/compass-0.12.2/frameworks/compass/stylesheets/compass/utilities/sprites/_base.scss */
.icon-upload {
  background-position: 0 -512px;
  height: 256px;
  width: 256px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Adobe Brackets 与 CSS DRY 原则</title>
      <link>https://www.zfanw.com/blog/adobe-brackets-css-dont-repeat-youself.html</link>
      <pubDate>Sun, 08 Sep 2013 11:17:28 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/adobe-brackets-css-dont-repeat-youself.html</guid>
      <description>&lt;div id=&#34;toc_container&#34; class=&#34;ml-l u-floatRight pure-u-1-1 pure-u-sm-2-5 toc_white no_bullets&#34;&gt;
  &lt;nav id=&#34;myaffix&#34;&gt;
  
  &lt;p class=&#34;toc-title&#34;&gt;
    目录
  &lt;/p&gt;
  
  &lt;ul class=&#34;toc-list nav&#34; role=&#34;menu&#34;&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;1&lt;/span&gt; 快速编辑&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-2&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;2&lt;/span&gt; 妙用&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;&lt;/nav&gt;
&lt;/div&gt;

&lt;div class=&#34;&#34;&gt;
  &lt;p&gt;
    在后端程序里，随处可见强调 &lt;a href=&#34;http://zh.wikipedia.org/wiki/一次且仅一次&#34;&gt;DRY&lt;/a&gt;(don&amp;#8217;t repeat youself) 原则，我想前端开发中也不应该例外。
  &lt;/p&gt;
  
  &lt;p&gt;
    一个样式类，在 CSS 文件中多处出现，就会造成后期修改的困难。谁也不能保证，我多处都做好修改。但如果我们只定义一次，就很容易确信，我们已经修改好了。
  &lt;/p&gt;
  
  &lt;p&gt;
    那么，我们又如何确定自己只定义了一次？
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i&#34;&gt;快速编辑&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi&#34; href=&#34;#i&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    Adobe Brackets 的 &lt;a href=&#34;https://github.com/adobe/brackets/wiki/How-to-Use-Brackets#quick-edit&#34;&gt;Quick Edit&lt;/a&gt;(&lt;strong&gt;快速编辑&lt;/strong&gt;样式) 工具可以很好地帮助解决这个问题。
  &lt;/p&gt;
  
  &lt;p&gt;
    在 Brackets 中，打开 HTML 文件，光标定位到类名位置，然后按 &lt;kbd&gt;Ctrl-E&lt;/kbd&gt; 快捷键，就会在当前 HTML 编辑窗口内调出快速样式编辑面板：
  &lt;/p&gt;
  
  &lt;p&gt;
    &lt;img src=&#34;http://www.zfanw.com/blog/wp-content/uploads/2013/09/adobe-brackets-quick-edit.jpg&#34; alt=&#34;adobe brackets 快速编辑&#34; width=&#34;700&#34; height=&#34;114&#34; class=&#34;alignnone size-full wp-image-10399&#34; srcset=&#34;https://www.zfanw.com/blog/wp-content/uploads/2013/09/adobe-brackets-quick-edit.jpg 700w, https://www.zfanw.com/blog/wp-content/uploads/2013/09/adobe-brackets-quick-edit-300x48.jpg 300w&#34; sizes=&#34;(max-width: 700px) 100vw, 700px&#34; /&gt;
  &lt;/p&gt;
  
  &lt;p&gt;
    面板分左右两列，左列显示样式规则，右列显示所有定义有该样式的 CSS 文件名称、代码位置。
  &lt;/p&gt;
  
  &lt;p&gt;
    比如上图中，我定义了一个 &lt;code&gt;.rom-comment-num&lt;/code&gt; 的类，该类出现在 main.css 样式文件中，并且出现了两次。当类出现在许多样式文件中，或者在一个样式文件中出现多处，我们就要认真考虑一下，我们是否正在违背 DRY 原则，正在给我们的后期维护制造困难。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-2&#34;&gt;妙用&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-2&#34; href=&#34;#i-2&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    上面我们已经知道快速编辑样式怎么用，这样，从中就能延展出一个不错的用处。
  &lt;/p&gt;
  
  &lt;p&gt;
    当我们给 CSS 类命名时，即便有一定的规范在，我们也会担心，这个命名是不是已经被定义过了？毕竟，页面一多，参与开发的人一多，谁也不好保证这种问题。这时按快捷键 &lt;kbd&gt;Ctrl-E&lt;/kbd&gt;，如果没能调出快速编辑面板，则该类名还没有被用过，我们可以放心使用。当然，Firebug 之类的网页调试工具也可以达到这种功能，但毕竟不如在编辑器中确认来得方便。
  &lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>CSS 修饰类</title>
      <link>https://www.zfanw.com/blog/css-style-modifier.html</link>
      <pubDate>Mon, 02 Sep 2013 13:53:03 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/css-style-modifier.html</guid>
      <description>&lt;p&gt;一个页面内容，如果它在结构上属于副标题，那么从语义上说，我们应该用 &lt;code&gt;&amp;lt;h2&amp;gt;&amp;lt;/h2&amp;gt;&lt;/code&gt; 标签对来包含它。可以想像，副标题的字体大小比正文要大，并且加粗。那么，在定义 CSS 样式时，我们可能是这样写的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;h2,
.h2 {
  font-size:18px;
  font-weight:700;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但很可惜，设计人员出于排版或其他想法，决定&lt;strong&gt;某些&lt;/strong&gt;副标题不加粗。&lt;/p&gt;

&lt;p&gt;因为 h2 标题加粗是存在共识的，所以我们上面写的基类(base class)并没有问题 &amp;#8211; 如果基类设定了副标题不加粗，那反而会给人造成困惑。&lt;/p&gt;

&lt;p&gt;基于基类，我们可以有两种解决办法，&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建一个 h2 变体样式类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.h2--fw-normal{
  font-weight:400;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后应用到元素中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h2 class=&amp;quot;h2 h2--fw-normal&amp;quot;&amp;gt;副标题&amp;lt;/h2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;又或者我们考虑添加一个专门设定 font-weight 的类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.fw-normal{
  font-weight:400;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再应用到元素中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h2 class=&amp;quot;h2 fw-normal&amp;quot;&amp;gt;副标题&amp;lt;/h2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;无论是第一种还是第二种方法，都能在 HTML 中起到辅助语义的作用，但第一种方法因为限定命名空间 h2，所以该类样式并不能应用到其他结构元素上，第二种方法则相反，可重用性很高。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript 与 HTML 元素状态</title>
      <link>https://www.zfanw.com/blog/javascript-and-html-element-state.html</link>
      <pubDate>Sat, 31 Aug 2013 15:56:40 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/javascript-and-html-element-state.html</guid>
      <description>&lt;p&gt;如果把 HTML 元素状态简单分为两种，显示和隐藏，那么，我们常常需要通过 JavaScript 控制它们。&lt;/p&gt;

&lt;p&gt;举 &lt;a href=&#34;http://www.zfanw.com/blog/jquery-plugin-tab.html&#34;&gt;jQuery 选项卡插件&lt;/a&gt; 来说，初始化时，我们只显示第一个选项卡对应内容块，隐藏其余内容块，这可以通过 JavaScript 实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(this).children(&#39;div:not(:first)&#39;).hide();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但我的插件中，添加了 &lt;code&gt;.is-hide&lt;/code&gt; 类来隐藏元素。之所以不用 JavaScript 控制，是因为我觉得，CSS 类应该在 HTML 代码中起到辅助语义的作用。在我们只阅读 HTML 代码时，看到一个叫 &lt;code&gt;.is-hide&lt;/code&gt; 的 CSS 类，马上可以明白，这一段元素是隐藏状态的。但如果用 JavaScript 来控制，情况就不一样。我们看 HTML 代码，元素应该是显示的，再看 CSS，元素应该是显示的，但前台却没显示，那只能认为是 JavaScript 干的 &amp;#8211; 这让事情变得不可预测。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;像上面我使用的 HTML 结构，可能后端开发看了会说，你这段代码结构怎么能有一个特例？这样我无法遍历输出呀。刻薄点说，我是不是也可以对设计人员说，你这些设计怎么能有一个特例，我无法抽象 CSS 模块类呀。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;我用过许多 jQuery 插件，它们都包揽太多工作。比如幻灯片插件，我们只要提供一个 HTML 基础骨架，它就能打包生成 Prev/Next 按钮，pager 等，我觉得这很糟糕，完全的黑箱操作，确实，这样能减少前端人员的一些工作，但对 CSS 结构或者 HTML 的可阅读性并没有帮助。所以我很欣赏 Bootstrap &lt;a href=&#34;http://getbootstrap.com/javascript/#carousel&#34;&gt;Carousel&lt;/a&gt; 插件的 HTML 结构，要求用户自己写，也就给了我们很大操作空间 &amp;#8211; 写得好还是坏，就是我们的问题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CSS 架构</title>
      <link>https://www.zfanw.com/blog/css-architecture.html</link>
      <pubDate>Thu, 22 Aug 2013 23:35:51 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/css-architecture.html</guid>
      <description>&lt;div id=&#34;toc_container&#34; class=&#34;ml-l u-floatRight pure-u-1-1 pure-u-sm-2-5 toc_white no_bullets&#34;&gt;
  &lt;nav id=&#34;myaffix&#34;&gt;
  
  &lt;p class=&#34;toc-title&#34;&gt;
    目录
  &lt;/p&gt;
  
  &lt;ul class=&#34;toc-list nav&#34; role=&#34;menu&#34;&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#_CSS&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;1&lt;/span&gt; 良好 CSS 架构的目标&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;2&lt;/span&gt; 常见的不良做法&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-2&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;3&lt;/span&gt; 原因&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-3&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;4&lt;/span&gt; 解决方法&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-4&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;5&lt;/span&gt; 最佳实践&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-5&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;6&lt;/span&gt; 工具&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-6&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;7&lt;/span&gt; 总结&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-7&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;8&lt;/span&gt; 翻译说明&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;&lt;/nav&gt;
&lt;/div&gt;

&lt;div class=&#34;&#34;&gt;
  &lt;p&gt;
    声明：本文译自 &lt;a href=&#34;http://philipwalton.com/articles/css-architecture/&#34;&gt;CSS Architecture&lt;/a&gt; 一文，thanks Philip Walton for sharing and translate permission。
  &lt;/p&gt;
  
  &lt;p&gt;
    对多数 Web 开发人员来说，精通 CSS 意味着你可以在代码中完美重现一个视觉模型。你不用表格，也尽少用图片 &amp;#8211; 对此你感到自豪。如果你真的很擅长，则你会用最新、最好的技术，比如媒体查询，过渡和转换。对优秀的 CSS 开发人员来说，这些都是必须，但在评估个人技能时，CSS 仍有一个方面很少被提及。
  &lt;/p&gt;
  
  &lt;p&gt;
    有趣的是，对其他语言我们通常不会这样疏忽大意。一个 Rails 开发人员不会因为他的代码合规范就被认为优秀。这是底线。它首先要符合规范，然后才好基于它来做评价：代码可读性如何？是否易于修改或扩展？跟程序的其它部分解藕度如何？扩展性如何？
  &lt;/p&gt;
  
  &lt;p&gt;
    这些问题，在评估代码库其他部分时是理所当然要问的，CSS 也不应该例外。今天的 web 应用程序比以往任何时候都要大，一个不经认真思索的 CSS 架构会削弱开发能力。所以，现在是时候了，像评估程序其他部分那样去评估 CSS。可不能再事后再说，或都干脆撇为“设计师”的问题。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;_CSS&#34;&gt;良好 CSS 架构的目标&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;hey_CSS&#34; href=&#34;#_CSS&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    在 CSS 社区，要就&lt;strong&gt;最佳实践&lt;/strong&gt;取得一般共识可不容易。只要看看 &lt;a href=&#34;https://news.ycombinator.com/item?id=2658948&#34;&gt;Hacker News 上的评论&lt;/a&gt;及 &lt;a href=&#34;http://csslint.net/&#34;&gt;CSS Lint&lt;/a&gt; 释出后&lt;a href=&#34;http://2002-2012.mattwilcox.net/archive/entry/id/1054/&#34;&gt;开发者们的反应&lt;/a&gt;就应该很清楚，我们连最基本的、CSS 作者该的和不该的都没法有一致看法。
  &lt;/p&gt;
  
  &lt;p&gt;
    因此，我认为我们应该首先定义我们的目标，而不是我为自己的一套最佳做法铺陈论点。如果我们在目标上达成一致，那么我们就有望找出糟糕的 CSS，不是因为它打破我们先入为主的关于好的观念，而是它在阻碍开发进度。
  &lt;/p&gt;
  
  &lt;p&gt;
    我相信良好的 CSS 架构目标应该与所有优秀软件开发相同。我希望我的 CSS 是可预见的，可重复使用的，可维护且可扩展的。
  &lt;/p&gt;
  
  &lt;h3&gt;
    可预见的
  &lt;/h3&gt;
  
  &lt;p&gt;
    可预见的 CSS 意味着你的规则不会给你意外。当你添加或更新一条规则，它不应该影响到你没打算影响的网站部分。对较少更改的小网站，这不很重要，但对数十或数百页的大网站来说，可预见的 CSS 是一种必须。
  &lt;/p&gt;
  
  &lt;h3&gt;
    可重复使用
  &lt;/h3&gt;
  
  &lt;p&gt;
    CSS 规则应该是抽象的，足够的解藕，你可以从现有部分快速创建新组件，而不必重编码那些你已经解决的模式和问题。
  &lt;/p&gt;
  
  &lt;h3&gt;
    可维护的
  &lt;/h3&gt;
  
  &lt;p&gt;
    当需要在你的网站上添加、更新或重新安排新组件和特性时，我们不需要重构现有 CSS。添加 X 组件到页面中不应该破坏 Y 组件。
  &lt;/p&gt;
  
  &lt;h3&gt;
    可扩展
  &lt;/h3&gt;
  
  &lt;p&gt;
    随着你的网站规模和复杂度不断增长，它通常需要更多开发者来维护。可扩展的 CSS 意味着，不论是一个人还是一个大的工程团队，都可以轻松管理。这也意味着，你的网站 CSS 架构平易近人，而不是一条巨大的学习曲线。仅仅因为你是今天唯一接触 CSS 的开发者并不意味着明天还如此。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i&#34;&gt;常见的不良做法&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi&#34; href=&#34;#i&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    在我们了解良好 CSS 架构方法前，我觉得有必要先看看一些常见的不良做法，这对我们是有帮助的。通常只有通过反复的错误，我们才能开始拥抱其他方法。
  &lt;/p&gt;
  
  &lt;p&gt;
    下面的例子，其实是我写过的代码的概括，虽然技术上说没问题，但每一个都会导致灾难，让人头痛。这些模式过去一直让我陷入麻烦。尽管我意愿美好，并且承诺这一次一定会有所不同。
  &lt;/p&gt;
  
  &lt;h3&gt;
    基于父元素来修改组件
  &lt;/h3&gt;
  
  &lt;p&gt;
    互联网上，几乎每一个网站都会有一个视觉元素，每次出现都一个样，却总有一次例外。面对这种一次性时，几乎每一个新 CSS 开发人员（即使是有经验的）都用同样的处理方式。你为这一异类找到一个独有的父元素（或者你创建一个），然后写一个新规则来处理它。
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;.widget {
  background: yellow;
  border: 1px solid black;
  color: black;
  width: 50%;
}

#sidebar .widget {
  width: 200px;
}

body.homepage .widget {
  background: white;
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    第一眼看去，这只是段相当无害的代码，且让我们按上面确立的目标检查一下它。
  &lt;/p&gt;
  
  &lt;p&gt;
    首先，例子中的窗口小部件不可预见。创建这些部件的开发人员期望它们看起来都是某个样子，然而当他在侧边栏或主页上使用时，却发现它不一样，尽管标记完全相同。
  &lt;/p&gt;
  
  &lt;p&gt;
    它也不好复用或扩展。如果其它页面上也需要它，而且跟主页上的样子一样，会怎样？又要添加新规则。
  &lt;/p&gt;
  
  &lt;p&gt;
    最后，它不易维护。如果小部件要重新设计，将要在好几个地方更新 CSS ，而且与上面的例子不同，这种反模式规则很少出现在一起。
  &lt;/p&gt;
  
  &lt;p&gt;
    想像一下，如果这种类型的代码是在任何其他语言中完成。基本上，你就是先定义一个类，然后在另一部分代码，取得类的定义，然后基于某一特定用途做些修改。这直接违反开放/闭合的软件开发原则：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;软件实体（类，模块，函数等）应该开放可扩展，对修改闭合。
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    在这篇文章后面，我们将看看如何不依赖父选择符来修改组件。
  &lt;/p&gt;
  
  &lt;h3&gt;
    过于复杂的选择器
  &lt;/h3&gt;
  
  &lt;p&gt;
    互联网上不时就会出现一篇文章，展示 CSS 选择器的能力，并宣称，你可以不靠任何类或 ID 样式化整个网站。
  &lt;/p&gt;
  
  &lt;p&gt;
    虽然技术上确实如此，但随着我接触 CSS 越多，我会越远离复杂的选择器。选择器越复杂，它跟 HTML 耦合度越高。依托 HTML 标签和组合的确可以让你的 HTML 干干净净，但结果是你的 CSS 又臃肿又杂乱。
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;#main-nav ul li ul li div { }
#content article h1:first-child { }
#sidebar &amp;gt; div &amp;gt; h3 %2B p { }
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    所有上述例子逻辑上均合理。第一个可能是在样式化下拉菜单，第二个说的是文章主标题看起来应该跟所有其他 h1 元素不同，最后一个例子好像是给侧边栏部分的第一段落增加些额外间距。
  &lt;/p&gt;
  
  &lt;p&gt;
    如果这 HTML 永远不变，这种说法还有可取之处，但 HTML 一直不变本身就很不现实。复杂的选择器让人印象深刻，它们可以从 HTML 中分离出表现，但它们很少有助于实现我们的目标 &amp;#8211; 良好 CSS 架构。
  &lt;/p&gt;
  
  &lt;p&gt;
    上面这些例子全是不能复用的。因为选择器指向的是标记中某一特殊地方，另一组件因为 HTML 结构不同，也就没法复用那些样式。举第一个选择器（下拉）为例，如果类似的下拉需要在不同页面出现，并且它还不在 &lt;code&gt;#main-nav&lt;/code&gt; 元素里，我们该怎么办？你只能重建整个风格。
  &lt;/p&gt;
  
  &lt;p&gt;
    一旦 HTML 需要改变，这些选择器也难以预见到情况。想像一下，如果某个开发者想把第三个例子中的 div 标签改成 HTML5 的 section 标签，整条规则就废了。
  &lt;/p&gt;
  
  &lt;p&gt;
    因为这些选择器只有在 HTML 保持不变时方有效，他们显然不可维护、不可扩展。
  &lt;/p&gt;
  
  &lt;p&gt;
    在大型应用中，你需要权衡然后做出妥协。以保持 HTML “干净”的名，换来复杂选择器的脆弱，其实并不值得。
  &lt;/p&gt;
  
  &lt;h3&gt;
    过于通用的类名称
  &lt;/h3&gt;
  
  &lt;p&gt;
    创建可复用的视觉组件时，组件的子元素置入组件类名的域中是很通用的作法。例如：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;&amp;lt;div class=&#34;widget&#34;&amp;gt;
  &amp;lt;h3 class=&#34;title&#34;&amp;gt;...&amp;lt;/h3&amp;gt;
  &amp;lt;div class=&#34;contents&#34;&amp;gt;
    Lorem ipsum dolor sit amet, consectetur adipiscing elit.
    In condimentum justo et est dapibus sit amet euismod ligula ornare.
    Vivamus elementum accumsan dignissim.
    &amp;lt;button class=&#34;action&#34;&amp;gt;Click Me!&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

.widget {}
.widget .title {}
.widget .contents {}
.widget .action {}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    我们的想法是，&lt;code&gt;.title&lt;/code&gt;,&lt;code&gt;.contents&lt;/code&gt; 及 &lt;code&gt;.action&lt;/code&gt; 这些子元素类可以安全地样式化，而不必担心这些样式会溢出到任何其他同名类元素中。确实如此，但它同样不能阻止同类名的样式渗入。
  &lt;/p&gt;
  
  &lt;p&gt;
    在一个大项目中，像 &lt;code&gt;.title&lt;/code&gt; 这样的类名会经常出现，可能是在另一个上下文，甚至自身中。如果这种情况发生，部件的标题就会跟预想的不同。
  &lt;/p&gt;
  
  &lt;p&gt;
    过于通用的类名会导致难以预测的 CSS。
  &lt;/p&gt;
  
  &lt;h3&gt;
    让一个规则做太多事情
  &lt;/h3&gt;
  
  &lt;p&gt;
    有时候，你会创建一个视觉组件，离网站某部分左边、上边均20px：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;.widget {
  position: absolute;
  top: 20px;
  left: 20px;
  background-color: red;
  font-size: 1.5em;
  text-transform: uppercase;
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    然后在后面，你需要在不同位置使用这一组件。上述 CSS 代码将无法正常使用，因为它在不同上下文中无法复用。
  &lt;/p&gt;
  
  &lt;p&gt;
    问题就在于，你让这个选择器做太多事了。在一条规则里，你定义了外观和风格，还定义了布局和位置。外观和风格是可重复使用的，但布局和位置不是。因为它们是一起用的，整个规则就像个妥协结果。
  &lt;/p&gt;
  
  &lt;p&gt;
    虽然第一眼看上去，这可能无害，但它通常会导致 CSS 不熟练的开发者不断复制粘贴。如果一个团队新成员想要某样东西，它看起来像某一组件，比如说 .infobox，他们可能会先尝试该类。但是，那行不通的，因为新 infobox 会以不一样的方式定位，你觉得他们接下来可能做什么？在我的经验中，大多数新开发人员都不会把规则破开，整理成可复用的部分。相反，他们会创建一个新选择器，把这一特定实例需要的代码复制、粘贴进来，结果就不必要地重复了代码。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-2&#34;&gt;原因&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-2&#34; href=&#34;#i-2&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    所有上述问题都有一个共性，他们把过多样式化的责任交给了 CSS。
  &lt;/p&gt;
  
  &lt;p&gt;
    这说法看似奇怪。毕竟，它是一个样式表，它难道不该承担大部分（如果不是全部）的样式化工作？这不正是我们想要的吗？
  &lt;/p&gt;
  
  &lt;p&gt;
    对这个问题的简单答案是“是的”，但是，像往常一样，事情并不总是那么简单。内容与表现分离是件好事，但就因为你从 HTML 中分离出 CSS，并不意味着你的内容就和表现分离了。换句话说，从 HTML 代码中分拆出所有表现代码并没有实现我们的目标，因为我们的 CSS 要正常工作，需要非常了解 HTML 结构。
  &lt;/p&gt;
  
  &lt;p&gt;
    此外，HTML 很少只是内容，它几乎总也是结构。而往往这种结构包含一些容器元素，它们没有其他目的，仅仅是让 CSS 隔离出一组特定元素。即使没有表现的类，这仍明显是表现与HTML的混合。但是否有必要把表现混入内容？&lt;!--这一段有些不明白--&gt;
  &lt;/p&gt;
  
  &lt;p&gt;
    我相信，基于 HTML 和 CSS 的当前状况，让它们共同努力一同担当表现层的工作是必要且明智的。内容层仍然可以通过模板和 partials 抽象出。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-3&#34;&gt;解决方法&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-3&#34; href=&#34;#i-3&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    既然你的 HTML 和 CSS 要一同合作来搭建 web 应用程序表示层，他们就需要一个方法，可以实践所有良好的 CSS 架构原则。
  &lt;/p&gt;
  
  &lt;p&gt;
    我发现的最好办法是，CSS 里尽可能少包括 HTML 结构。CSS 应该定义一组视觉元素的外观（以减少与 HTML 的耦合度），这些元素不论出现在 HTML 的哪里，都应该是那个样子。如果某个组件在不同情况下需要不同外观，它应该被定义成其他东西，应用它则是 HTML 的责任。
  &lt;/p&gt;
  
  &lt;p&gt;
    举个例子， CSS 可能通过.button 类定义一个按钮组件。如果 HTML 想要一个特定元素，看起来像个按钮，它就应该使用这个类。如果有些情况需要不同的按钮（比如大点的，或是全宽度的），那么 CSS 需要一个新类来定义外观，然后，HTML 应用新类，来布置新外观。
  &lt;/p&gt;
  
  &lt;p&gt;
    CSS 定义你的组件是什么样子，HTML 则将这些样式配给页面元素。CSS 需要了解的 HTML 结构越少，结果会越好。
  &lt;/p&gt;
  
  &lt;p&gt;
    在 HTML 中明确声明你的需要，会有一个很大的好处，它可以让其他查看标签的开发人员确切知道什么元素应该是什么样子。意图是显而易见的。如果不是这种做法，就很难区分元素的外观是有意还是无意的，这给团队带来困惑。
  &lt;/p&gt;
  
  &lt;p&gt;
    一种常见的反对声音是说，标签中加入许多类会导致有很多工作要做。一条 CSS 规则可以针对特定组件的一千个实例，那么有什么值得我们为了在标签中明确声明去书写一千次的类名？
  &lt;/p&gt;
  
  &lt;p&gt;
    虽然这种担忧是有的，它却可能会误导。它的言下之意是，或者你在 CSS 中使用父选择器，或者你手写1000次 HTML 类，但我们显然有其他替代方法。Rails 或者其他框架中的视图层的抽象，可以在保持明确声明外观的同时无需在 HTML 里重复写同一类。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-4&#34;&gt;最佳实践&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-4&#34; href=&#34;#i-4&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    在我犯过一遍又一遍的上述错误，并付出代价后，我得出了以下建议。虽然并不全面，但我的经验表明，坚持这些原则将有助你更好地实现良好 CSS 架构目标。
  &lt;/p&gt;
  
  &lt;h3&gt;
    目的明确
  &lt;/h3&gt;
  
  &lt;p&gt;
    要确保你的选择器不会误操作其它元素的最好方法，是不给它们机会。&lt;code&gt;#main-nav ul li ul li div&lt;/code&gt; 这样的选择器，很容易就会在你更改标签过程中误样式化其他元素。而 &lt;code&gt;.subnav&lt;/code&gt; 这样的样式，绝不会无意样式化意外元素。给你想要样式化的元素应用类是最好的方式，这样可以保持你的 CSS 可预见。
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;/* Grenade */
#main-nav ul li ul { }

/* Sniper Rifle */
.subnav { }
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    以上两个例子，你可以想像第一个是手榴弹，第二个则是狙击枪。手榴弹今天可能工作得很好，但你永远不知道，什么时候无辜平民会进入到爆炸范围内。
  &lt;/p&gt;
  
  &lt;h3&gt;
    分割你的需要
  &lt;/h3&gt;
  
  &lt;p&gt;
    我已经提到过，一个组织良好的组件层可以帮助离散 CSS 与 HTML 结构。此外，你的 CSS 组件本身应该是模块化的。组件应该知道如何样式化自己，并且能把样式化工作做好，但它们不应该负责它们的布局或位置，也不应该对他们将如何与周围元素间隔开这种事做太多假设。
  &lt;/p&gt;
  
  &lt;p&gt;
    总的来说，组件应该定义它们的外观，而不是布局或位置。当你看到位置，宽度，高度和边距与背景，颜色，字体等属性出现在同一规则里时，就要小心了。
  &lt;/p&gt;
  
  &lt;p&gt;
    布局和位置，应该由一个独立的布局类或单独的容器元素处理。（请记住，要有效分离内容与表现，往往要求把内容从容器中分开。）
  &lt;/p&gt;
  
  &lt;h3&gt;
    命名空间你的类
  &lt;/h3&gt;
  
  &lt;p&gt;
    我们已经研究了为什么父选择器在封装和防止样式交叉污染时不是100%有效的。一个更好的方法是应用命名空间到类上。如果一个元素是视觉组件一员，则每个子元素类都应该使用组件基类名称作为命名空间。
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;/* High risk of style cross-contamination */
.widget { }
.widget .title { }

/* Low risk of style cross-contamination */
.widget { }
.widget-title { }
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    命名空间你的类，可以让你的组件自包含、模块化。它最大限度地减少现有类发生冲突的可能性，并降低样式化子元素需要的特殊性。
  &lt;/p&gt;
  
  &lt;h3&gt;
    通过修饰类来扩展组件
  &lt;/h3&gt;
  
  &lt;p&gt;
    当现有的组件在不同上下文中略有不同时，创建一个修饰类来扩展它。
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;/* Bad */
.widget { }
#sidebar .widget { }

/* Good */
.widget { }
.widget-sidebar { }
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    我们已经看到基于组件父元素之一修改组件的缺点，但这里需要说一下：修饰类可应用到任何地方。基于位置的覆写只能在特定位置使用。修饰类则可以根据你的需要任意使用。最后，修饰类在 HTML 中清楚表达了开发者的意图。基于位置的类却相反，如果开发者只是查看 HTML，则基于位置的类根本不可见，大大增加被忽略的概率。
  &lt;/p&gt;
  
  &lt;h3&gt;
    按逻辑结构组织你的 CSS
  &lt;/h3&gt;
  
  &lt;p&gt;
    &lt;a href=&#34;http://snook.ca/&#34;&gt;Jonathan Snook&lt;/a&gt; 在他的优秀著作 &lt;a href=&#34;http://smacss.com/&#34;&gt;SMACSS&lt;/a&gt; 里建议把 CSS 规则分为​四个不同类别：基础，布局，模块，和状态。基础由重置规则和元素缺省值组成。布局用于定位跨站元素，还包含通用布局方式如网络系统。模块是可重复使用的视觉元素，状态则指可以通过 JavaScript 开启或关闭的样式。
  &lt;/p&gt;
  
  &lt;p&gt;
    在 SMACSS 系统中，模块（相当于我说的组件）包括 CSS 规则的绝大多数，因此我觉得常常有必要进一步分割，抽象到模板中。
  &lt;/p&gt;
  
  &lt;p&gt;
    组件是独立的视觉元素。模板却是构建使用的基础块。模板无法自代表，也很少描述外观和风格。相反，它们是单一，可重复的模式，可以放在一起，形成一个组件。
  &lt;/p&gt;
  
  &lt;p&gt;
    举个具体的例子，一个组件可能是一个模式对话框。对话框在头部可能有网站的背景渐变标识，围绕它可能有一个阴影，在右上角可能有一个关闭按钮，它可能被固定定位，水平和垂直均居中。这四种模式中的每一个都可能在整站中一次又一次地用到，这样你就不必每次都重新编写这些模式。他们都是模板，一起则构成组件。
  &lt;/p&gt;
  
  &lt;p&gt;
    我通常不在 HTML 中使用模板类，除非我有一个很好的理由。相反，我使用一个预处理器在组件定义中引入模板样式。我将在后面详细讨论我这样做的理由。
  &lt;/p&gt;
  
  &lt;h3&gt;
    使用类来样式化并且只用来样式化
  &lt;/h3&gt;
  
  &lt;p&gt;
    无论谁，如果在大型项目上工作过，就可能遇到一个 HTML 元素有这么一个类，类的目的完全未知。你想删除它，但你很犹豫，因为它可能有些你不知道的用处。这样的事一次又一次的发生，然后，随着时间推移，你的 HTML 中充满了不起任何作用的类，只因为团队成员都不敢删除它们。
  &lt;/p&gt;
  
  &lt;p&gt;
    问题就在于，前端 web 开发中，类通常都被赋予太多责任。他们样式化 HTML 元素，他们扮演 JavaScript 钩子，他们加入到 HTML 中用于功能检测，他们用于自动化测试等等。
  &lt;/p&gt;
  
  &lt;p&gt;
    这是问题。当类被应用程序的大部分用到，要想把它们从 HTML 中移除就会变得相当可怕。
  &lt;/p&gt;
  
  &lt;p&gt;
    然而，确立一个惯例就可以完全避免这个问题。在 HTML 中，当你看到一个类，你应该能够立即说出它的目的是什么。我的建议是给所有非样式化目的的类加上前缀。比如我用 .js-， 前缀表示用于 JavaScript 目的，.supports- 则表示 Modernizr 类。所有不带前缀的类用于样式且只用于样式。
  &lt;/p&gt;
  
  &lt;p&gt;
    这使得查找并移除未使用的类变得简单，就好像搜索样式表目录一样了。你甚至可以在 JavaScript 中自动完成这一过程，只要交叉引用 HTML 中的类与 document.styleSheets 对象的类。不在 document.styleSheets 中的类，可以安全删除。
  &lt;/p&gt;
  
  &lt;p&gt;
    总的来说，内容从表现区分开是最佳实践，功能跟表现分离同样重要。使用样式化的类做 JavaScript 勾子会高度藕合你的 CSS 和 JavaScript，结果会很难或不可能在不破坏功能的情况下更新某些元素的外观。
  &lt;/p&gt;
  
  &lt;h3&gt;
    使用逻辑结构命名你的类
  &lt;/h3&gt;
  
  &lt;p&gt;
    当下，大多数人写 CSS 用连字符分隔词。但单独的连字符通常并不足以区分不同类型的类。
  &lt;/p&gt;
  
  &lt;p&gt;
    &lt;a href=&#34;http://nicolasgallagher.com/&#34;&gt;Nicolas Gallagher&lt;/a&gt; 最近写了一篇，内容是&lt;a href=&#34;http://nicolasgallagher.com/about-html-semantics-front-end-architecture/&#34;&gt;他如何解决这个问题&lt;/a&gt;，我对他的办法略加修改然后应用，取得了不错的结果。为描述命名约定的必要，请看看以下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;/* A component */
.button-group { }

/* A component modifier (modifying .button) */
.button-primary { }

/* A component sub-object (lives within .button) */
.button-icon { }

/* Is this a component class or a layout class? */
.header { }
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    如果只是看上面的类，很难区分它们分别应用于哪一类规则。这不仅增加开发过程中的混乱，也使得你很难自动化测试你的 CSS 和 HTML。一个结构化的命名惯例，让你看到一个类名就确切地知道它与其他类的关系以及它应该出现在 HTML 的哪里 &amp;#8211; 也使得命名更容易，此前并不能的测试变得可行。
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;/* Templates Rules (using Sass placeholders) */
%template-name
%template-name--modifier-name
%template-name__sub-object
%template-name__sub-object--modifier-name

/* Component Rules */
.component-name
.component-name--modifier-name
.component-name__sub-object
.component-name__sub-object--modifier-name

/* Layout Rules */
.l-layout-method
.grid

/* State Rules */
.is-state-type

/* Non-styled JavaScript Hooks */
.js-action-name
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    第一个例子重写：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;/* A component */
.button-group { }

/* A component modifier (modifying .button) */
.button--primary { }

/* A component sub-object (lives within .button) */
.button__icon { }

/* A layout class */
.l-header { }
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-5&#34;&gt;工具&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-5&#34; href=&#34;#i-5&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    保持一个有效、有组织的 CSS 架构是非常困难的，尤其是在大型团队里。一些这或那的不良规则，可以越滚越大，直到变成一个不可收拾的烂摊子。一旦你的应用程序 CSS 进入特殊性战争的地步，并且只能靠着出 !important 这张王牌，它不从头开始也就基本无法恢复。关键是从一开始就要避免这些问题。
  &lt;/p&gt;
  
  &lt;p&gt;
    幸运的是，有一些工具可以让控制你的网站 CSS 架构变得简单。
  &lt;/p&gt;
  
  &lt;h3&gt;
    预处理器
  &lt;/h3&gt;
  
  &lt;p&gt;
    这些日子里，谈 CSS 工具而不提预处理器是不可能的，因此本文也不例外。但在我赞美它们的有用之前，我应提醒几句。
  &lt;/p&gt;
  
  &lt;p&gt;
    预处理器帮助你更快地编写 CSS，而不是更好。因为最终它被变成纯 CSS，应此也适用同样规则。既然预处理器能让你更快地写 CSS，那么它也可以让你更快地写糟糕的 CSS，所以在考虑一个预处理解决你的问题前，重要的是要先明白良好的 CSS 架构。
  &lt;/p&gt;
  
  &lt;p&gt;
    许多所谓的预处理器“特性”实际上对 CSS 架构非常不好。以下是一些“特性”，我尽可能要避免（虽然总体思路适用于所有预处理语言，以下这些指南特指 Sass）。
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      如果只是为组织代码，决不要嵌套规则。只有当输出的 CSS 是你想要的时才嵌套。
    &lt;/li&gt;
    &lt;li&gt;
      如果不传递参数，切勿使用 mixin。不带参数的 mixins 不如使用模板代替，它们是可扩展的。
    &lt;/li&gt;
    &lt;li&gt;
      如果选择器并非单一类，则切勿使用 @extend。从设计的角度看，它毫无道理，而且它使编译后的 CSS 膨大。
    &lt;/li&gt;
    &lt;li&gt;
      在组件修饰符规则中，切勿为 UI 组件使用 @extend，因为你失去了继承链（这个问题后面会聊得更多）。
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    预处理器最好的部分，是一些函数如 &lt;a href=&#34;http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#extend&#34;&gt;@extend&lt;/a&gt; 和 &lt;a href=&#34;http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#placeholder_selectors_&#34;&gt;%placeholder&lt;/a&gt;。两者都能让你轻松管理 CSS 抽象，而不添加多余东西，也不会在你的 HTML 中添加大量基类，这些基类相当难管理。
  &lt;/p&gt;
  
  &lt;p&gt;
    使用 @extend 时应特别注意，因为有时你会想在你的 HTML 中添加那些类。例如，当你第一次了解 @extend，你很容易就在你所有修饰类中这样使用：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;.button {
  /* button styles */
}

/* Bad */
.button--primary {
  @extend .button;
  /* modification styles */
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这样做的问题是，在HTML中，你失去了继承链。这下，用 JavaScript 来选择所有按钮实例变得很难。
  &lt;/p&gt;
  
  &lt;p&gt;
    一般来说，我决不扩展 UI 组件或任何我后来可能会想知道类型的东西。这是模板的用处，也是另一种帮助区分模板和组件的方式。在你的应用程序逻辑中，你不会需要针对模板，因此可以安全地使用预处理器扩展它。
  &lt;/p&gt;
  
  &lt;p&gt;
    拿上面提到的模式对话框来说，它看起来可能是这样：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;.modal {
  @extend %dialog;
  @extend %drop-shadow;
  @extend %statically-centered;
  /* other modal styles */
}

.modal__close {
  @extend %dialog__close;
  /* other close button styles */
}

.modal__header {
  @extend %background-gradient;
  /* other modal header styles */
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;h3&gt;
    CSS Lint
  &lt;/h3&gt;
  
  &lt;p&gt;
    &lt;a href=&#34;http://www.stubbornella.org/content/&#34;&gt;Nicole Sullivan&lt;/a&gt; 和 &lt;a href=&#34;http://www.nczonline.net/&#34;&gt;Nicholas Zakas&lt;/a&gt; 创建了 &lt;a href=&#34;http://csslint.net/&#34;&gt;CSS Lint &lt;/a&gt;，一个代码质量检查工具，帮助开发人员检测他们的 CSS 坏习惯。他们的网站这样介绍：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;CSS Lint 指出你的 CSS 代码问题。它检查基本语法，并且对代码应用一组规则，查找有问题的模式或效率低下的地方。规则都是可插拔的，因此你可以轻松编写自己的，或是忽略那些你不想要的规则。
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    虽然一般的规则集对于大多数项目可能并不完美，CSS Lint 最大的特点是它有能力根据你的需要进行定制。这意味着你可以从他们的默认列表中挑出你想要的，也可以编写自己的。
  &lt;/p&gt;
  
  &lt;p&gt;
    像 CSS Lint 这样的工具，在任何大型团队中都是必不可少的，这可以确保一致和惯例。也正像我在前面提到的，约定伟大的地方是，他们允许像 CSS Lint 这样的工具轻易识别出问题。
  &lt;/p&gt;
  
  &lt;p&gt;
    基于我上面提出的约定，要编写规则来检查反模式就很容易。这里有我使用的几个建议：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      不要在你的选择器中使用 ID。
    &lt;/li&gt;
    &lt;li&gt;
      任何多部分规则都不要使用非语义类型选择（如 DIV，SPAN）。
    &lt;/li&gt;
    &lt;li&gt;
      不要使用超过2个组合的选择器。
    &lt;/li&gt;
    &lt;li&gt;
      不要允许任何 “js” 开头的类名。
    &lt;/li&gt;
    &lt;li&gt;
      非 “l-” 前缀的规则经常使用布局和定位则给出警告。
    &lt;/li&gt;
    &lt;li&gt;
      如果一个类后来作为一个其他东西的子类重新定义，则给出警告。
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    这些显然只是建议，但他们的主要目的，就是让你思考你的项目要如何加强标准。
  &lt;/p&gt;
  
  &lt;h3&gt;
    HTML Inspector
  &lt;/h3&gt;
  
  &lt;p&gt;
    早些时候，我提到，要找出 HTML 中用到却不曾在任何样式表中定义的类是很容易的。我目前正在开发一个工具叫做 &lt;a href=&#34;https://github.com/philipwalton/html-inspector&#34;&gt;HTML Inspector&lt;/a&gt; ，它让这个过程更简单。
  &lt;/p&gt;
  
  &lt;p&gt;
    HTML Inspector 遍历你的 HTML（很像 CSS Lint），允许你编写自己的规则，在一些惯例被打破时抛出错误和警告。我目前使用以下规则：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      如果相同 ID 不止一次出现​​在页面上，抛出警告。
    &lt;/li&gt;
    &lt;li&gt;
      不使用任何样式表中没有的类，白名单（如 “js-” 前缀的类）里的也不使用。
    &lt;/li&gt;
    &lt;li&gt;
      修饰类不应该离开它们的基类使用。
    &lt;/li&gt;
    &lt;li&gt;
      如果祖先中不包含基类，则不要使用次对象类
    &lt;/li&gt;
    &lt;li&gt;
      普通的 DIV 或 SPAN元素，不附带任何类的话，不应该用在HTML中。
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-6&#34;&gt;总结&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-6&#34; href=&#34;#i-6&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    CSS 不只是视觉设计。不要因为你写的是 CSS，就丢掉编程最佳实践。像 OOP，DRY，开放/闭合的原则，关注点分离等概念仍然适用于 CSS。
  &lt;/p&gt;
  
  &lt;p&gt;
    我们的底线是，无论如何组织代码，请确保判断方法的标准是，它们是否在长远上，真正让你的开发变得更加简单、易于维护。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-7&#34;&gt;翻译说明&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-7&#34; href=&#34;#i-7&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      Sass 部分，因为我只用过 LESS，所以理解不一定准确
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>IE6 下的 PNG 透明</title>
      <link>https://www.zfanw.com/blog/ie6-png-transparent.html</link>
      <pubDate>Wed, 14 Aug 2013 11:19:46 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/ie6-png-transparent.html</guid>
      <description>

&lt;p&gt;就我的实践经验，IE6 下解决 PNG 图片透明问题，&lt;a href=&#34;http://www.dillerdesign.com/experiment/DD_belatedPNG/&#34;&gt;DD_belatedPNG&lt;/a&gt; 是比较方便的。&lt;/p&gt;

&lt;p&gt;它的用法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--[if IE 6]&amp;gt;
&amp;lt;script src=&amp;quot;DD_belatedPNG.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
  /* EXAMPLE */
  DD_belatedPNG.fix(&#39;.png_bg&#39;);

  /* string argument can be any CSS selector */
  /* .png_bg example is unnecessary */
  /* change it to what suits you! */
&amp;lt;/script&amp;gt;
&amp;lt;![endif]--&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很多人可能就参照它的示例写，比如，腾讯旗下的导航站是这样写的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
try{
    if(DD_belatedPNG){
        DD_belatedPNG.fix(&#39;img,li.png-filter a span.qqicon-logout,li.png-filter a span.qqicon,.icon-weixin,.mailInput-icon-unfold,#changeSearchEngine_ICON,#currentMail-s,.engineWrap a,.game-box .caption a.little-game, .game-box .caption a.page-game, .game-box .caption a.web-game, .xzSelect .drop, .xzClosed, .xzClosed.hover,ul.channel-videoImg span.title em,.down-icon,.history-del,.channel-videoline,.videoplay,.video-pages a,.v-new&#39;);
    }
}catch(e){};
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们能看到，&lt;code&gt;fix&lt;/code&gt; 里有一堆的 class 及 id 又或者其他 CSS 选择符。这一堆代码维护起来很困难 &amp;#8211; 写了基本就不要想修改。&lt;/p&gt;

&lt;p&gt;我的方法是，只设定一个 CSS 类 &lt;code&gt;pngfix&lt;/code&gt;，凡使用 PNG 透明图片的元素，都加上该类，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h2 class=&amp;quot;pngfix&amp;quot;&amp;gt;Goodbye IE6&amp;lt;/h2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后 JavaScript 语句只要一句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DD_belatedPNG.fix(&#39;.pngfix&#39;);   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;又因为我在 CSS 中抽象出一个 &lt;a href=&#34;http://www.zfanw.com/blog/css-sprite.html&#34;&gt;贴图定位的类&lt;/a&gt; &lt;code&gt;.sprite&lt;/code&gt;，则连 &lt;code&gt;.pngfix&lt;/code&gt; 都可以省掉，直接使用 &lt;code&gt;.sprite&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DD_belatedPNG.fix(&#39;.sprite&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;注意事项&#34;&gt;注意事项&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;如果背景图片使用 CSS 贴图定位，DD_belatedPNG 这个方法同样存在些问题，比如背景图片有1像素的偏移&lt;/li&gt;
&lt;li&gt;如果 PNG 使用 map 热点，则 DD_belatedPNG 处理后，热点的链接会无法点击，一个替代方法是 &lt;a href=&#34;http://labs.unitinteractive.com/unitpngfix.php&#34;&gt;Unit PNG Fix&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>