<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>前端开发 on 陈三</title>
    <link>https://www.zfanw.com/blog/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/</link>
    <description>Recent content in 前端开发 on 陈三</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 04 Jan 2014 07:47:38 +0000</lastBuildDate>
    <atom:link href="https://www.zfanw.com/blog/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>面试一个前端开发者</title>
      <link>https://www.zfanw.com/blog/interviewing-a-front-end-developer.html</link>
      <pubDate>Sat, 04 Jan 2014 07:47:38 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/interviewing-a-front-end-developer.html</guid>
      <description>&lt;div id=&#34;toc_container&#34; class=&#34;ml-l u-floatRight pure-u-1-1 pure-u-sm-2-5 toc_white no_bullets&#34;&gt;
  &lt;nav id=&#34;myaffix&#34;&gt;
  
  &lt;p class=&#34;toc-title&#34;&gt;
    目录
  &lt;/p&gt;
  
  &lt;ul class=&#34;toc-list nav&#34; role=&#34;menu&#34;&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;1&lt;/span&gt; 第一部分：对象原型&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-2&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;2&lt;/span&gt; 第二部分：参数&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-3&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;3&lt;/span&gt; 第三部分：上下文&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-4&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;4&lt;/span&gt; 第四部分：遮罩库&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-5&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;5&lt;/span&gt; 其他想法&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;&lt;/nav&gt;
&lt;/div&gt;

&lt;div class=&#34;&#34;&gt;
  &lt;p&gt;
    声明：This post is translated from &lt;a href=&#34;http://blog.sourcing.io/interview-questions&#34;&gt;Alex MacCaw&amp;#8217;s interesting sharing&lt;/a&gt;, thank him for allowing my translating and blogging here.
  &lt;/p&gt;
  
  &lt;p&gt;
    我在 Twitter、Stripe 的一部分工作包括面试前端工程师候选人。关于怎样面试，我们有很大的自由，我也因此开发出些不一样的问题集，颇有意思，所以我想分享下。
  &lt;/p&gt;
  
  &lt;p&gt;
    在继续前，我想声明一下，招聘是件极度困难的事，要在45分钟内就决定某个人是产上合适同样是艰巨的任务。面试的问题在于，每个人都努力要被雇佣。任何一个通过我面试的人，可能跟我一样，想得很多，而这不见得是件好事。因此，迄今为止我的决定多少都有碰运气的成分。不过，我相信这个方法是个好的开始。
  &lt;/p&gt;
  
  &lt;p&gt;
    最理想的，当然是候选人有一个非常完整的 &lt;strong&gt;GitHub&lt;/strong&gt;&lt;fnref target=&#34;11191.a&#34; /&gt; 简历，那么我们就可以一同回顾下他们的开源项目。我通常会浏览他们的代码，围绕一些设计决策，问他们问题。如果他们表现突出，那么面试就会更多地考核他们是否能跟团队良好协作。否则，我会继续问代码问题。
  &lt;/p&gt;
  
  &lt;p&gt;
    我的面试是非常实际的，全都关于代码。我不问抽象的、算法的问题 &amp;#8211; 其他面试官如果愿意，可以选择问这些，不过我认为这些问题跟前端编程的关联性是存疑的。我的问题看起来可能很简单，不过每个集合都有所针对，考察 JavaScript 知识的某一特定方面。
  &lt;/p&gt;
  
  &lt;p&gt;
    不需要白板。如果候选人带笔记本电脑，他们可以用自己的。否则他们可以用我的。他们可以使用他们喜欢的任何编辑器，通常我会在 Chrome 浏览器的控制台里直接测试他们的程序输出的结果。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i&#34;&gt;第一部分：对象原型&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi&#34; href=&#34;#i&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    我们先从简单的开始。我让候选人定义一个 &lt;code&gt;spacify&lt;/code&gt; 函数，函数接收一个字符串参数，然后返回一样的字符串，只是两个字符间均插入一个空格。例如：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;spacify(&#39;hello world&#39;)//=&amp;gt;&#39;h e l l o  w o r l d&#39;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这个问题看起来可能非常简单，但后面你会发现，这是个不错的开始，尤其对那些只是通过电话面试、不曾考察的候选人来说 &amp;#8211; 有些人声称了解 JavaScript，但实际上连个函数怎么写都不知道。
  &lt;/p&gt;
  
  &lt;p&gt;
    正确答案如下。有些时候，候选人会用 &lt;code&gt;for&lt;/code&gt; 循环，也是个可接受的答案。
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;function spacify(str) {
  return str.split(&#39;&#39;).join(&#39; &#39;);
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    紧接的一个问题，是让候选人将 &lt;code&gt;spacify&lt;/code&gt; 函数直接应用到 &lt;code&gt;String&lt;/code&gt; 对象，比如：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;&#39;hello world&#39;.spacify();
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    问这个问题，能让我了解候选人对函数原型的基本掌握情况。通常，这会引向一个有趣的讨论，就是直接在原型上定义属性，尤其是 &lt;code&gt;Object&lt;/code&gt; 上定义属性时带来的影响。最后的结果看起来如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;String.prototype.spacify = function(){
  return this.split(&#39;&#39;).join(&#39; &#39;);
};
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这时，我一般还会让候选人解释函数表达式与函数声明的区别。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-2&#34;&gt;第二部分：参数&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-2&#34; href=&#34;#i-2&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    接下来，我会问一些简单问题，专门考察他们对 &lt;code&gt;arguments&lt;/code&gt; 对象的理解程度。我会先运行一个尚未定义的 &lt;code&gt;log&lt;/code&gt; 函数。
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;log(&#39;hello world&#39;)
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    然后让他们定义一个 &lt;code&gt;log&lt;/code&gt; 函数，它会把字符串参数委托给 &lt;code&gt;console.log()&lt;/code&gt;。正确答案就差不多是后面几行这样，不过聪明的候选人会跳过直接应用 &lt;code&gt;apply&lt;/code&gt;。
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;function log(msg){
  console.log(msg);
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    等函数定义好了，我会更改调用 &lt;code&gt;log&lt;/code&gt; 的方式，传入多个参数。我会说清楚，我希望 &lt;code&gt;log&lt;/code&gt; 能接收不定数量的参数，而不仅仅两个。我也会提示一个情况：&lt;code&gt;console.log&lt;/code&gt; 能接收多个参数。
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;log(&#39;hello&#39;,&#39;world&#39;);
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    但愿你的候选人会直接用上 &lt;code&gt;apply&lt;/code&gt;。有时他们会绊倒在 &lt;code&gt;apply&lt;/code&gt; 跟 &lt;code&gt;call&lt;/code&gt; 的区别上，那你可以提示一下正确的方向。传递 &lt;code&gt;console&lt;/code&gt; 上下文也是非常重要的。
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;function log(){
  console.log.apply(console,arguments);
};
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    接着我会要求他们在每个记录信息前加上 &lt;code&gt;&#34;(app)&#34;&lt;/code&gt;，比如：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;&#39;(app) hello world&#39;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    就在这里，事情变得有些棘手。不错点的候选人知道 &lt;code&gt;arguments&lt;/code&gt; 是伪数组，要想操作它，我们需要事先将其转化为标准数组。这种情况一般是用 &lt;code&gt;Array.prototype.slice&lt;/code&gt;，如下所示：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;function log(){
  var args = Array.prototype.slice.call(arguments);
  args.unshift(&#39;(app)&#39;);

  console.log.apply(console,args);
};
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-3&#34;&gt;第三部分：上下文&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-3&#34; href=&#34;#i-3&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    接下来的一系列问题，是考察候选人对 JavaScript 上下文和 &lt;code&gt;this&lt;/code&gt; 的掌握。我首先定义如下例子。注意 &lt;code&gt;count&lt;/code&gt; 属性是从当前上下文取出的。
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;var User = {
  count: 1,

  getCount: function(){
    return this.count;
  }
};
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    然后我再定义以下几行，之后我问候选人 log 输出结果会是什么。
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;console.log(User.getCount());

var func = User.getCount;
console.log(func());
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    在这个案例中，正确答案是 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt;。你可能会感到惊讶，因为有很多人栽在类似这种的基础上下文问题。&lt;code&gt;func&lt;/code&gt; 在 &lt;code&gt;window&lt;/code&gt; 环境中执行，因此丢失 &lt;code&gt;count&lt;/code&gt; 属性。我会解释给他们，然后问他们如何保证 &lt;code&gt;func&lt;/code&gt; 的上下文总是绑定给 &lt;code&gt;User&lt;/code&gt;，这样它总是会正确返回 &lt;code&gt;1&lt;/code&gt;。
  &lt;/p&gt;
  
  &lt;p&gt;
    正确答案是使用 &lt;code&gt;Function.prototype.bind&lt;/code&gt;，比如：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;var func = User.getCount.bind(User);
console.log(func());
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    我一般还会解释说这个函数在旧浏览器中还没有提供，让他们写个垫片函数。弱一点的候选人多数要苦苦挣扎，不过要求你雇用的人全面理解 &lt;code&gt;apply&lt;/code&gt; 和 &lt;code&gt;call&lt;/code&gt; 是非常重要的。
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;Function.prototype.bind = Function.prototype.bind || function(context){
  var self = this;

  return function(){
    return self.apply(context, arguments);
  };
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    如果候选人只在浏览器原生 &lt;code&gt;bind&lt;/code&gt; 不存在时才垫片，可以额外加分。到此为止，如果他们表现都非常不错，我会要求他们柯里化参数&lt;fnref target=&#34;11191.b&#34; /&gt;。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-4&#34;&gt;第四部分：遮罩库&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-4&#34; href=&#34;#i-4&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    面试的最后，我会让候选人构建一些实际的东西，通常是一个遮罩库。我发现这很有用，因为它展示了整个前端层：HTML，CSS，和 JavaScript。如果面试的前面部分他们表现非常不错，我就会尽可能快的切入这个问题。
  &lt;/p&gt;
  
  &lt;p&gt;
    具体怎么做取决于他们，不过有一些关键东西需要我们留意：
  &lt;/p&gt;
  
  &lt;p&gt;
    在创建遮罩时，使用 &lt;code&gt;position:fixed&lt;/code&gt; 要比 &lt;code&gt;position:absolute&lt;/code&gt; 好，因为它保证遮罩覆盖整个窗口，不论窗口是否滚动。如果候选人没注意到，我会提出来，然后问他们 &lt;code&gt;fixed&lt;/code&gt; 与 &lt;code&gt;absolute&lt;/code&gt; 定位的区别。
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;.overlay {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  top: 0;
  background: rgba(0,0,0,.8);
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    他们怎样居中遮罩内容也能说明问题。有些人可能会用 CSS 和绝对定位 &amp;#8211; 内容的宽、高固定的情况下这是可行的。其他人可能会用 JavaScript 来定位。
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;.overlay article {
  position: absolute;
  left: 50%;
  top: 50%;
  margin: -200px 0 0 -200px;
  width: 400px;
  height: 400px;
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    我还会要求他们做到，遮罩被点击时要关闭，这可以切入讨论不同类型事件的传播。经常地，候选人会直接在遮罩上绑定一个单击事件监听器，然后调用它。
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;$(&#39;.overlay&#39;).clock(closeOverlay);
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这可行，但你随后会意识到，遮罩子元素的单击事件同样关闭了遮罩 &amp;#8211; 这显然不是我们想要的。解决办法是检查事件对象，确保事件不会传播，如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;$(&#39;.overlay&#39;).click(function(e){
  if (e.target == e.currentTarget)
    closeOverlay();
});
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-5&#34;&gt;其他想法&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-5&#34; href=&#34;#i-5&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    当然，这些问题只覆盖了前端知识的一小部分，你还可以问很多其他方面，比如性能，HTML5 APIs，AMD vs CommonJS 模块，构造器，类型和盒模式。我通常会根据面试者的兴趣，混合使用不同主题的问题。
  &lt;/p&gt;
  
  &lt;p&gt;
    我还建议看看前端开发面试问题库&lt;fnref target=&#34;11191.1&#34; /&gt;找想法，或者 JavaScript 花园&lt;fnref target=&#34;11191.2&#34; /&gt;列举的任何 JavaScript 行为。
  &lt;/p&gt;
  
  &lt;footnotes&gt;
    &lt;fn name=&#34;11191.a&#34;&gt;
      &lt;p&gt;
        &lt;a href=&#34;https://github.com/&#34;&gt;Github&lt;/a&gt;
      &lt;/p&gt;
    &lt;/fn&gt;
    
    &lt;fn name=&#34;11191.b&#34;&gt;
      &lt;p&gt;
        &lt;a href=&#34;http://en.wikipedia.org/wiki/Currying&#34;&gt;Wikipedia Currying&lt;/a&gt;
      &lt;/p&gt;
    &lt;/fn&gt;
    
    &lt;fn name=&#34;11191.1&#34;&gt;
      &lt;p&gt;
        &lt;a href=&#34;https://github.com/darcyclarke/Front-end-Developer-Interview-Questions&#34;&gt;Front-end Developer Interview Questions&lt;/a&gt;
      &lt;/p&gt;
    &lt;/fn&gt;
    
    &lt;fn name=&#34;11191.2&#34;&gt;
      &lt;p&gt;
        &lt;a href=&#34;http://bonsaiden.github.io/JavaScript-Garden&#34;&gt;JavaScript Garden&lt;/a&gt;
      &lt;/p&gt;
    &lt;/fn&gt;
  &lt;/footnotes&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>关于面试前端工程师</title>
      <link>https://www.zfanw.com/blog/on-interviewing-front-end-engineers.html</link>
      <pubDate>Wed, 01 Jan 2014 04:44:05 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/on-interviewing-front-end-engineers.html</guid>
      <description>&lt;div id=&#34;toc_container&#34; class=&#34;ml-l u-floatRight pure-u-1-1 pure-u-sm-2-5 toc_white no_bullets&#34;&gt;
  &lt;nav id=&#34;myaffix&#34;&gt;
  
  &lt;p class=&#34;toc-title&#34;&gt;
    目录
  &lt;/p&gt;
  
  &lt;ul class=&#34;toc-list nav&#34; role=&#34;menu&#34;&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;1&lt;/span&gt; 我们雇佣聪明的人&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-2&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;2&lt;/span&gt; 人力资源&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-3&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;3&lt;/span&gt; 成长&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-4&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;4&lt;/span&gt; 理解前端工程师&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-5&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;5&lt;/span&gt; 什么是重点&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-6&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;6&lt;/span&gt; 我们说给自己的谎&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-7&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;7&lt;/span&gt; 结论&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;&lt;/nav&gt;
&lt;/div&gt;

&lt;div class=&#34;&#34;&gt;
  &lt;p&gt;
    &lt;strong&gt;声明&lt;/strong&gt;：本文译自 Nicholas C. Zakas 的 &lt;a href=&#34;http://www.nczonline.net/blog/2013/12/27/on-interviewing-front-end-engineers/&#34;&gt;On interviewing front-end engineers&lt;/a&gt;。感谢作者的翻译许可。译文有不到之处，也欢迎指出。
  &lt;/p&gt;
  
  &lt;p&gt;
    Philip Walton 上周写了篇很有意思的文章&lt;fnref target=&#34;11171.1&#34; /&gt;，说的是他在旧金山几家公司面试前端工程师的经历。概述一下，就是他很惊讶，被问到他的（大部分跟计算机科学概念有关）及没问到他的问题（DOM 怎么看）惊到了。我很想自己也惊讶下，不过在过去七年里，我一直住在硅谷，所以这些故事是听了无数遍。再怎么想&lt;fnref target=&#34;11171.a&#34; /&gt;，我都不觉得这些问题只发生在旧金山湾区内 &amp;#8211; 我认为这是我们行业的问题，对前端工程师做什么以及创造什么价值的持续误解。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i&#34;&gt;我们雇佣聪明的人&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi&#34; href=&#34;#i&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    Google 当初崭露头角时，他们有个刻板的招聘方式。他们的想法是，尽可能招最聪明的人，这些人一旦招进来了，他们总能找出最能发挥你聪明才智的地方。这多少意味着，每个想进来的人，都会经历相似的面试，这面试试图标注一个工程师的「聪明」门槛&lt;fnref target=&#34;11171.b&#34; /&gt;。换句话说，不管你专长或专注的领域是什么，你的面试跟其他人基本差不多。一旦被视为「聪明」，你就被放进来了，只是还不知道你要做什么，直到你以一个真正资格的员工身份出现在校园里&lt;fnref target=&#34;11171.c&#34; /&gt;。
  &lt;/p&gt;
  
  &lt;p&gt;
    今天的行业内，围绕前端工程师的许多糟糕的招聘实践，我认为是 Google 的做法带的坏头。在我参加 Google 的面试时，我被那些跟我专业没半点关系的问题吓到了。我还记得，有好几个情况下我都在考虑自己是不是该放弃，因为我压根不知道怎样用堆排序&lt;fnref target=&#34;11171.d&#34; /&gt;来准确跟踪数以亿计的请求的搜索查询时间。那不是我职业生涯中想要做的，我对计算机科学的这个领域不感兴趣；这个问题究竟能提供什么价值？
  &lt;/p&gt;
  
  &lt;p&gt;
    （注意：我不知道 Google 今天是不是还在坚持类似的招聘方式。出于这篇文章的目的，我且把它称作「Google 的做法」，但我绝不在影射 Google 现在还在这样干。此外，Google 现在有，也曾经有一些世界上最优秀的前端工程师为他们工作。我绝不是说，他们在前端招聘上做得不好。）
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-2&#34;&gt;人力资源&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-2&#34; href=&#34;#i-2&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    从实用的角度出发，并且在经历创业失败后，我理解 Google 的做法。在一个公司还小，刚起步的时候，你需要能做各种不同事情的人。你没法要求有一个前端工程师、一个后端工程师、一个数据库管理员、一个网站可靠性工程师&lt;fnref target=&#34;11171.e&#34; /&gt;，这太奢侈。你需要的是能做很多事的人，至于他们是否达到专家水平就无所谓了 &amp;#8211; 他们只是需要把事情做好，然后在新任务出现时能够熟练上手。
  &lt;/p&gt;
  
  &lt;p&gt;
    在这种情况下，Google 的做法非常适用。资源有限，你要明白，你的公司能接受的工程师需要具备哪些技能。最重要的一点，是考虑工程师的流转性，他们是否能在各个任务间高效切换，雇用那些能随事情主次、需求变化而随时做出调整的人。年轻的公司不要奢望专业人士。为了把工作做完，每个人都需要尽可能地什么都能干&lt;fnref target=&#34;11171.f&#34; /&gt;。
  &lt;/p&gt;
  
  &lt;p&gt;
    好消息是，如果你只是在找全能型的工程师，只要求他们具备起码的核心技能，那么这个流程会有不错的效果。在公司还小，还在成长时，这常常是最好办法。Google 即便在壮大后，也一直在用这个方法，不过确实有针对一些专业人士对流程做些加强（在我参加他们的面试时，的确被问到一些 JavaScript 的问题）。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-3&#34;&gt;成长&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-3&#34; href=&#34;#i-3&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    我看到的成长型公司最大的问题是，他们未能调整他们的面试流程，来适应公司的成长、团队形态的变化。在你决定聘请专业人士及经验丰富的工程师时，Google 的招聘做法开始遭遇滑铁卢。万金油式的面试做法不再有效，你遇上麻烦了。对一家公司来说，这个阶段是艰难的。如果你以前从没招聘过专业人士，并且对该专业你也没有任何经验，那么你怎么能规划出一个能够准确探测你想要的技能库的面试流程呢？
  &lt;/p&gt;
  
  &lt;p&gt;
    太多的公司在使用「和」的方法。首先，你要符合我们目下对每个工程师起码的核心技能的要求，然后还得有能力做专业的事情。招聘公司们相信，它们在给工程师们保留完整的神奇门槛的同时，还可以招到他们需要的专业人士。这有时确实可行，但大多数时候并不如此。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-4&#34;&gt;理解前端工程师&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-4&#34; href=&#34;#i-4&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    任何一家公司，如果没有相关专业的经验，那么要招聘一个专家就会非常困难。原因很明显：专家在某些事情上有他们的独到之处。他们专注于一些别人不关心的事情，并且下意识地会忽视一些别人关心的事情。大脑只能处理这么多量的数据，要想在特定主题上深入，经常需要丢弃其他一些宽泛的信息。比如，过去有一时，我可以在 Visual Basic 4.0 里做任何事情。但现在，要我写出可以运行的代码就很困难了，我得从网上找。正因为我不想在这种事情上耗费我的精力，所以我才渐渐遗忘。
  &lt;/p&gt;
  
  &lt;p&gt;
    前端工程师当然是专业人士。我们关心一些别人看来十分疯狂的事情：了解各种浏览器间的差异，像素与 em 单位，PNG 与 JPEG，JavaScript APIs 兼容性，如何构建 DOM 来呈现 UI，等等。当我尝试给后端工程师解释一些我做过的很酷的事情时，他们的眼神很快变得呆滞无神。他们永远不会明白我是如何仓促地在 Internet Explorer、Firefox、Chrome 和 Safari 上测试东西，并且让它正常运行起来。他们永远不会明白为什么粗体在某些情形下看起来要比斜体好。他们永远不会明白我是怎么在浏览器里找 bug。当然，他们不必知道。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-5&#34;&gt;什么是重点&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-5&#34; href=&#34;#i-5&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    一直以来，都不断地有人问我，招前端工程师的话，是否需要他们知道计算机科学算法跟数据结构。我简单的回答是：不需要。我看不出，这些是人们成功成为前端工程师的必要条件。原因是大部分前端工程师每天接触的并不是这些。我用算法跟数据结构吗？有时吧，但我一般是在我需要它们的时候才去查找。这些信息在网上很容易找到，而关于这些主题，身边总是有人知道得比我更清楚。
  &lt;/p&gt;
  
  &lt;p&gt;
    我对前端工程师要求的东西，跟传统计算机科学概念没有太多关系。我以前写过什么造就一个好的前端工程师&lt;fnref target=&#34;11171.2&#34; /&gt;和如何面试前端工程师&lt;fnref target=&#34;11171.3&#34; /&gt;，大体上，我现在还认同我过去在这些文章里所写的东西。我要求你热爱 web，理解 HTML，CSS 跟 JavaScript，最重要的，知道怎么组合它们来解决问题。
  &lt;/p&gt;
  
  &lt;p&gt;
    总的来说，我认为面试应该设计来展示一个候选人每天要用的技能。说句好样的，我们来聊聊 O-notation（我开始我的职业7年左右才听到这么个词）或者堆排序（我第一次碰上堆排序是在我参加 Google 面试的时候）实在太简单不过，但这些是否能说明一个人能够成功干成前端工程师？绝对不能。
  &lt;/p&gt;
  
  &lt;p&gt;
    对细枝末节的问题，我也不太感冒。比如，「说三个右边对齐的方法」这种问题。这些问题让我想起高中的测试，只是在测试你反刍信息的能力，而不是让你展现技能。那么你应该问些什么？想想，这个角色，日常要做些什么，然后问些近似的问题。不确定？你总是可以从公司经历过的问题中找一些出来，然后问候选人们他们会怎么处理。我想知道的是，当我给你某些特定类型的问题时，你愿意、并且能够解决它。
  &lt;/p&gt;
  
  &lt;p&gt;
    我想看看你在你的领域里是怎么解决困难的，你怎样梳理问题、不兼容，在你卡壳的时候你的直觉怎样做判断，你是否能够采纳反馈并且将其纳入你的进程里。这些是人们成功的因素。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-6&#34;&gt;我们说给自己的谎&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-6&#34; href=&#34;#i-6&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    找出回文，计算数组总和这些问题之所以无处不在，经常是因为人们认为它们能够在评估一个候选人时提供关键的数据。关于这些问题，我们有各种美好意愿，可惜多是自欺：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        &lt;strong&gt;我们可以洞察他们的思考过程&lt;/strong&gt; &amp;#8211; 胡说八道。大学计算机科学考试上才经常出现的细枝末节或随机问题，可不会让我们洞察一个人的思考过程，但情景模拟可以。扔给一个人一个问题，而这问题跟他日常工作几乎没有关系，根本就无助于我们评估他们的价值。当然，我们可以借此看到他们是如何处理他们并不擅长的情况的。如果这是你所关心的，那么请继续问这类问题。但大部分工程师要处理的是某一特定的问题空间&lt;fnref target=&#34;11171.g&#34; /&gt;。这才是我们的问题应该关心的地方。
      &lt;/p&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        &lt;strong&gt;我们坚持每个人都要达到这个标准&lt;/strong&gt; &amp;#8211; 这是量丈聪明的神方法。你相信，每个人问上一些同样的问题就是给你一把放之四海而皆准的量尺。只是，这样的量尺并不存在。叫迈克尔·乔丹扔个100英里每小时的快球&lt;fnref target=&#34;11171.h&#34; /&gt;，并不能让你洞察他的高超技能。当然，有一些人什么事情都非常擅长，但专业人士为了成为专业人士，倾向于放手一些他们日常中不用的知识。世上没有量丈聪明的方法。
      &lt;/p&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        &lt;strong&gt;目前为止，运行良好&lt;/strong&gt; &amp;#8211; 通常是成长中的公司的喊声。我们过去用这些问题招聪明的人，为什么不再继续？你不再继续的原因是，整个团队的情况已经变了。你现在可以雇用专家，他们在他们领域里知道的比你公司里任何人都要多。你当然可以继续使用你过去一直在用的流程来招聘相同类型的人，但要想用同样的流程招到不同类型的人，那就有点痴人说梦了。
      &lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    在我的职业生涯里，这些东西我是听了一遍又一遍，烦到我看不到歇停的一天。将问题跟候选人做为职员真正要做的事情匹配起来，这才是最重要的。这才是有用信息所在之地。找不到一个单词的回文是个值得关注的小事，但它是否真正告诉你这人雇用后成功的概率呢？
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-7&#34;&gt;结论&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-7&#34; href=&#34;#i-7&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    在我近14年的职业生涯里，我负责招聘了很大数量的前端工程师，我可以自豪地说，我从来没有招错人。他们中有些证明只是不错，有些则是非常杰出，但没有一个是糟糕的。我是怎样做到？是的，我不关心那些他们日常里根本不会碰上的细枝末节问题，我问的都是些我的计划任务里他们未来需要处理的问题，透过这些问题，我可以看到他们的处理方式。在人们的问题空间里了解他们很重要，这对所有的专业人士来说都是一样的，而不仅限于前端工程师 &amp;#8211; 如果我在这篇文章里说得还不够清楚的话。
  &lt;/p&gt;
  
  &lt;p&gt;
    对专业人士来说，参加公司的面试也常是件令人沮丧的事。怎样让事情变好起来？提供反馈。如果你是第一个被雇用的专业人士，对招聘流程提出反馈，看看是不是可以做调整。即便你没有被录用，也可以反馈给你的招聘方，告诉他们，他们问你的这些问题，根本没有给你展示你技能的机会。
  &lt;/p&gt;
  
  &lt;p&gt;
    不幸的是，仍有大量的公司使用万金油方法来招聘工程师，你不会得到一个根据你特殊技能量身定制的面试。请别搞错，招聘是艰难的，而让公司增长更是难上加难。最好的改变方法是从内部发起，所以你可以提供反馈，参与你的公司的招聘，帮助别人有个更好的面试经历。
  &lt;/p&gt;
  
  &lt;footnotes&gt;
    &lt;fn name=&#34;11171.1&#34;&gt;
      &lt;p&gt;
        &lt;a href=&#34;http://css-tricks.com/interviewing-front-end-engineer-san-francisco/&#34;&gt;Interviewing as a Front-End Engineer in San Francisco&lt;/a&gt;
      &lt;/p&gt;
    &lt;/fn&gt;
    
    &lt;fn name=&#34;11171.a&#34;&gt;
      &lt;p&gt;
        by any stretch of the imagination
      &lt;/p&gt;
    &lt;/fn&gt;
    
    &lt;fn name=&#34;11171.b&#34;&gt;
      &lt;p&gt;
        in an attempt to standardize the bar for &amp;#8220;smart&amp;#8221; as an engineer
      &lt;/p&gt;
    &lt;/fn&gt;
    
    &lt;fn name=&#34;11171.c&#34;&gt;
      &lt;p&gt;
        until you showed up on campus as a fully-credentialed employee
      &lt;/p&gt;
    &lt;/fn&gt;
    
    &lt;fn name=&#34;11171.d&#34;&gt;
      &lt;p&gt;
        &lt;a href=&#34;http://en.wikipedia.org/wiki/Heap_sort&#34;&gt;heap sort&lt;/a&gt;
      &lt;/p&gt;
    &lt;/fn&gt;
    
    &lt;fn name=&#34;11171.e&#34;&gt;
      &lt;p&gt;
        site reliability engineer
      &lt;/p&gt;
    &lt;/fn&gt;
    
    &lt;fn name=&#34;11171.f&#34;&gt;
      &lt;p&gt;
        Everyone needs to be as full stack as possible to get work done
      &lt;/p&gt;
    &lt;/fn&gt;
    
    &lt;fn name=&#34;11171.2&#34;&gt;
      &lt;p&gt;
        &lt;a href=&#34;http://www.nczonline.net/blog/2007/08/15/what-makes-a-good-front-end-engineer/&#34;&gt;What makes a good front end engineer&lt;/a&gt;
      &lt;/p&gt;
    &lt;/fn&gt;
    
    &lt;fn name=&#34;11171.3&#34;&gt;
      &lt;p&gt;
        &lt;a href=&#34;http://www.nczonline.net/blog/2010/01/05/interviewing-the-front-end-engineer/&#34;&gt;Interviewing the front end engineer&lt;/a&gt;
      &lt;/p&gt;
    &lt;/fn&gt;
    
    &lt;fn name=&#34;11171.g&#34;&gt;
      &lt;p&gt;
        Most engineers will be dealing with a particular problem space
      &lt;/p&gt;
    &lt;/fn&gt;
    
    &lt;fn name=&#34;11171.h&#34;&gt;
      &lt;p&gt;
        fastball &amp;#8211; 译注，指棒球
      &lt;/p&gt;
    &lt;/fn&gt;
  &lt;/footnotes&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>