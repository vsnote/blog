<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Babel on 陈三</title>
    <link>https://www.zfanw.com/blog/tags/babel/</link>
    <description>Recent content in Babel on 陈三</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Fri, 29 Jan 2016 10:25:05 +0000</lastBuildDate>
    <atom:link href="https://www.zfanw.com/blog/tags/babel/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>babel 6 教程</title>
      <link>https://www.zfanw.com/blog/babel-6.html</link>
      <pubDate>Fri, 29 Jan 2016 10:25:05 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/babel-6.html</guid>
      <description>&lt;div id=&#34;toc_container&#34; class=&#34;ml-l u-floatRight pure-u-1-1 pure-u-sm-2-5 toc_white no_bullets&#34;&gt;
  &lt;nav id=&#34;myaffix&#34;&gt;
  
  &lt;p class=&#34;toc-title&#34;&gt;
    目录
  &lt;/p&gt;
  
  &lt;ul class=&#34;toc-list nav&#34; role=&#34;menu&#34;&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#babel-cli&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;1&lt;/span&gt; babel-cli&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#babel&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;2&lt;/span&gt; babel 插件&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;3&lt;/span&gt; 预置套餐&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#babel-polyfill&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;4&lt;/span&gt; babel-polyfill&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#babel-runtime&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;5&lt;/span&gt; babel-runtime&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#webpack_babel-loader&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;6&lt;/span&gt; webpack 中定义 babel-loader&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#babel-register&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;7&lt;/span&gt; babel-register&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-2&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;8&lt;/span&gt; 扩展阅读&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;&lt;/nav&gt;
&lt;/div&gt;

&lt;div class=&#34;&#34;&gt;
  &lt;p&gt;
    babel 5.x -&gt; 6.x 的变化非常大，许多模块分离出去，只是一些文档还语焉不详，这里略作整理。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;babel-cli&#34;&gt;babel-cli&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heybabel-cli&#34; href=&#34;#babel-cli&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    如果你用过 CoffeeScript，或 TypeScript，那你对它们的编译过程一定很熟悉，&lt;a href=&#34;https://babeljs.io/docs/usage/cli/&#34;&gt;babel-cli&lt;/a&gt; 模块同样也是一个编译的作用。
  &lt;/p&gt;
  
  &lt;p&gt;
    比如有一个 test.js 文件，内容如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;let fun = () =&amp;gt; console.log(&#39;babel&#39;)
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    那么执行 &lt;code&gt;babel test.js&lt;/code&gt;，会输出以下内容：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;&#34;use strict&#34;;

var fun = function fun() {
  return console.log(&#39;babel&#39;);
};
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    除了 &lt;code&gt;babel&lt;/code&gt; 命令外，babel-cli 包另有一个 &lt;code&gt;babel-node&lt;/code&gt; 命令，它近似于 node，只不过它在运行代码前会预先编译 ES2015 的代码。
  &lt;/p&gt;
  
  &lt;p&gt;
    不论是 &lt;code&gt;babel&lt;/code&gt; 命令还是 &lt;code&gt;babel-node&lt;/code&gt; 命令，我们都可以通过命令行参数修改它们的行为，还可以通过新建一个 &lt;code&gt;.babelrc&lt;/code&gt; 文件来配置。
  &lt;/p&gt;
  
  &lt;p&gt;
    但以上是 babel 5.x 的用法。
  &lt;/p&gt;
  
  &lt;p&gt;
    如果在 babel 6 里，执行 &lt;code&gt;babel test.js&lt;/code&gt;，只会输出原样的文本，因为 &lt;code&gt;babel&lt;/code&gt; 不再包含任何 transform 功能，babel 6 里把它们作为插件（plugin）分割出去，需要我们自己定义，见下文说明。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;babel&#34;&gt;babel 插件&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heybabel&#34; href=&#34;#babel&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    在 babel 6 里，要转换 ES2015 的代码，需要自己配置插件，比如上面的示例：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;let fun = () =&amp;gt; console.log(&#39;babel&#39;)
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    我们执行 &lt;code&gt;babel test.js&lt;/code&gt;，babel 不会对文件做任何转换。我们需要一个 &lt;a href=&#34;http://babeljs.io/docs/plugins/transform-es2015-arrow-functions/&#34;&gt;ES2015 arrow functions transform&lt;/a&gt; 插件。
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        安装插件
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;npm install babel-plugin-transform-es2015-arrow-functions
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        在目录下创建一个 .babelrc 文件，用于配置 babel，添加如下内容：
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;{
  &#34;plugins&#34;: [&#34;transform-es2015-arrow-functions&#34;]
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        再执行 &lt;code&gt;babel test.js&lt;/code&gt;，我们得到如下转换结果：
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;let fun = function () {
  return console.log(&#39;babel&#39;);
};
&lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;
        基本上 ES2015/ES7 的各种功能，babel 都提供了相应的插件用于转换，但如果我们要一个一个配置 &amp;#8211; 那就太恼人了。所以 babel 还提供了一个方法：presets。
      &lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i&#34;&gt;预置套餐&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi&#34; href=&#34;#i&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    我们不妨把 presets 理解为套餐，不同套餐有不同的插件组合，比如 &lt;a href=&#34;http://babeljs.io/docs/plugins/preset-es2015/&#34;&gt;ES2015 preset&lt;/a&gt; 里打包了所有用于转换 ES2015 代码的插件，&lt;a href=&#34;http://babeljs.io/docs/plugins/preset-react/&#34;&gt;React preset&lt;/a&gt; 则打包了转换 react.js jsx 语法的插件。它们的用法同上面一致：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        安装 preset
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;npm install babel-preset-es2015
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        配置 .babelrc 文件
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;{
  &#34;presets&#34;: [&#34;es2015&#34;]
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        再执行 &lt;code&gt;babel test.js&lt;/code&gt;，我们会得到与 babel 5.x 一样的转换结果：
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;
var fun = function fun() {
  return console.log(&#39;babel&#39;);
};
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;babel-polyfill&#34;&gt;babel-polyfill&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heybabel-polyfill&#34; href=&#34;#babel-polyfill&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    babel 虽然可以转换各种 ES2015 语法及 jsx，但浏览器未提供原生支持的许多功能还是需要 polyfill，比如 Promise。
  &lt;/p&gt;
  
  &lt;p&gt;
    我们只要在代码中引入 babel-polyfill 就可以模拟出一个 ES2015 的环境，用法如下：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        安装 &lt;code&gt;babel-polyfill&lt;/code&gt;
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;npm install babel-polyfill --save
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        在入口文件中引用：
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;import babel-polyfill
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;babel-runtime&#34;&gt;babel-runtime&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heybabel-runtime&#34; href=&#34;#babel-runtime&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    与 babel-polyfill 一样，babel-runtime 的作用也是模拟 ES2015 环境。只不过，babel-polyfill 是针对全局环境的，引入它，我们的浏览器就好像具备了规范里定义的完整的特性 &amp;#8211; 虽然原生并未实现。
  &lt;/p&gt;
  
  &lt;p&gt;
    babel-runtime 更像是分散的 polyfill 模块，我们可以在自己的模块里单独引入，比如 &lt;code&gt;require(‘babel-runtime/core-js/promise’)&lt;/code&gt; ，它们不会在全局环境添加未实现的方法，只是，这样手动引用每个 polyfill 会非常低效。我们借助 &lt;a href=&#34;http://babeljs.io/docs/plugins/transform-runtime/&#34;&gt;Runtime transform&lt;/a&gt; 插件来自动化处理这一切。
  &lt;/p&gt;
  
  &lt;p&gt;
    至于要用 babel-polyfill 还是 babel-runtime，则需要根据具体需求。举个例子，如果一个库里引用了 babel-polyfill，别人的库也引用了 babel-polyfill，我们很可能会跑两个 babel-polyfill 实例，这里，使用 babel-runtime 会更合适。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;webpack_babel-loader&#34;&gt;webpack 中定义 babel-loader&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heywebpack_babel-loader&#34; href=&#34;#webpack_babel-loader&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    在 &lt;code&gt;webpack.config.js&lt;/code&gt; 里这样定义：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;module: {
  loaders:  [
    {
      test: /\.js/,
      loader: &#39;babel?presets[]=es2015,presets[]=react,plugins[]=transform-runtime&#39;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;babel-register&#34;&gt;babel-register&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heybabel-register&#34; href=&#34;#babel-register&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    &lt;a href=&#34;https://babeljs.io/docs/usage/require/&#34;&gt;babel-register&lt;/a&gt; 是放在 node 里使用的。它的作用是替代 node 的 &lt;code&gt;require&lt;/code&gt; 命令，与 node 自身的 &lt;code&gt;require&lt;/code&gt; 不同，它可以加载 es2015、jsx 等类型文件。
  &lt;/p&gt;
  
  &lt;p&gt;
    用法如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;require(&#39;babel-register&#39;)({presets: [&#39;es2015&#39;, &#39;react&#39;]})
require(&#39;./app&#39;)
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这样我们在 app 文件中就可以使用 es2015 与 jsx 语法了。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-2&#34;&gt;扩展阅读&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-2&#34; href=&#34;#i-2&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;a href=&#34;https://medium.com/@jcse/clearing-up-the-babel-6-ecosystem-c7678a314bf3#a7d5&#34;&gt;Clearing up the Babel 6 Ecosystem&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>