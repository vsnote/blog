<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Require.Js on 陈三</title>
    <link>https://www.zfanw.com/blog/tags/require/index.js/</link>
    <description>Recent content in Require.Js on 陈三</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 18 Jan 2014 22:49:34 +0000</lastBuildDate>
    <atom:link href="https://www.zfanw.com/blog/tags/require.js/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Require.js 教程</title>
      <link>https://www.zfanw.com/blog/require-js.html</link>
      <pubDate>Sat, 18 Jan 2014 22:49:34 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/require-js.html</guid>
      <description>&lt;div id=&#34;toc_container&#34; class=&#34;ml-l u-floatRight pure-u-1-1 pure-u-sm-2-5 toc_white no_bullets&#34;&gt;
  &lt;nav id=&#34;myaffix&#34;&gt;
  
  &lt;p class=&#34;toc-title&#34;&gt;
    目录
  &lt;/p&gt;
  
  &lt;ul class=&#34;toc-list nav&#34; role=&#34;menu&#34;&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;1&lt;/span&gt; 全局环境中的函数&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-2&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;2&lt;/span&gt; 命名空间组织函数&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#Requirejs&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;3&lt;/span&gt; Require.js&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#Requirejs-2&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;4&lt;/span&gt; Require.js 的好处&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-3&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;5&lt;/span&gt; 全局变量的额外说明&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&#34;toc-list__item&#34; role=&#34;menuitem&#34;&gt;
      &lt;a href=&#34;#i-4&#34;&gt;&lt;span class=&#34;toc_number toc_depth_1&#34;&gt;6&lt;/span&gt; 修订历史&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;&lt;/nav&gt;
&lt;/div&gt;

&lt;div class=&#34;&#34;&gt;
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i&#34;&gt;全局环境中的函数&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi&#34; href=&#34;#i&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    我开始学 JavaScript 时，函数通常这么写：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;function fun1() {
  // some code here
}

function fun2() {
  // some other code here
}
...
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    对，函数写在全局环境里。项目如果较小，通常不会有&lt;strong&gt;命名冲突&lt;/strong&gt;问题。
  &lt;/p&gt;
  
  &lt;p&gt;
    但代码多了以后，函数名常常不够用。于是引入命名空间，按功能模块化代码。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-2&#34;&gt;命名空间组织函数&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-2&#34; href=&#34;#i-2&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    在命名空间下，代码可能是这样写：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;var com = com || {};
com.zfanw = com.zfanw || {};

// 模块一
com.zfanw.module1 = (function() {
  // some code here
  return {
    func1: func1,
    ...
  };
}());

// 模块二
com.zfanw.module2 = (function() {
  // some other code here
  return {
    func1: func1,
    ...
  };
}());
...
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    至此，代码冲突的可能性已经很小，但又会有代码依赖、脚本文件管理、阻塞等问题。
  &lt;/p&gt;
  
  &lt;p&gt;
    &lt;a href=&#34;http://requirejs.org/&#34; title=&#34;require.js 官网页面&#34;&gt;Require.js&lt;/a&gt; 可以帮忙解决这些问题。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;Requirejs&#34;&gt;Require.js&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyRequirejs&#34; href=&#34;#Requirejs&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    首先了解下 require.js 里&lt;a href=&#34;http://requirejs.org/docs/api.html#define&#34; title=&#34;require.js 模块是什么&#34;&gt;模块的概念&lt;/a&gt;：
  &lt;/p&gt;
  
  &lt;blockquote&gt;
    &lt;p&gt;
      A module is different from a traditional script file in that it defines a well-scoped object that avoids polluting the global namespace. It can explicitly list its dependencies and get a handle on those dependencies without needing to refer to global objects, but instead receive the dependencies as arguments to the function that defines the module.
    &lt;/p&gt;
  &lt;/blockquote&gt;
  
  &lt;p&gt;
    简单说，有两点：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      模块作用域自成一体，不会污染全局空间
    &lt;/li&gt;
    &lt;li&gt;
      模块明确依赖关系，依赖通过参数传递进入模块作用域，不需要引用全局变量
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;h3&gt;
    定义模块
  &lt;/h3&gt;
  
  &lt;p&gt;
    与上面使用的命名空间方式不同，require.js 使用全局方法 &lt;code&gt;define&lt;/code&gt; 定义模块，形式如下：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;define(id?, dependencies?, factory); // ? 表示可选
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    我且把模块分两种。
  &lt;/p&gt;
  
  &lt;h4&gt;
    无依赖的模块
  &lt;/h4&gt;
  
  &lt;p&gt;
    假如一个模块不依赖其他模块，那么定义起来很简单，比如模块 hello 保存在 hello.js 文件中：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;define(function() {

  // some code here
  return {
    // some public api
  };
});
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;h4&gt;
    有依赖的模块
  &lt;/h4&gt;
  
  &lt;p&gt;
    有依赖的模块要稍复杂，&lt;code&gt;define&lt;/code&gt; 时，我们需罗列模块的依赖情况：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;define([&#39;jquery&#39;], function($) { 
// 比如这个模块，代码依赖 jQuery，require.js 会先加载并执行 `jquery` 模块代码，
// 然后将依赖模块以 `$` 的参数形式传入回调函数中，回调函数将执行结果注册为模块

  // maybe some code here
  return {
    // public api
  };
});
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;h4&gt;
    模块名称
  &lt;/h4&gt;
  
  &lt;p&gt;
    &lt;code&gt;define&lt;/code&gt; 函数共有三个参数，第一个参数 id 定义模块名称，这个名称的格式即 &lt;code&gt;baseUrl&lt;/code&gt; 的路径除去文件格式，比如 &lt;code&gt;baseUrl&lt;/code&gt; 为 js 目录，一个模块放在 js/libs/hi.js 里，则模块名称：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;define(&#39;libs/hi&#39;, [&#39;jquery&#39;], function($){......});
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    这种定义形式的好处是，模块不可能冲突，因为操作系统不允许同一目录下存在同名文件。但也因此 require.js 建议我们不要设置模块名称，因为设置了 &amp;#8216;libs/hi&amp;#8217; 的模块名称后，模块就必须放在 js/libs 目录下的 hi.js 文件中，要是我们移动位置，模块名称要跟着改变。
  &lt;/p&gt;
  
  &lt;h3&gt;
    使用模块
  &lt;/h3&gt;
  
  &lt;p&gt;
    在定义好模块后，我们该怎么使用？Require.js 同样提供了一个全局函数 &lt;code&gt;require&lt;/code&gt;（与 &lt;code&gt;requirejs&lt;/code&gt; 等效）。
  &lt;/p&gt;
  
  &lt;p&gt;
    &lt;code&gt;require&lt;/code&gt; 函数加载依赖并执行回调：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;require([&#39;jquery&#39;], function($) { 

// 代码加载 jquery 依赖，然后执行回调代码
  console.log($);
});
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    举一个简单例子。我有一个文件夹，文件结构如下：
  &lt;/p&gt;
  
  &lt;ul&gt;
    &lt;li&gt;
      index.html
    &lt;/li&gt;
    &lt;li&gt;
      js/ &lt;ul&gt;
        &lt;li&gt;
          main.js
        &lt;/li&gt;
        &lt;li&gt;
          require.js
        &lt;/li&gt;
        &lt;li&gt;
          jquery.js
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
  
  &lt;p&gt;
    这里 jquery.js 已经注册为 AMD 模块，则 HTML 文件里这样引用 require.js：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;&amp;lt;script src=&#34;js/require.js&#34; data-main=&#34;js/main&#34;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    require.js 会检查 &lt;code&gt;data-main&lt;/code&gt; 属性值，这里是 &lt;code&gt;js/main&lt;/code&gt;，根据设定，它会加载 js 目录下的 main.js 文件。
  &lt;/p&gt;
  
  &lt;p&gt;
    main.js 文件里，我只做一件事，用 jQuery 方法取得当前窗口的宽度：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;require([&#39;jquery&#39;], function($) {
    var w = $(window).width();
    console.log(w);
});
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    是的，执行代码就这么简单。
  &lt;/p&gt;
  
  &lt;h3&gt;
    非 AMD 规范的模块
  &lt;/h3&gt;
  
  &lt;p&gt;
    但事情远没有我们想像中美好，AMD 只是一种社区规范，并非标准，而且在它出来以前，已经有各种各样的流行库存在，更不用说我们自己早期写的代码，所以我们一定会遇上非 AMD 规范的模块。
  &lt;/p&gt;
  
  &lt;p&gt;
    为了让 require.js 能够加载它们，并且自动识别、载入依赖，我们有两种选择：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      自己动手，使用 &lt;code&gt;define&lt;/code&gt; 重写代码
    &lt;/li&gt;
    &lt;li&gt;
      使用 Require.js 提供的配置选项 shim
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    比如我手上一个项目，因为某种原因，还在用 jQuery 1.4.1 版本，而 jQuery 从 1.7 版本开始才注册为 AMD 模块，我要在 require.js 中使用 jQuery 1.4.1 的话，就需要先做 shim：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;require.config({
    shim: {
        &#39;jquery-1.4.1&#39;: { // &amp;lt;= 这个是相对于 main.js 的路径
            exports: &#39;jQuery&#39; // &amp;lt;= 这个值需要稍加注意，稍后会提及
        },
        &#39;libs/jquery-throttle-debounce.min&#39;: { // &amp;lt;= jQuery 插件
            deps: [&#39;jquery-1.4.1&#39;] //无需 exports，因为我们只是在增强 jQuery 功能
        }
    },
});
require([&#39;jquery-1.4.1&#39;, &#39;libs/jquery-throttle-debounce.min&#39;], function($){
    console.log($.debounce);
});
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    写完 shim，发现 &lt;code&gt;jquery-1.4.1&lt;/code&gt;、&lt;code&gt;libs/jquery-throttle-debounce.min&lt;/code&gt; 这样的名称太长。这里我们又有两种选择：
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      修改 js 文件名
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;
        使用 require.js 提供的配置项 &lt;code&gt;paths&lt;/code&gt; 给模块 ID 指定对应的真实文件路径
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;require.config({
paths: {
    &#39;jquery&#39;: &#39;jquery-1.4.1&#39;, // &amp;lt;= 模块 jquery 指向 js/jquery-1.4.1.js 文件
    &#39;debounce&#39;: &#39;libs/jquery-throttle-debounce.min&#39;
},
shim: {
    &#39;jquery&#39;: {
        exports: &#39;$&#39;
    },
    &#39;debounce&#39;: {
        deps: [&#39;jquery&#39;] 
    }
}
});
require([&#39;jquery&#39;, &#39;debounce&#39;], function($){
console.log($.debounce);
});
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;p&gt;
    这样，引用起来就方便很多了。
  &lt;/p&gt;
  
  &lt;p&gt;
    另外，需要注意 shim 中的 &lt;code&gt;exports&lt;/code&gt; 项。我们如果把 exports 值改成非全局变量名，就会导致传入回调的对象变成 undefined，举个例子：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;require.config({
    paths: {
        &#39;jquery&#39;: &#39;jquery-1.4.1&#39;, 
    },
    shim: {
        &#39;jquery&#39;: {
            exports: &#39;hellojQuery&#39; // 这里我把 exports 值设置为 jQuery/$ 以外的值
        }
    }
});
require([&#39;jquery&#39;], function($){
    console.log($);// 这里，会显示 undefined
});
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;p&gt;
    其他模块在做 shim 时同理，比如 underscore 需要 exports 为 &lt;code&gt;_&lt;/code&gt;。
  &lt;/p&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;Requirejs-2&#34;&gt;Require.js 的好处&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyRequirejs-2&#34; href=&#34;#Requirejs-2&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    说了这么多，Require.js 到底解决了我们什么问题？
  &lt;/p&gt;
  
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;
        并行加载
      &lt;/p&gt;
      
      &lt;p&gt;
        我们知道，&lt;code&gt;&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt; 标签会阻塞页面 DOM 树的构建，比如加载 a.js，页面需要等它加载完成并执行结束后才能继续构建 DOM 树。而 require.js 的模块允许&lt;strong&gt;并行下载&lt;/strong&gt;，没有依赖关系的模块还可以并行执行，大大加快页面访问速度。
      &lt;/p&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        不愁依赖
      &lt;/p&gt;
      
      &lt;p&gt;
        在我们定义模块的时候，我们就已经决定好模块的依赖 &amp;#8211; c 依赖 b，b 又依赖 a。当我想用 c 模块的功能时，我只要在 require函数的依赖里指定 c：
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;require([&#39;c&#39;], function(c) {...});
&lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;
        至于 c 依赖的模块，c 依赖的模块的依赖模块&amp;#8230; 等等，require.js 会帮我们打理。
      &lt;/p&gt;
      
      &lt;p&gt;
        而传统的 script 办法，我们必须明确指定所有依赖顺序：
      &lt;/p&gt;
      
      &lt;pre&gt;&lt;code&gt;&amp;lt;script src=&#34;js/a.js&#34;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&#34;js/b.js&#34;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&#34;js/c.js&#34;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
      
      &lt;p&gt;
        换句话说，传统的 script 方法里，我们极可能要靠记忆或者检查模块内容这种方式来确定依赖 &amp;#8211; 效率太低，容易出错。
      &lt;/p&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
      &lt;p&gt;
        减少全局冲突
      &lt;/p&gt;
      
      &lt;p&gt;
        通过 define 的方式，我们大量减少全局变量，这样代码冲突的概率基本为零。
      &lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;h2 class=&#34;storycontent-h2&#34;&gt;
    &lt;span id=&#34;i-3&#34;&gt;全局变量的额外说明&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-3&#34; href=&#34;#i-3&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
  &lt;/h2&gt;
  
  &lt;p&gt;
    有一点需要说明，require.js 环境中并不是只有 &lt;code&gt;define&lt;/code&gt; 和 &lt;code&gt;require&lt;/code&gt; 两个全局变量。许多库都会向全局环境中暴露变量，以 jQuery 为例，1.7 版本后，它虽然注册自己为 AMD 模块，但同时也向全局环境中暴露 &lt;code&gt;jQuery&lt;/code&gt; 与 &lt;code&gt;$&lt;/code&gt;。所以下面的代码中，虽然我们没有向回调函数传入一份引用，jQuery/$ 同样是存在的：
  &lt;/p&gt;
  
  &lt;pre&gt;&lt;code&gt;require([&#39;jquery&#39;], function(){ 
  console.log(jQuery); 
  console.log($);
});
&lt;/code&gt;&lt;/pre&gt;
  
  &lt;div class=&#39;timeline&#39;&gt;
    &lt;h2 class=&#34;storycontent-h2&#34;&gt;
      &lt;span id=&#34;i-4&#34;&gt;修订历史&lt;/span&gt;&lt;a title=&#34;标题链接地址&#34; class=&#34;u-floatRight hidden&#34; id=&#34;heyi-4&#34; href=&#34;#i-4&#34;&gt;&lt;span class=&#34;&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/span&gt;&lt;/a&gt;
    &lt;/h2&gt;
    
    &lt;ol&gt;
      &lt;li&gt;
        &lt;span itemprop=&#39;dateModified&#39;&gt;2015-06-21&lt;/span&gt;：修改排版，删除不必要文字
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>