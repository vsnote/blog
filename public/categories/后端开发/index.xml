<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>后端开发 on 陈三</title>
    <link>https://www.zfanw.com/blog/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/</link>
    <description>Recent content in 后端开发 on 陈三</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 13 Jul 2016 03:00:06 +0000</lastBuildDate>
    <atom:link href="https://www.zfanw.com/blog/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>PhoenixFramework 部署注意事项</title>
      <link>https://www.zfanw.com/blog/phoenixframework-deploy.html</link>
      <pubDate>Wed, 13 Jul 2016 03:00:06 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/phoenixframework-deploy.html</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;编译环境与生产环境&lt;a href=&#34;http://www.phoenixframework.org/docs/advanced-deployment&#34;&gt;应该一致&lt;/a&gt;，&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We need to be sure that the architectures for both our build and hosting environments are the same, e.g. 64-bit Linux -&amp;gt; 64-bit Linux. If the architectures don&amp;#8217;t match, our application might not run when deployed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;比如我在 macOS 上编译的，放到 CentOS 7 上，就跑不起来了。最好在本地弄个与生产环境接近的虚拟机用于编译。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;生产环境中一样需要安装 &lt;a href=&#34;https://www.erlang-solutions.com/resources/download.html&#34;&gt;Erlang&lt;/a&gt; 与 &lt;a href=&#34;http://elixir-lang.org/install.html&#34;&gt;elixir&lt;/a&gt;，
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用 &lt;a href=&#34;https://hexdocs.pm/exrm/getting-started.html&#34;&gt;exrm&lt;/a&gt; 编译不代表万事俱备，生产环境下，Erlang 与 elixir 都需要装一遍。但 PhoenixFramework 就不需要在生产环境中安装了，它只是开发使用。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>no matching action clause to process request</title>
      <link>https://www.zfanw.com/blog/no-matching-action-clause-to-process-request.html</link>
      <pubDate>Wed, 08 Jun 2016 03:15:58 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/no-matching-action-clause-to-process-request.html</guid>
      <description>&lt;p&gt;本文基于 phoenix framework 1.1.4。&lt;/p&gt;

&lt;p&gt;我在 phoenix 项目里，定义了这样一个函数，用来过滤用户：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  def index(conn, %{&amp;quot;email&amp;quot; =&amp;gt; email, &amp;quot;codename&amp;quot; =&amp;gt; codename}) do
    # ... get the user with the filters
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问以下两个路径：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:4000/api/users?codename=Plator&#34;&gt;http://localhost:4000/api/users?codename=Plator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:4000/api/users?email=chenxsan@example.com&#34;&gt;http://localhost:4000/api/users?email=chenxsan@example.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;均会报告以下错误：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Phoenix.ActionClauseError at GET /api/users&lt;/p&gt;

&lt;p&gt;bad request to IngressRun.UserController.index, no matching action clause to process request&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但如果访问&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://localhost:4000/api/users?email=chenxsan@example.com&amp;amp;codename=Plator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;却是能正常响应的。&lt;/p&gt;

&lt;p&gt;看&lt;a href=&#34;http://elixirforum.com/t/am-i-doing-this-right-pattern-matching-in-controller-methods/249/2&#34;&gt;这篇&lt;/a&gt;的意思，我有多少个过滤条件，过滤条件组合一下，我就要定义多少个 action &amp;#8211; 并不现实，也很傻。&lt;/p&gt;

&lt;p&gt;比较靠谱的做法是&lt;a href=&#34;https://medium.com/@kaisersly/filtering-from-params-in-phoenix-27b85b6b1354#.oebhg9kbm&#34;&gt;这一篇&lt;/a&gt;。不过它的示例里：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Post
|&amp;gt; where(^filters)
|&amp;gt; Repo.all
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我的测试中，会报一个编译错误：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;cannot use ^filters outside of match clauses&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;换成以下形式就没问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from(p in Post, where: ^filters) |&amp;gt; Repo.all
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外我好奇的是，为什么这种过滤资源的常用功能，许多框架都不集成，phoenix 里我没见到，express.js 里也没有。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Elixir Guardian 库的 current_user</title>
      <link>https://www.zfanw.com/blog/elixir-guardian-authentication-current_user.html</link>
      <pubDate>Sun, 22 May 2016 04:50:32 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/elixir-guardian-authentication-current_user.html</guid>
      <description>&lt;p&gt;如果你用 &lt;a href=&#34;http://www.phoenixframework.org/docs/sessions&#34;&gt;Phoenix framework 的 session&lt;/a&gt; 管理会话，那么你的登录函数大概是这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  def login(conn, user) do
    conn
    |&amp;gt; assign(:current_user, user)
    |&amp;gt; put_session(:user_id, user.id)
    |&amp;gt; configure_session(renew: true)
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的 &lt;code&gt;assign(:current_user, user)&lt;/code&gt; 允许我们在模板中直接使用 &lt;code&gt;@current_user&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在 &lt;a href=&#34;https://github.com/ueberauth/guardian&#34;&gt;Guardian&lt;/a&gt; 下，因为我们把会话管理交给 guardian，所以代码大概是这么写的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;case IngressRun.Auth.login_by_email_and_pass(conn, email, pass, repo: Repo) do
      {:ok, user} -&amp;gt;
        conn
        |&amp;gt; Guardian.Plug.sign_in(user)
        |&amp;gt; put_flash(:info, &amp;quot;Welcome back!&amp;quot;)
        |&amp;gt; redirect(to: page_path(conn, :index))
      {:error, _reason, conn} -&amp;gt;
        conn
        |&amp;gt; put_flash(:error, &amp;quot;Invalid email/password combination&amp;quot;)
        |&amp;gt; render(&amp;quot;new.html&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么有一个问题，在 guardian 下，我们的模板要怎样取到 &lt;code&gt;current_user&lt;/code&gt; 的值？&lt;/p&gt;

&lt;p&gt;guardian 提供了方法，让我们取得当前的用户资源：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Guardian.Plug.current_resource(conn)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以要在模板中使用 &lt;code&gt;@current_user&lt;/code&gt;，我们的 controller 函数大概是这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defmodule IngressRun.AboutController do
  use IngressRun.Web, :controller

  def index(conn, _params) do
    conn
    |&amp;gt; assign(:current_user, Guardian.Plug.current_resource(conn))
    |&amp;gt; render(&amp;quot;index.html&amp;quot;)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;guardian 还提供了 Phoenix 助手，所以在 controller 中我们可以把上面的代码改写如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defmodule IngressRun.AboutController do
  use IngressRun.Web, :controller
  use Guardian.Phoenix.Controller

  def index(conn, _params, user, _claims) do
    conn
    |&amp;gt; assign(:current_user, user)
    |&amp;gt; render(&amp;quot;index.html&amp;quot;)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但因为这个 &lt;code&gt;current_user&lt;/code&gt; 每个页面都要用到，则每个 controller 里的每个 action 都要写一遍 &lt;code&gt;assign(:current_user, user)&lt;/code&gt;，未免太棘手。&lt;/p&gt;

&lt;p&gt;这时我们就可以用上 &lt;a href=&#34;https://github.com/elixir-lang/plug#the-plugconn&#34;&gt;plug&lt;/a&gt; &amp;#8211; 如果你写过 express.js，则这个概念与中间件类似：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;plug :assign_current_user
# ...
defp assign_current_user(conn, _opts) do
    assign(conn, :current_user, Guardian.Plug.current_resource(conn))
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以把这个 plug 定义在 controller 里，但如前面所说的，整个站点都要用到它，则定义在 &lt;code&gt;pipeline&lt;/code&gt; 里会更合适，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pipeline :browser_session do
    plug Guardian.Plug.VerifySession
    plug Guardian.Plug.LoadResource
    plug :assign_current_user
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就可以继续在模板中使用 &lt;code&gt;&amp;lt;%= @current_user %&amp;gt;&lt;/code&gt; 了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Express 路由</title>
      <link>https://www.zfanw.com/blog/express-js-router-edge-case.html</link>
      <pubDate>Thu, 12 May 2016 12:06:15 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/express-js-router-edge-case.html</guid>
      <description>&lt;p&gt;如果你的网站很小，又或者你不介意一个文件有成千上万行的代码，那大可以不必深入理解 express.js 的路由，只要知道 &lt;code&gt;app.get&lt;/code&gt; 一类的简单用法就行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import express from &#39;express&#39;
const app = express()
/**
 * @api {get} / 读取 xx
 */
app.get(&#39;/&#39;, (req, res, next) =&amp;gt; {})

/**
 * @api {post} / 创建 xx
 */
app.post(&#39;/&#39;, (req, res, next) =&amp;gt; {})

/**
 * @api {delete} /:id 删除 xx
 */
app.delete(&#39;/:id&#39;, (req, res, next) =&amp;gt; {})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只是事情远没那么简单。&lt;/p&gt;

&lt;p&gt;比如上面的 &lt;code&gt;post&lt;/code&gt; 与 &lt;code&gt;delete&lt;/code&gt;，需要用户登录后才能执行，则你就需要一个检查用户是否已登录的方法，如果已经登录，则继续执行，否则重定向到登录页。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @function restrict 验证 session 中 token 是否存在
 */
function restrict (req, res, next) {
  if (!req.session.token) {
    return res.redirect(&#39;/login&#39;)
  } else {
    next()
  }
}
app.post(&#39;/&#39;, restrict, (req, res, next) =&amp;gt; {})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://expressjs.com/en/api.html#app.METHOD&#34;&gt;app.METHOD&lt;/a&gt; 的用法是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.METHOD(path, callback [, callback ...])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恰如前面的例子中所看到的，我们可以给 &lt;code&gt;app.post&lt;/code&gt; 传递多个 callback，callback 会按顺序执行，除非前头排队执行的不调 &lt;code&gt;next()&lt;/code&gt;。譬如上面的 &lt;code&gt;restrict&lt;/code&gt;，在检查到 &lt;code&gt;token&lt;/code&gt; 不存在后，它就直接 &lt;code&gt;return&lt;/code&gt; 了，没有 &lt;code&gt;next()&lt;/code&gt;，再后面的 callback 函数就不再执行。而在 &lt;code&gt;token&lt;/code&gt; 存在的情况下，它执行了 &lt;code&gt;next()&lt;/code&gt;，即继续下一个 callback。&lt;/p&gt;

&lt;p&gt;在 &lt;a href=&#34;https://en.wikipedia.org/wiki/Representational_state_transfer&#34;&gt;RESTful&lt;/a&gt; 的规范里，我们的操作是围绕着资源（resources）的，比如这个博客，它有 posts 这个资源，针对它的增删改查（CRUD）在路由中体现为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @api {get} /posts 读取所有博客
 */
app.get(&#39;/posts&#39;, callback)

/**
 * @api {post} /posts 创建博客
 */
app.post(&#39;/posts&#39;, callback)

/**
 * @api {get} /posts/:postID 读取 id 为 postID 值的博客
 */
app.get(&#39;/posts/:postID&#39;, callback)

/**
 * @api {patch} /posts/:postID 修改 id 为 postID 值的博客
 */
app.patch(&#39;/posts/:postID&#39;, callback)

/**
 * @api {delete} /posts/:postID 删除 id 为 postID 值的博客
 */
app.delete(&#39;/posts/:postID&#39;, callback)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们为什么要把 &lt;code&gt;/posts/:postID&lt;/code&gt; 写上三遍甚至多遍？假如后期 URL 想做一点调整，我们就要改三次了。&lt;/p&gt;

&lt;p&gt;我们可以使用 &lt;a href=&#34;http://expressjs.com/en/api.html#app.route&#34;&gt;app.route&lt;/a&gt; 对上面的代码做一点改进：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.route(&#39;/posts&#39;)
  .get(callback)
  .post(callback)

app.route(&#39;/posts/:postID&#39;)
  .get(callback)
  .patch(callback)
  .delete(callback)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但我的博客上并不仅仅 posts 这类资源，还有 comments 资源，还有 users 资源，于是，我们的路由会慢慢变成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.route(&#39;/users&#39;)
  .all(restrict)
  .get(callback)
  .post(callback)

app.route(&#39;/posts&#39;)
  .get(callback)
  .post(callback)

app.route(&#39;/posts/:postID&#39;)
  .get(callback)
  .patch(callback)
  .delete(callback)

app.route(&#39;/posts/:postID/comments&#39;)
  .get(callback)
  .post(callback)

app.route(&#39;/posts/:postID/comments/:commentID&#39;)
  .get(callback)
  .patch(callback)
  .delete(callback)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想像一下，每个 &lt;code&gt;callback&lt;/code&gt; 乐观点，假设能用 20 行代码解决，我们的这个路由文件也至少要上 500 行。假如再加上注释，则这个文件估计要有上千行。rMBP 下，14 号大小，编辑器一屏能显示 37 行。&lt;/p&gt;

&lt;p&gt;分家的时候到了。&lt;/p&gt;

&lt;p&gt;怎么分？&lt;/p&gt;

&lt;p&gt;如果 &lt;code&gt;app.route&lt;/code&gt; 肯接收第二个参数就好了，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.route(&#39;/posts&#39;, callback)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就可以在单独的文件中定义 &lt;code&gt;/posts&lt;/code&gt; 路径下所有处理逻辑，然后 &lt;code&gt;import&lt;/code&gt; 进来给 &lt;code&gt;app.route&lt;/code&gt; 调用。&lt;/p&gt;

&lt;p&gt;但 &lt;code&gt;app.route&lt;/code&gt; 只接收一个 &lt;code&gt;path&lt;/code&gt; 参数。&lt;/p&gt;

&lt;p&gt;这里，我们有两个问题要解决：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如何把 &lt;code&gt;app.route(path)&lt;/code&gt; 后所附的各种逻辑独立到一个文件中&lt;/li&gt;
&lt;li&gt;如何将独立文件中的处理逻辑与 url 匹配起来&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一个问题的解决办法是使用 &lt;a href=&#34;http://expressjs.com/en/api.html#router&#34;&gt;Router&lt;/a&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let router = express.Router()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就创建了一个 Router 对象，Router 是一个 mini 的 app，所以我们前面所写的 &lt;code&gt;app.METHOD&lt;/code&gt; 的代码，Router 都可以同样使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let router = express.Router()
router.route(&#39;/&#39;)
  .all(restrict)
  .get(callback)
  .post(callback)
export default router
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就可以将某个 url 下对应的各种处理逻辑独立到一个文件里。&lt;/p&gt;

&lt;p&gt;接下来解决第二个问题。&lt;/p&gt;

&lt;p&gt;我们要用到 &lt;code&gt;app.use&lt;/code&gt;，它的用法与我们想像的 &lt;code&gt;app.route&lt;/code&gt; 的近似：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.use([path,] function [, function...])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们首先将独立文件 &lt;code&gt;import&lt;/code&gt; 进来，然后使用 &lt;code&gt;app.use&lt;/code&gt; 将它与 url 匹配起来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import userRouter from &#39;./userRouter&#39;
app.use(&#39;/users&#39;, userRouter)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，app 里所有 &lt;code&gt;/users/*&lt;/code&gt; 的请求都会进入 &lt;code&gt;userRouter&lt;/code&gt; 这个 mini app 中处理。&lt;/p&gt;

&lt;p&gt;但是我们要注意，&lt;code&gt;app.use(&#39;/users&#39;, userRouter)&lt;/code&gt; 这样的写法下，userRouter 中要匹配 &lt;code&gt;/users&lt;/code&gt; 路径，并不是下面这种写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.route(&#39;/users&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.route(&#39;/&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是的，我们的 url 路径现在分散了，一部分在入口文件中，一部分在 Router 文件中，如果我们切割得很厉害，则一个完整的 API 路径，会分散在多个文件中。假如代码不写注释，也不生成文档，则查阅 API 路径会非常麻烦。就我目前的经验，并没有一个很好的解决办法 &amp;#8211; 除了文档中标注。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：以上代码均指 express.js 4.x 的 API。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mongoose populate 预填充字段</title>
      <link>https://www.zfanw.com/blog/mongoose-populate.html</link>
      <pubDate>Tue, 10 May 2016 12:14:00 +0000</pubDate>
      
      <guid>https://www.zfanw.com/blog/mongoose-populate.html</guid>
      <description>

&lt;p&gt;举这个博客说，它有两个模型（model），&lt;code&gt;User&lt;/code&gt; 和 &lt;code&gt;Post&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;一个 User 可以有多篇 Post，创建 Post 的时候，我们要存一个作者信息，假定是 &lt;code&gt;author&lt;/code&gt; 字段，它的值指向用户的 &lt;code&gt;_id&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var mongoose = require(&#39;mongoose&#39;)
  , Schema = mongoose.Schema
var userSchema = Schema({
  name: String
})
var postSchema = Schema({
  title: String,
  content: String,
  author: String
})
var User = mongoose.model(&#39;User&#39;, userSchema)
var Post = mongoose.model(&#39;Post&#39;, postSchema)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上是我还不知道 &lt;code&gt;populate&lt;/code&gt; 时的写法，&lt;code&gt;Post&lt;/code&gt; 模型里，&lt;code&gt;author&lt;/code&gt; 指向了用户的 &lt;code&gt;_id&lt;/code&gt;，这样，每次查询 post 都需要查询两个模型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Post.findOne({title: &#39;mongoose populate&#39;}).then((doc) =&amp;gt; {
  User.findOne({_id: doc.author}).then((user) =&amp;gt; {
    return Object.assign({}, doc, {author: user})
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但 mongoose 提供了 &lt;code&gt;populate&lt;/code&gt; 方法，可以在查询时，预先填充字段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var mongoose = require(&#39;mongoose&#39;)
  , Schema = mongoose.Schema
var userSchema = Schema({
  name: String
})
// 这里，我们给 author 定义了一个 `ref` 指向了 User 模型
var postSchema = Schema({
  title: String,
  content: String,
  author: {
    type: mongoose.Schema.Types.ObjectId,
    ref: &#39;User&#39;
  }
})
// `findOne` 勾子，在使用 `findOne` 时，mongoose 会预填充 `author` 字段的数据
postSchema.pre(&#39;findOne&#39;, function (next) {
  this.populate(&#39;author&#39;, &#39;name&#39;)
  next()
})
var User = mongoose.model(&#39;User&#39;, userSchema)
var Post = mongoose.model(&#39;Post&#39;, postSchema)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们的查询 post 语句可以写成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Post.findOne({title: &#39;mongoose populate&#39;}).then((doc) =&amp;gt; {
  return doc
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;doc&lt;/code&gt; 里的 &lt;code&gt;author&lt;/code&gt; 是一个对象，包含一个 &lt;code&gt;_id&lt;/code&gt; 和一个 &lt;code&gt;name&lt;/code&gt;，非常便捷、简洁。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://mongoosejs.com/docs/populate.html&#34;&gt;Mongoose Query Population v4.4.16&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>